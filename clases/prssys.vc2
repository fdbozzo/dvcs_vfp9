*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="prssys.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS cmaddparam AS commandbutton 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: funcion
	*</DefinedPropArrayMethod>

	AutoSize = .F.
	Caption = "\<Más Parámetros"
	FontSize = 8
	funcion = .F.
	Height = 25
	Name = "cmaddparam"
	Width = 94
	
	PROCEDURE Click
		LOCAL objfun,lnOrd,lcCnt
		objfun=NEWOBJECT("prsfun","clases\prssys.vcx")
		DO case
			CASE this.funcion="A"
				lnOrd=objfun.AddCntParam(this.parent,.t.)
			CASE this.funcion="R"
				LnOrd=objfun.AddCntProp(this.Parent,.t.)
		ENDCASE
		
		obfjun=null
		*!*	lcCnt="oCnt"+TRANSFORM(lnOrd)
		*!*	this.Parent.&lcCnt..gText1.setfocus
		
	ENDPROC

	PROCEDURE Init
		this.funcion="A"
		* A PARAM
		* R PROPERTY
	ENDPROC

ENDDEFINE

DEFINE CLASS cmbdir AS combobox 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	BorderColor = 114,136,141
	DisabledBackColor = 220,228,224
	DisabledForeColor = 0,0,0
	FontSize = 8
	Height = 22
	Name = "cmbdir"
	Sorted = .T.
	SpecialEffect = 1
	Style = 2
	Width = 100

ENDDEFINE

DEFINE CLASS cmgo AS commandbutton 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	Caption = "\<Go"
	FontSize = 8
	Height = 22
	Name = "cmgo"
	Width = 40
	
	PROCEDURE Click
		IF PEMSTATUS(_screen,"RespGo",5)
			_screen.respgo=.t.
		ENDIF
		
		Thisform.Release
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmparam AS commandbutton 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: funcion
	*</DefinedPropArrayMethod>

	Caption = "\<Aceptar"
	FontSize = 8
	funcion = A
	Height = 25
	Name = "cmparam"
	Width = 55
	
	PROCEDURE Click
		LOCAL obret,lExit
		obRet=null
		FOR EACH oCnt IN thisform.Controls
			IF oCnt.BaseClass="Container" AND !INLIST(UPPER(oCnt.name),"OCLOSE")
				FOR EACH oText IN ocnt.Controls
					IF INLIST(oTExt.baseClass,"Textbox","Combobox","Editbox","Checkbox")
						IF EMPTY(otext.value)
							obRet=oText
							lExit=.t.
							EXIT
						ENDIF
					ENDIF
					
				NEXT
			
			ENDIF
			IF lExit
				EXIT
			ENDIF
		ENDFOR
		lcCartel=""
		DO case
			CASE this.funcion="A"
				lcCartel="CmParam Revision"	
			CASE this.funcion="R"
				lcCartel="CmProper Revision"
		ENDCASE
		
		
		
		IF !ISNULL(obRet)
			MESSAGEBOX("Faltan Valores",0,lcCartel)
			obREt.setfocus
			RETURN
		ENDIF
		
		IF PEMSTATUS(_screen,"RespParam",5)
			_screen.RespParam=.t.
		ENDIF
		
		thisform.Release
		
		
		
		
	ENDPROC

	PROCEDURE Init
		THIS.FUNCION="A"
	ENDPROC

ENDDEFINE

DEFINE CLASS cntbackup AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape3d1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GMARCO1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDestino" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cnt1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cnt1.Gmarco3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cnt1.Cmbdir1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cnt1.lblProyectos" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cnt1.Gmarco2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cnt1.lblQuitar" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdLimpiar" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRescue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdBackup" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtDestino" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: changecaption
		*m: cleancaption
		*m: getcmbdir
		*m: getmedida
		*m: limpiar
		*p: esinit
		*p: fileconf
		*p: fileused
		*p: folderback
		*p: forbiden
		*p: lastheight
		*p: lastwidth
		*p: noresize
		*p: rootapp		&& Ruta de la aplicación
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	esinit = .T.
	fileconf = 
	fileused = .F.
	folderback = .F.
	forbiden = .F.
	Height = 119
	lastheight = 0
	lastwidth = 0
	Name = "cntbackup"
	noresize = .F.
	rootapp = 		&& Ruta de la aplicación
	Width = 475

	ADD OBJECT 'cmdBackup' AS commandbutton WITH ;
		BackColor = 231,237,234, ;
		Caption = "\<Backup", ;
		DisabledBackColor = 221,226,222, ;
		FontSize = 8, ;
		Height = 21, ;
		Left = 300, ;
		Name = "cmdBackup", ;
		TabIndex = 10, ;
		Top = 27, ;
		Width = 55
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdLimpiar' AS commandbutton WITH ;
		BackColor = 231,237,234, ;
		Caption = "\<Limpiar", ;
		DisabledBackColor = 221,226,222, ;
		FontSize = 8, ;
		Height = 21, ;
		Left = 410, ;
		Name = "cmdLimpiar", ;
		TabIndex = 8, ;
		Top = 27, ;
		Width = 55
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdRescue' AS commandbutton WITH ;
		BackColor = 231,237,234, ;
		Caption = "\<Rescue", ;
		DisabledBackColor = 221,226,222, ;
		FontSize = 8, ;
		Height = 21, ;
		Left = 356, ;
		Name = "cmdRescue", ;
		TabIndex = 7, ;
		Top = 27, ;
		Width = 55
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'Cnt1' AS container WITH ;
		BackStyle = 0, ;
		BorderWidth = 0, ;
		Height = 22, ;
		Left = 3, ;
		Name = "Cnt1", ;
		TabIndex = 1, ;
		Top = 4, ;
		Width = 332
		*< END OBJECT: BaseClass="container" />

	ADD OBJECT 'Cnt1.Cmbdir1' AS cmbdir WITH ;
		DisabledBackColor = 242,247,243, ;
		Height = 21, ;
		Left = 67, ;
		Name = "Cmbdir1", ;
		Top = 1, ;
		Width = 224
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="combobox" />

	ADD OBJECT 'Cnt1.Gmarco2' AS gmarco WITH ;
		Height = 21, ;
		Left = 290, ;
		Name = "Gmarco2", ;
		Top = 1, ;
		Width = 41
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Cnt1.Gmarco3' AS gmarco WITH ;
		Height = 21, ;
		Left = 1, ;
		Name = "Gmarco3", ;
		Top = 1, ;
		Width = 67
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Cnt1.lblProyectos' AS glab WITH ;
		Caption = "Proyectos", ;
		ForeColor = 0,0,255, ;
		Left = 6, ;
		MousePointer = 15, ;
		Name = "lblProyectos", ;
		ToolTipText = "Seleccione Carpeta de Scripts", ;
		Top = 4
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Cnt1.lblQuitar' AS glab WITH ;
		Caption = "Quitar", ;
		Enabled = .F., ;
		ForeColor = 255,0,0, ;
		Left = 295, ;
		MousePointer = 15, ;
		Name = "lblQuitar", ;
		ToolTipText = "Seleccione Carpeta de Scripts", ;
		Top = 4
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'GMARCO1' AS gmarco WITH ;
		Height = 21, ;
		Left = 4, ;
		Name = "GMARCO1", ;
		Top = 27, ;
		Width = 156
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'lblDestino' AS glab WITH ;
		Caption = "Destino", ;
		ForeColor = 0,0,255, ;
		Left = 9, ;
		MousePointer = 15, ;
		Name = "lblDestino", ;
		TabIndex = 11, ;
		ToolTipText = "Carpeta de Scripts", ;
		Top = 30
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Shape3d1' AS shape3d WITH ;
		Height = 59, ;
		Left = 1, ;
		Name = "Shape3d1", ;
		Top = 1, ;
		Width = 470
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'txtDestino' AS gtext WITH ;
		Enabled = .F., ;
		Height = 21, ;
		Left = 70, ;
		Name = "txtDestino", ;
		Top = 27, ;
		Width = 224
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="textbox" />
	
	PROCEDURE changecaption
		LPARAMETERS xcfile
		this.fileused=xcFile
		this.cleancaption(187)
		this.cleancaption(42)
		this.Parent.Caption=ALLTRIM(this.Parent.Caption);
				+" » Editing "+LOWER(xcfile)
	ENDPROC

	PROCEDURE cleancaption
		LPARAMETERS xnChar
		* xcChar », * (42)
		LOCAL nat
		WITH this
			nat=AT(CHR(xnChar),.Parent.Caption)
			IF nat#0
				.Parent.Caption=ALLTRIM(LEFT(.Parent.Caption,nat-1))
			ENDIF
		ENDWITH
	ENDPROC

	PROCEDURE Destroy
		this.noresize=.t.
		
		
		
	ENDPROC

	PROCEDURE getcmbdir
		LOCAL lcFile,obj,lnHand,lnit,lcGet,objRet,i
		lcfile=this.fileconf
		IF !FILE(lcfile)
			lnHand=FCREATE(lcFile)
			=FCLOSE(lnHand)
		ENDIF
		
		*lcFile="frmBackup.txt"
		lnHand=-1
		lnIt=1
		LOCAL ARRAY gaDir(1,3)
		gadir[1,1]="(Seleccione Proyecto)"
		gadir[1,2]=""
		gadir[1,3]=""
		
		*LPARAMETERS xcFile,xnHandler,xlNotVerb,xnPrivileg,xlOpenEmpty
		TRY
			LOCAL loex as Exception
			obj=NEWOBJECT("prsfun","clases\prssys.vcx")
			IF obj.getfopen(lcFile,@lnHand,.f.,0,.t.)
				DO WHILE !FEOF(lnHand)
					lcGet=FGETS(lnHand,2048)
					IF EMPTY(lcGet)
						LOOP
					ENDIF
					objRet=obj.GetValtag(lcGet,.t.)
					IF VARTYPE(objRet)="O"
						DO case
							CASE objREt.tag=="FOLDERBACK"
								this.folderback=LOWER(objREt.value)
								this.txtDestino.Value=this.folderback
							OTHERWISE
							
								lnIt=lnit+1
								DIMENSION gaDir(lnIt,3)
								gaDir[lnIt,1]=PROPER(objRet.tag)
								gaDir[lnIt,2]=LOWER(ObjRet.value)
								gaDir[lnIt,3]=lcGet
						ENDCASE
						
					ENDIF
					
				ENDDO
		*!*			=FCLOSE(lnHand)
			ENDIF
		
		CATCH TO loEx
			loex.UserValue=PROGRAM()
			obj.ShowError(loex)
		FINALLY
			IF lnHand> -1
				=FCLOSE(lnHand)
			ENDIF
			objRet=null
			obj=null
		ENDTRY
		
		WITH this.cnt1.cmbdir1
			.Clear
			.boundColumn=3
			.Controlsource='thisform.SelFile'	
			.ColumnCount=2
			.Columnwidths="200,200"
			FOR i=1 TO ALEN(gaDir,1)
				.Addlistitem(gaDir[i,1],i,1)
				.AddListitem(gaDir[i,2],i,2)
				.Addlistitem(JustFname(gadir[i,2]),i,3)
				.addListitem(gaDir[i,3],i,4)
			NEXT
			.requery
			.refresh
		ENDWITH
		this.cnt1.lblQuitar.Enabled=!EMPTY(thisform.selfile)
		
					
	ENDPROC

	PROCEDURE getmedida
		LPARAMETERS xlINit
		TRY
			LOCAL loex as Exception
			WITH this
				.Width=.Parent.Width-1
				.Height=.Parent.Height-1
				.Shape3d1.Width=.Width-1
				.Shape3d1.Height=.Height-1
				.gmarco1.Width=.shape3d1.Width-8
				.Cmbfun.Left=.gmarco1.Left+.gmarco1.Width-.CmbFun.width
				.gedit1.Width=.gmarco1.Width
				.txtDestino.Width=.gmarco1.width-.gmarco2.width+2-.CmbFun.width
				.cmdLimpiar.Left=.gmarco1.Left+.gmARCO1.Width-.cmdLimpiar.Width-2
				.cmdRescue.Left=.cmdLimpiar.Left-.cmdRescue.Width-1
				.cmdBackup.Left=.cmdRescue.Left-.cmdBackup.Width-1
				.gedit1.Height=.Height-.cntParam.Height ;
					- .txtDestino.Height - .txtDestino.Top - 4
					
		*		.gmarco3.Left=.gmarCO1.Left+.gmarCO1.Width-.gmarco3.width
				.cntParam.Top=.gedit1.Top+.gedit1.Height
				.cntprop.Top=.Cntparam.top
				.cntParam.Width=FLOOR(.Width/2)-4
				.CntProp.Width=.cntParam.Width
				.CntProp.Left=.gedit1.Left+.gedit1.Width-.cntProp.width
				.Cnt1.Width=.gmARCO1.width+1
		
			ENDWITH
		CATCH TO loEx
			loex.UserValue=PROGRAM(0)
			LOCAL obj
			obj=NEWOBJECT("prsfun","clases\prssys.vcx")
			obj.showError(loex)
		FINALLY
			obj=null
		ENDTRY
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS xcRootApp
		
		WITH this
			.rootapp=EVL(xcRootApp,FULLPATH(""))
			.BackStyle=0
			.SpecialEffect= 2
			.BorderWidth=0
			.fileused=""
			.Fileconf=ADDBS(.rootapp)+"frmBackup.txt"
			.ESinit=.T.
			.noresize=.t.
			.Width=.shape3d1.Width+1
			.Height=.shape3d1.Height+1
			.forbiden=",EXECUTE,MSE_EXPORT,MSE_TITLE,MSE_COLUMNS,MSE_HEADERS,MSE_SUMCOL,"
			.FolderBack=""
		ENDWITH
		ADDPROPERTY(thisform,"SelFile","")
		this.limpiar()
		this.getcmbdir()
		
		
	ENDPROC

	PROCEDURE limpiar
		LPARAMETERS lCmRead
		IF !lCmRead
			thisform.selfile=""
		ENDIF
		
		WITH this
		
			IF !lCmRead		
				.cmdLimpiar.Enabled=.f.
				.cmdRescue.Enabled=.t.
				.fileused=""
				.Cnt1.cmbdir1.Refresh		
			ENDIF
			.cmdBackup.Enabled=.f.
		*	.Parent.funsel=""
		ENDWITH
		*This.cleancaption(187)
		*this.cleancaption(42)
		thisform.Closable=.t.
	ENDPROC

	PROCEDURE cmdBackup.Click
		LOCAL lcRoot,obj,lnItem,loObj
		IF EMPTY(this.Parent.folderback)
			MESSAGEBOX("No definió el destino de BackUp",0,PROGRAM())
			RETURN
		ENDIF
		
		loObj=This.Parent.cnt1.cmbdir1
		lnItem=loObj.ListItemId
		
		
		lcRoot=loObj.ListItem(lnItem,2)
		IF !FILE(lcRoot)
			MESSAGEBOX("El archivo "+lcRoot+" ha desparecido",0,PROGRAM())
			RETURN
		ENDIF
		
		obj=NEWOBJECT("FunMark","clases\prssys.vcx")
		obj.SelBackup(lcRoot,this.Parent.rootapp,this.Parent.folderback)	
		obj=null
		
	ENDPROC

	PROCEDURE cmdLimpiar.Click
		this.Parent.limpiar()
		
	ENDPROC

	PROCEDURE cmdRescue.Click
		LOCAL lcRoot,obj,lnItem,loObj
		
		obj=NEWOBJECT("FunMark","clases\prssys.vcx")
		obj.REscueProy(this.Parent.folderback)
		
		obj=null
		
	ENDPROC

	PROCEDURE Cnt1.Cmbdir1.Click
		LOCAL lcSel
		lcSel=this.ListItem(this.ListItemId,2)
		this.Parent.Parent.cmdBackup.Enabled=!EMPTY(lcSel)
		this.Parent.Parent.cmdLimpiar.Enabled=!EMPTY(lcSel)
		This.Parent.lblQuitar.Enabled=!EMPTY(lcSel)
		
		
	ENDPROC

	PROCEDURE Cnt1.lblProyectos.Click
		LOCAL lcFile,objFun,lcFileConf
		lcFile=GETFILE("pjx")
		lcFileConf=this.Parent.Parent.fileconf
		IF EMPTY(lcFile)
			RETURN
		ENDIF
		objFun=NEWOBJECT("prsfun","clases\prssys.vcx")
		lcTag=objFun.Puttag(JUSTFNAME(lcFile),lcfile)
		objFun.ADdTagToFile(this.Parent.Parent.fileconf,lcTag)
		objFun=null
		this.Parent.Parent.getcmbdir()
		
		
	ENDPROC

	PROCEDURE Cnt1.lblQuitar.Click
		LOCAL lcTag,lnItem,loObj,lcCaption,lnMess
		loObj=this.Parent.cmbdir1
		lnItem=loObj.ListItemid
		lcCaption=loObj.listitem(lnItem,1)
		lcTag=loObj.ListItem(lnItem ,4)
		IF EMPTY(lcTAg)
			RETURN
		ENDIF
		lnMess=MESSAGEBOX("Desea eliminar de Backup el proyecto "+lcCaption+"?",4,"Project Backup")
		IF lnmess#6
			RETURN
		ENDIF
		
		objFun=NEWOBJECT("prsfun","clases\prssys.vcx")
		objFun.ADdTagToFile(this.Parent.parent.fileconf,lcTag,.t.)
		objFun=null
		thisform.selfile=""
		this.Parent.Parent.getcmbdir()
	ENDPROC

	PROCEDURE Cnt1.Resize
		LOCAL lnWidth,lnp1,lnp2
		
		WITH this
			lnWidth=.width-.gmarco3.Width-.gmarco3.Left+1
		ENDWITH
		lnp1=FLOOR(lnWidth*0.60)
		lnp2=lnWidth-lnp1
		
		WITH this.cmbdir1
			.width=lnWidth
			.columnWidths=TRANSFORM(lnp1)+","+TRANSFORM(lnp2)
		ENDWITH
		
		
	ENDPROC

	PROCEDURE lblDestino.Click
		LOCAL lcFolder,objFun,lcIni
		lcIni=IIF(EMPTY(this.Parent.folderback),FULLPATH(""),this.Parent.folderback)
		lcFolder=GETDIR( lcIni ,"Seleccione Carpeta","Destino de Backup",64)
		IF EMPTY(lcFolder)
			RETURN
		ENDIF
		objFun=NEWOBJECT("prsfun","clases\prssys.vcx")
		IF VARTYPE(objfun)#"O"
			MESSAGEBOX("No se creó el objeto prsfun")
			RETURN
		ENDIF
		lcTag=objFun.Puttag("FOLDERBACK",lcFolder)
		objFun.ADdTagToFile(this.Parent.fileconf,lcTag)
		objFun=null
		this.parent.getcmbdir()
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntbas AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape3d1" UniqueID="" Timestamp="" />

	BackStyle = 0
	BorderWidth = 0
	Height = 200
	Name = "cntbas"
	Width = 200

	ADD OBJECT 'Shape3d1' AS shape3d WITH ;
		Left = 0, ;
		Name = "Shape3d1", ;
		Top = 1
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />
	
	PROCEDURE Init
		WITH this
			.Shape3d1.Top=1
			.shape3d1.Left=1
			.shape3d1.Width=.Width-1
			.shape3d1.Height=.Height-1
		ENDWITH
	ENDPROC

	PROCEDURE Resize
		WITH this
			.shape3d1.Width=.Width-1
			.shape3d1.Height=.Height-1
		ENDWITH
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntclose AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Gmarco1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GLAB1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gtext1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gmarco2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gmarco3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Prsfun1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gedit1" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: forbiden
		*p: novalide
		*p: numbarra
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	forbiden = .F.
	Height = 95
	Name = "cntclose"
	novalide = .F.
	numbarra = .F.
	Width = 372

	ADD OBJECT 'Gedit1' AS gedit WITH ;
		Height = 53, ;
		Left = 1, ;
		Name = "Gedit1", ;
		Top = 21, ;
		Width = 295
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="editbox" />

	ADD OBJECT 'GLAB1' AS glab WITH ;
		Caption = "Propiedad", ;
		Left = 7, ;
		Name = "GLAB1", ;
		TabIndex = 4, ;
		Top = 4
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Glab2' AS glab WITH ;
		Caption = "Tablas / Cursores", ;
		Left = 142, ;
		Name = "Glab2", ;
		TabIndex = 5, ;
		Top = 4
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Glab3' AS glab WITH ;
		Caption = "Quitar", ;
		ForeColor = 255,0,0, ;
		Left = 259, ;
		Name = "Glab3", ;
		Top = 4
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Gmarco1' AS gmarco WITH ;
		Left = 1, ;
		Name = "Gmarco1", ;
		Top = 1
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gmarco2' AS gmarco WITH ;
		Height = 21, ;
		Left = 135, ;
		Name = "Gmarco2", ;
		Top = 1, ;
		Width = 118
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gmarco3' AS gmarco WITH ;
		Height = 21, ;
		Left = 252, ;
		Name = "Gmarco3", ;
		Top = 1, ;
		Width = 44
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gtext1' AS gtext WITH ;
		Enabled = .F., ;
		Height = 21, ;
		Left = 67, ;
		Name = "Gtext1", ;
		TabIndex = 1, ;
		Top = 1, ;
		Width = 69
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="textbox" />

	ADD OBJECT 'Prsfun1' AS prsfun WITH ;
		Left = 331, ;
		Name = "Prsfun1", ;
		Top = 27
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="custom" />
	
	PROCEDURE Init
		WITH this
			.Width=.gmaRCO1.Left+.gmarco3.Left+.gmarco3.Width
			.gtEXT1.Value="CLOSE"
		ENDWITH
		
	ENDPROC

	PROCEDURE Gedit1.InteractiveChange
		this.Parent.glab3.Enabled=!EMPTY(this.Value)
		
	ENDPROC

	PROCEDURE Glab3.Click
		this.Parent.gedit1.Value=""
		this.Enabled=.f.
	ENDPROC

ENDDEFINE

DEFINE CLASS cntcopy AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="GMARCO1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GLAB1" UniqueID="" Timestamp="" />

	BackStyle = 0
	BorderWidth = 0
	Height = 22
	Name = "cntcopy"
	Width = 53

	ADD OBJECT 'GLAB1' AS glab WITH ;
		Caption = "Copiar", ;
		ForeColor = 0,0,255, ;
		Left = 7, ;
		MousePointer = 15, ;
		Name = "GLAB1", ;
		Top = 4
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'GMARCO1' AS gmarco WITH ;
		Height = 21, ;
		Left = 1, ;
		Name = "GMARCO1", ;
		Top = 1, ;
		Width = 52
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />
	
	PROCEDURE GLAB1.Click
		LOCAL oform,lcString,OBJFUN
		oform=this.Parent.Parent
		objFun=NEWOBJECT("prsfun","clases\prssys.vcx")
		objfun.tryCopy(oform,.f.)
		objfun=null
		IF VARTYPE(objCopy)="O"
			lcSTring=alltrim(objCopy.cString)
			objCopy=null
			RELEASE objCopy
			_cliptext=LEFT(lcString,LEN(lcString)-1)
			this.ForeColor=RGB(128,0,255)
		ENDIF
		
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntdiff AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="CmOri" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="CmBin" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Text2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="CmRead" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GMARCO1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Combo1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GLAB1" UniqueID="" Timestamp="" />

	Height = 83
	Name = "cntdiff"
	Width = 413

	ADD OBJECT 'CmBin' AS commandbutton WITH ;
		Caption = "FoxBin", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 6, ;
		Name = "CmBin", ;
		TabIndex = 2, ;
		Top = 53, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'CmOri' AS commandbutton WITH ;
		Caption = "Original", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 6, ;
		Name = "CmOri", ;
		TabIndex = 1, ;
		Top = 31, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'CmRead' AS commandbutton WITH ;
		Caption = "ReadSome", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 293, ;
		Name = "CmRead", ;
		TabIndex = 3, ;
		Top = 43, ;
		Width = 65
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'Combo1' AS combobox WITH ;
		BorderColor = 114,136,141, ;
		FontSize = 8, ;
		Height = 21, ;
		Left = 91, ;
		Name = "Combo1", ;
		SpecialEffect = 1, ;
		Style = 2, ;
		Top = 8, ;
		Width = 140
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'GLAB1' AS glab WITH ;
		Caption = "Elemento", ;
		Left = 13, ;
		Name = "GLAB1", ;
		Top = 11
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'GMARCO1' AS gmarco WITH ;
		Left = 7, ;
		Name = "GMARCO1", ;
		Top = 8
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Shape1' AS shape WITH ;
		BackColor = 221,226,222, ;
		Height = 82, ;
		Left = 1, ;
		Name = "Shape1", ;
		SpecialEffect = 0, ;
		Top = 2, ;
		Width = 383
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Text1' AS textbox WITH ;
		BorderColor = 114,136,141, ;
		DisabledBackColor = 242,247,243, ;
		DisabledForeColor = 0,0,0, ;
		Enabled = .F., ;
		FontSize = 8, ;
		Height = 21, ;
		Left = 91, ;
		Name = "Text1", ;
		SpecialEffect = 1, ;
		TabIndex = 4, ;
		Top = 32, ;
		Width = 200
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'Text2' AS textbox WITH ;
		BorderColor = 114,136,141, ;
		DisabledBackColor = 242,247,243, ;
		DisabledForeColor = 0,0,0, ;
		Enabled = .F., ;
		FontSize = 8, ;
		Height = 21, ;
		Left = 91, ;
		Name = "Text2", ;
		SpecialEffect = 1, ;
		TabIndex = 5, ;
		Top = 54, ;
		Width = 200
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE Destroy
		IF PEMSTATUS(_Screen,"oFrmDiff",5)
			IF VARTYPE(_screen.oFrmdiff)="O"
				_screen.ofrmDiff.release
				_screen.ofrmDiff=null
				REMOVEPROPERTY(_screen,"oFrmDiff")
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE Init
		WITH this
			.width=.shape1.Width+1
			.Height=.shape1.Height+1
			.BackStyle= 0
			.BorderWidth=0
		ENDWITH
		
	ENDPROC

	PROCEDURE CmBin.Click
		LOCAL lcRoot,objFun,lcfile,lcDapli
		
		lcDapli=_screen.dapli
		lcRoot=ADDBS(dserv)
		
		CD &lcRoot
		lcFile=GETFILE(thisform.ketipo)
		CD &lcDAPLI
		IF EMPTY(LCFILE)
			RETURN
		ENDIF
		lcFile=LOWER(lcFile)
		lcOther=ALLTRIM(this.Parent.text1.Value)
		IF lcFile==lcOther
			MESSAGEBOX("No necesita analizar el mismo archivo")
			RETURN
		ENDIF
		this.Parent.text2.Value=lcfile
		
		
	ENDPROC

	PROCEDURE CmOri.Click
		LOCAL lcRoot,objFun,lcfile,lcDapli
		lcDapli=_screen.dapli
		
		lcRoot=ADDBS(dserv)
		
		CD &lcRoot
		lcFile=GETFILE(thisform.ketipo)
		CD &lcDAPLI
		IF EMPTY(LCFILE)
			RETURN
		ENDIF
		lcFile=LOWER(lcFile)
		lcOther=ALLTRIM(this.Parent.text2.Value)
		IF lcFile==lcOther
			MESSAGEBOX("No necesita analizar el mismo archivo")
			RETURN
		ENDIF
		this.Parent.text1.Value=LOWER(lcfile)
		
		
		
	ENDPROC

	PROCEDURE CmRead.Click
		LOCAL objFun,lcName,lcFile,dbName,dbfile,lcOri,lcNew
		
		objfun=NEWOBJECT("funmark","clases\prssys.vcx")
		
		lcfile=ALLTRIM(this.Parent.text1.Value)
		dbFile=ADDBS(dserv)+"cur"+JUSTSTEM(lcFile)+".dbf"
		dbName=JUSTSTEM(dbfile)
		
		objfun.ReadFoxBin(ALLTRIM(this.Parent.text1.Value),0,dbFile)
		objfun.ReadFoxBin(ALLTRIM(this.Parent.text2.Value),1,dbfile)
		
		IF !FILE(dbFile)
			objfun=null
			MESSAGEBOX("No se creó &lcFile")
			RETURN
		ENDIF
		IF !USED(dbName)
			USE (dbfile) IN 0 EXCLUSIVE
		ENDIF
		SELECT (dbname)
		SET ORDER TO
		SCAN
			OBJFUN.ParserMemo(DBNAME,"ORIGINAL","FOXBIN","COMPARA","CALIF")
		ENDSCAN
		GO top
		lcOri=ALLTRIM(this.Parent.text1.Value)
		lcNew=ALLTRIM(this.Parent.text2.value)
		ADDPROPERTY(_screen,"oFrmDiff",NEWOBJECT("FrmDiff","clases\prssys.vcx","",dbName,lcOri,lcNew))
		_screen.oFrmDiff.Show()
		
		objfun=null
		*BROWSE
		*USE
		*DO FORM &dformu\gbshow WITH dbName,thisform.cnt2.text1.Value,;
		*	thisform.cnt2.text2.Value
		
		*!*	SELECT (dbname)
		*!*	SET ORDER TO
		*!*	GO top
		*!*	BROWSE
		
		
	ENDPROC

	PROCEDURE Combo1.Click
		nitem=this.ListItemId
		IF nitem#0
			lcSel=this.ListItem(nitem,2)
			WITH this.Parent
				.cmbin.Enabled=!EMPTY(lcSel)
				.CmOri.Enabled=!EMPTY(lcSel)
			ENDWITH
		ENDIF
		
	ENDPROC

	PROCEDURE Combo1.Init
		lcPOs="SC2;VC2;FR2;DB2;DC2;PJ2;MN2"
		LOCAL ARRAY gatem(7,2)
		gaTem[1,1]=[Formulario]
		gaTem[2,1]=[Clase]
		gaTem[3,1]=[Reporte]
		gaTem[4,1]=[Tabla]
		gaTem[5,1]=[Base Datos]
		gaTem[6,1]=[Proyecto]
		gaTem[7,1]=[Menú]
		
		gaTem[1,2]=[SC2]
		gaTem[2,2]=[VC2]
		gaTem[3,2]=[FR2]
		gaTem[4,2]=[DB2]
		gaTem[5,2]=[DC2]
		gaTem[6,2]=[PJ2]
		gaTem[7,2]=[MN2]
		WITH this.Parent
			.cmread.enabled=.f.
			.cmBin.enabled=.f.
			.CmOri.enabled=.f.
		endwith
		*thisform.ketipo=""
		ADDPROPERTY(thisform,"Ketipo","")
		WITH this
			.BoundColumn=2
			.ControlSource='thisform.ketipo'
			.AddListItem("(Seleccione Tipo)",1,1)
			.AddListItem("",1,2)
			FOR i=1 TO ALEN(gatem,1)
				.AddListItem(gatem[i,1],i+1,1)
				.AddListItem(gatem[i,2],i+1,2)
			NEXT
			.Requery
			.Refresh
		ENDWITH
		
	ENDPROC

	PROCEDURE Combo1.InteractiveChange
		WITH this.Parent
			.text2.Value=""
			.text1.Value=""
		ENDWITH
		
		
	ENDPROC

	PROCEDURE Text1.ProgrammaticChange
		lc1=ALLTRIM(this.Value)
		lc2=ALLTRIM(this.Parent.text2.Value)
		this.Parent.cmRead.Enabled=IIF(!EMPTY(lc1) and !EMPTY(lc2),.t.,.f.)
		
	ENDPROC

	PROCEDURE Text2.ProgrammaticChange
		lc1=ALLTRIM(this.Value)
		lc2=ALLTRIM(this.Parent.text1.Value)
		this.Parent.cmRead.Enabled=IIF(!EMPTY(lc1) and !EMPTY(lc2),.t.,.f.)
	ENDPROC

ENDDEFINE

DEFINE CLASS cntempty AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Gmarco1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GLAB1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gtext1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gmarco2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gtext2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gmarco3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Prsfun1" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: forbiden
		*p: novalide
		*p: numbarra
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	forbiden = .F.
	Height = 22
	Name = "cntempty"
	novalide = .F.
	numbarra = .F.
	Width = 627

	ADD OBJECT 'GLAB1' AS glab WITH ;
		Caption = "Propiedad", ;
		Left = 7, ;
		Name = "GLAB1", ;
		TabIndex = 4, ;
		Top = 4
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Glab2' AS glab WITH ;
		Caption = "Valor / Variable", ;
		Left = 194, ;
		Name = "Glab2", ;
		TabIndex = 5, ;
		Top = 4
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Glab3' AS glab WITH ;
		Caption = "Quitar", ;
		ForeColor = 255,0,0, ;
		Left = 432, ;
		Name = "Glab3", ;
		Top = 4
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Gmarco1' AS gmarco WITH ;
		Left = 1, ;
		Name = "Gmarco1", ;
		Top = 1
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gmarco2' AS gmarco WITH ;
		Left = 183, ;
		Name = "Gmarco2", ;
		Top = 1
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gmarco3' AS gmarco WITH ;
		Height = 21, ;
		Left = 425, ;
		Name = "Gmarco3", ;
		Top = 1, ;
		Width = 44
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gtext1' AS gtext WITH ;
		Height = 21, ;
		Left = 67, ;
		Name = "Gtext1", ;
		TabIndex = 1, ;
		Top = 1, ;
		Width = 117
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="textbox" />

	ADD OBJECT 'Gtext2' AS gtext WITH ;
		Height = 21, ;
		Left = 282, ;
		Name = "Gtext2", ;
		TabIndex = 3, ;
		Top = 1, ;
		Width = 142
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="textbox" />

	ADD OBJECT 'Prsfun1' AS prsfun WITH ;
		Left = 547, ;
		Name = "Prsfun1", ;
		Top = 5
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="custom" />
	
	PROCEDURE Init
		WITH this
			.Width=.gmARCO1.Left+.gmarco3.Left+.gmarco3.Width
			.Height=.gmaRCO1.Height+1
			.forbiden=",MSE_EXPORT,MSE_TITLE,MSE_COLUMNS,MSE_HEADERS,MSE_SUM,"
		ENDWITH
		
		
	ENDPROC

	PROCEDURE GLAB1.Click
		MESSAGEBOX("this.numbarra="+TRANSFORM(this.Parent.numbarra))
	ENDPROC

	PROCEDURE Glab3.Click
		this.Parent.prsfun1.quitcntprop(this.Parent)
		
		
	ENDPROC

	PROCEDURE Gtext1.Valid
		LOCAL lcValor,lnBarra,i
		THIS.Value=ALLTRIM(THIS.Value)
		IF !EMPTY(THIS.Value)
			this.Value=this.Parent.prsfun1.ValidTExt(this.Value)
		
			lnBarra=this.Parent.numbarra
			lcValor=UPPER(this.Value)
			FOR i=1 TO objEmpty.CntCount
				IF i#lnBarra
					IF UPPER(objEmpty.gadob[i,1])==lcvalor
						MESSAGEBOX("La propiedad "+PROPER(this.Value)+" ya está agregada.",0,"CntEmpty validation")	
						this.Value=""
						RETURN 0
					ENDIF
				ENDIF
			NEXT
			
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS cntexcel AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape3d1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GMARCO1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gmarco2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GLAB1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GTEXT1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gmarco7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gtext6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="CmInsert" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gedit1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gedit2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gedit3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gmarco6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gmarco8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gmarco9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gedit4" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: inserob
		*p: exisempty		&& Si había sido creado la clase empty
		*p: objedit
	*</DefinedPropArrayMethod>

	exisempty = .F.		&& Si había sido creado la clase empty
	Height = 371
	Name = "cntexcel"
	objedit = null
	Width = 396

	ADD OBJECT 'CmInsert' AS commandbutton WITH ;
		Caption = "\<Aceptar", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 321, ;
		Name = "CmInsert", ;
		TabIndex = 6, ;
		Top = 336, ;
		Width = 56
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'Gedit1' AS gedit WITH ;
		Height = 232, ;
		Left = 4, ;
		Name = "Gedit1", ;
		TabIndex = 3, ;
		Top = 102, ;
		Width = 125
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="editbox" />

	ADD OBJECT 'Gedit2' AS gedit WITH ;
		Height = 232, ;
		Left = 128, ;
		Name = "Gedit2", ;
		TabIndex = 4, ;
		Top = 102, ;
		Width = 125
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="editbox" />

	ADD OBJECT 'Gedit3' AS gedit WITH ;
		Height = 232, ;
		Left = 252, ;
		Name = "Gedit3", ;
		TabIndex = 5, ;
		Top = 102, ;
		Width = 125
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="editbox" />

	ADD OBJECT 'Gedit4' AS gedit WITH ;
		Height = 54, ;
		Left = 101, ;
		Name = "Gedit4", ;
		TabIndex = 2, ;
		Top = 27, ;
		Width = 276
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="editbox" />

	ADD OBJECT 'GLAB1' AS glab WITH ;
		Caption = "Tabla ó Cursor", ;
		Left = 174, ;
		Name = "GLAB1", ;
		TabIndex = 8, ;
		Top = 8
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Glab2' AS glab WITH ;
		Caption = "Títulos", ;
		Left = 11, ;
		Name = "Glab2", ;
		TabIndex = 9, ;
		Top = 30
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Glab6' AS glab WITH ;
		Caption = "Columnas", ;
		Left = 8, ;
		Name = "Glab6", ;
		TabIndex = 10, ;
		Top = 85
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Glab7' AS glab WITH ;
		Caption = "Objeto Empty", ;
		Left = 11, ;
		Name = "Glab7", ;
		TabIndex = 13, ;
		Top = 8
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Glab8' AS glab WITH ;
		Caption = "Encabezados", ;
		Left = 134, ;
		Name = "Glab8", ;
		TabIndex = 11, ;
		Top = 85
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Glab9' AS glab WITH ;
		Caption = "Sumar Columnas", ;
		Left = 258, ;
		Name = "Glab9", ;
		TabIndex = 12, ;
		Top = 85
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'GMARCO1' AS gmarco WITH ;
		Height = 21, ;
		Left = 167, ;
		Name = "GMARCO1", ;
		Top = 5, ;
		Width = 83
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gmarco2' AS gmarco WITH ;
		Height = 54, ;
		Left = 4, ;
		Name = "Gmarco2", ;
		Top = 27, ;
		Width = 99
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gmarco6' AS gmarco WITH ;
		Left = 4, ;
		Name = "Gmarco6", ;
		Top = 82, ;
		Width = 125
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gmarco7' AS gmarco WITH ;
		Height = 21, ;
		Left = 4, ;
		Name = "Gmarco7", ;
		Top = 5, ;
		Width = 83
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gmarco8' AS gmarco WITH ;
		Left = 128, ;
		Name = "Gmarco8", ;
		Top = 82, ;
		Width = 125
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gmarco9' AS gmarco WITH ;
		Left = 252, ;
		Name = "Gmarco9", ;
		Top = 82, ;
		Width = 125
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'GTEXT1' AS gtext WITH ;
		Height = 21, ;
		Left = 249, ;
		Name = "GTEXT1", ;
		TabIndex = 1, ;
		Top = 5, ;
		Width = 128
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="textbox" />

	ADD OBJECT 'Gtext6' AS gtext WITH ;
		Enabled = .F., ;
		Height = 21, ;
		Left = 86, ;
		Name = "Gtext6", ;
		TabIndex = 7, ;
		Top = 5, ;
		Width = 82
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="textbox" />

	ADD OBJECT 'Shape3d1' AS shape3d WITH ;
		Height = 361, ;
		Left = 1, ;
		Name = "Shape3d1", ;
		Top = 1, ;
		Width = 380
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />
	
	PROCEDURE Init
		WITH this
			.Height=.Shape3d1.Height+1
			.Width=.shape3d1.Width+1
			.BackStyle= 0
			.BorderWidth=0
		ENDWITH
		
	ENDPROC

	PROCEDURE inserob
		LOCAL lcEdit,lcObjeto,lcParte1,lcParte2,lcObjEmpty,;
			nLines,i,di,dj,ln,lnh,h,lnSelStart,lcSum
		
		LOCAL ARRAY gaCols(1), gatt(4,3)
		
		STORE "" TO gatt
		
		gatt[1,1]=This.gedit4.Text
		gatt[1,2]="Tit"
		
		gatt[2,1]=this.gedit1.Text
		gatt[2,2]="Col"
		
		gatt[3,1]=this.gedit2.Text
		gatt[3,2]="Hea"
		
		gatt[4,1]=this.gEDIT3.Text
		gatt[4,2]="Sum"
		
		FOR xi=1 TO ALEN(gatt,1)
			FOR i=1 TO ALINES(gaCols,gatt[xi,1])
				gatt[xi,3]=gatt[xi,3]+CHRTRAN(gaCols[i],["',;.],"") + ","
			NEXT
			gatt[xi,3]=LEFT(gatt[xi,3],LEN(gatt[xi,3])-1)
		NEXT
		
		* Contar columnas y encabezados
		IF GETWORDCOUNT(gatt[2,3],",") # GETWORDCOUNT(gatt[3,3],",")
			MESSAGEBOX("Cantidad de Columnas="+TRANSFORM(GETWORDCOUNT(gatt[2,3],","));
				+CHR(13)+"Cantidad de Encabezados="+TRANSFORM(GETWORDCOUNT(gatt[3,3],","));
				+CHR(13)+"La cantidad de columnas y de encabezados deben ser iguales",0,"CntExcel InserOb Message")
			this.geDIT3.SetFocus
			RETURN
		ENDIF
		
		
		* Verifica que las columnas sumas estén como columnas
		lcSum=""
		FOR i=1 TO ALINES(gaCols,gaTt[4,3],5,",")
			IF AT(","+UPPER(gaCols[i])+"," ,","+UPPER(Gatt[2,3])+",")>0
				lcSum=lcSum+gaCols[i]+","
			ENDIF
			gatt[4,3]=LEFT(lcSum,LEN(lcSum)-1)
		NEXT
		
		
		lcObjEmpty=ALLTRIM(this.gtext6.Value)
		lcObjeto="AddProperty("+lcObjEmpty+","
		
		LOCAL ARRAY gaEdit(IIF(this.exisempty,6,8),3)
		ln=0
		lcEdit=""
		IF !this.exisempty
			ln=ln+1
			gaEdit[ln,1]=lcObjEmpty+[=NEWOBJECT("Empty")]
		ENDIF
		ln=ln+1
		gaEdit[ln,1]=lcObjeto+["Execute","<EXCEL>")]
		ln=ln+1
		gaEdit[ln,1]=lcObjeto+["MSE_Export","]+ALLTRIM(this.gtext1.Value)+[")]
		ln=ln+1
		gaEdit[ln,1]=lcObjeto+["MSE_Title","]+ALLTRIM(gatt[1,3])+[")]
		
		
		ln=ln+1
		gaEdit[ln,1]=lcObjeto+["MSE_Columns","]+ALLTRIM(gatt[2,3])+[")]
		ln=ln+1
		gaEdit[ln,1]=lcObjeto+["MSE_Headers","]+ALLTRIM(gatt[3,3])+[")]
		ln=ln+1
		gaEdit[ln,1]=lcObjeto+["MSE_Sum","]+ALLTRIM(gatt[4,3])+[")]
		IF !this.exisempty
			ln=ln+1
			gaEdit[ln,1]=[RETURN ]+lcObjEmpty
		ENDIF
		lcEdit=""
		FOR i=1 TO ln
			gaEdit[i,3]=0
			lcEdit=lcEdit+gaEdit[i,1]+CHR(13)
		NEXT
		
		
		TRY
			LOCAL loex as Exception
			_clipText=lcEdit
			DO case
				CASE !This.exisempty
					* No existe una clase "Empty". Debe crearse al final del texto.
					lnSelStart=len(this.objedit.Text)
					lcparte1=LEFT(this.objedit.text,lnSelStart)
					lcparte2=SUBSTR(this.objedit.text,lnSelStart+1)
					DO WHILE RIGHT(LcParte1,1)=CHR(13)
						lcParte1=LEFT(lcParte1,LEN(lcParte1)-1)
					ENDDO
					DO WHILE LEFT(lcparte2,1)=CHR(13)
						lcParte2=SUBSTR(lcParte2,2)
					ENDDO
					this.objedit.value=lcParte1+CHR(13)+lcEdit+CHR(13)+lcParte2+CHR(13)
				OTHERWISE
				
					LOCAL ARRAY gaComp(6,3),galines(1),gaInsert(1,2)
					LOCAL lnIsert,lnExcel
					lnInsert=0
					lnExcel=0
					gaComp[1,1]=[ADDPROPERTY(]+lcObjEmpty+[,"EXECUTE","<EXCEL>"]
					gaComp[1,2]=[ADDPROPERTY(]+lcObjEmpty+[,'EXECUTE','<EXCEL>']
					gaComp[1,3]=["Execute"]
		
					gaComp[2,1]=[ADDPROPERTY(]+lcObjEmpty+[,"MSE_EXPORT",]
					gaComp[2,2]=[ADDPROPERTY(]+lcObjEmpty+[,'MSE_EXPORT',]
					gaComp[2,3]=["MSE_Export"]
		
					gaComp[3,1]=[ADDPROPERTY(]+lcObjEmpty+[,"MSE_TITLE",]
					gaComp[3,2]=[ADDPROPERTY(]+lcObjEmpty+[,'MSE_TITLE',]
					gaComp[3,3]=["MSE_Title"]
		
					gaComp[4,1]=[ADDPROPERTY(]+lcObjEmpty+[,"MSE_COLUMNS",]
					gaComp[4,2]=[ADDPROPERTY(]+lcObjEmpty+[,'MSE_COLUMNS',]
					gacomp[4,3]=["MSE_Columns"]
		
					gaComp[5,1]=[ADDPROPERTY(]+lcObjEmpty+[,"MSE_HEADERS",]
					gaComp[5,2]=[ADDPROPERTY(]+lcObjEmpty+[,'MSE_HEADERS',]
					gaComp[5,3]=["MSE_Headers"]
		
					gaComp[6,1]=[ADDPROPERTY(]+lcObjEmpty+[,"MSE_SUM",]
					gaComp[6,2]=[ADDPROPERTY(]+lcObjEmpty+[,'MSE_SUM',]
					gacomp[6,3]=["MSE_Sum"]
		
		
					nlines=ALINES(gaLines,this.objedit.Text)
					lnExcel=nLines
					FOR i=1 TO nLines
						LcLine=UPPER(CHRTRAN(gaLines[i],CHR(32),""))
						IF AT([NEWOBJECT("EMPTY")],lcLine)>0
							lnExcel=i
						ENDIF
						IF AT([NEWOBJECT('EMPTY')],lcLine)>0
							lnExcel=i
						ENDIF				
						IF AT([<EXCEL>],lcline)>0
							lnExcel=i
						ENDIF
						
						FOR di=1 TO ALEN(gacomp,1)
							FOR dj=1 TO 2
								IF LEFT(LcLine,LEN(gaComp[di,dj]))==gacomp[di,dj]
									lnh=0
									FOR h=1 TO ALEN(gaEdit,1)
										nat=AT(gaComp[di,3],gaEdit[h,1])
										IF nat>0	
											gaEdit[h,2]=.t.
											gaEdit[h,3]=i							
											lnh=h
											EXIT
										ENDIF
									NEXT
									IF lnh#0
										gaLines[i]=gaEdit[lnH,1]
									ELSE
										lnInsert=lnInsert+1
										DIMENSION gainsert(lnInsert,2)
										gaInsert[lnInsert,1]=i
										gaInsert[lnInsert,2]=gaLines[i]
									ENDIF
									
								ENDIF		
							NEXT
						NEXT
					NEXT
					IF lnInsert>0
						FOR i=1 TO lnInsert
							lni=gaInsert[i,1]
							DIMENSION galines(ALEN(galines)+1)
							AINS(gaLines,lni)
							gaLines[lni]=gaInsert[i,2]
						NEXT
					ELSE
		
						lnLast=lnExcel+1
						FOR i=1 TO ALEN(gaEdit,1)
							IF gaEdit[i,3]=0
								gaEdit[i,3]=lnLast
							ENDIF
		
							IF !gaEdit[i,2]
								DIMENSION galines(ALEN(galines)+1)
								AINS(galines,lnLast)
								gaLines[lnLast]=gaEdit[i,1]
							ENDIF
							lnLast=gaEdit[i,3]+1
						NEXT
			
					ENDIF
					
					lcEdit=""
					FOR i=1 TO ALEN(gaLines)
						lcEdit=lcEdit+gaLines[i]+CHR(13)
					NEXT
					this.objedit.value=lcEdit		
					this.objedit.selstart=LEN(lcEdit)
					this.objedit.parent.patext()
					this.objedit.setfocus
					
			ENDCASE
		CATCH TO loEx
			loex.UserValue=PROGRAM()+" Insertando Propiedades para Excel"
			LOCAL objfff
			objfff=NEWOBJECT("prsfun","clases\prssys.vcx")
			objFff.ShowError(loEx)
		FINALLY
			objFff=null
		
		ENDTRY
		
		thisform.Release
		
		
		
	ENDPROC

	PROCEDURE CmInsert.Click
		this.Parent.inserob()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntfile AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="GMARCO1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GLAB1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gtext1" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: nametabla		&& Path y Nombre de la tabla
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	Height = 22
	Name = "cntfile"		&& Path y Nombre de la tabla
	nametabla = 		&& Path y Nombre de la tabla
	Width = 200

	ADD OBJECT 'GLAB1' AS glab WITH ;
		Caption = "Tabla", ;
		ForeColor = 0,0,255, ;
		Left = 5, ;
		MousePointer = 15, ;
		Name = "GLAB1", ;
		ToolTipText = "Buscar una tabla", ;
		Top = 4
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'GMARCO1' AS gmarco WITH ;
		Height = 21, ;
		Left = 1, ;
		Name = "GMARCO1", ;
		Top = 1, ;
		Width = 46
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gtext1' AS gtext WITH ;
		Enabled = .F., ;
		Height = 21, ;
		Left = 36, ;
		Name = "Gtext1", ;
		Top = 1, ;
		Width = 163
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="textbox" />
	
	PROCEDURE GLAB1.Click
		IF THIS.ForeColor=RGB(0,0,255)
			lcFile=GETFILE("DBF")
			IF !EMPTY(lcFile)
				this.Parent.nametabla=lcFile
			ENDIF
			
		ENDIF
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntgen AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape3d1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gmarco1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gmarco2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gmarco3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gtext1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gtext2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="CmAddTabla" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="CmLimpiar" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cmbdir1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gmarco4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gtext3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gmarco5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glist1" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: agrelist
		*m: gencmbdir
		*m: genglist1
		*m: limpiar
		*m: quitalist
		*p: gprsfile		&& Archivo prs al que se agrega la tabla
		*p: gtabla		&& Tabla que se incorpora a prs
		*p: nfiles
		*p: ruta		&& Ruta de instalación de tablas
		*p: subcarpeta
		*a: gafiles[1,0]
	*</DefinedPropArrayMethod>

	gprsfile = 		&& Archivo prs al que se agrega la tabla
	gtabla = 		&& Tabla que se incorpora a prs
	Height = 460
	Name = "cntgen"
	nfiles = 0
	ruta = 		&& Ruta de instalación de tablas
	subcarpeta = .F.
	Width = 437

	ADD OBJECT 'CmAddTabla' AS commandbutton WITH ;
		Caption = "Agregar Tabla", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 191, ;
		Name = "CmAddTabla", ;
		TabIndex = 5, ;
		Top = 398, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'Cmbdir1' AS cmbdir WITH ;
		Height = 21, ;
		Left = 73, ;
		Name = "Cmbdir1", ;
		TabIndex = 3, ;
		Top = 45, ;
		Width = 122
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="combobox" />

	ADD OBJECT 'CmLimpiar' AS commandbutton WITH ;
		Caption = "Limpiar", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 276, ;
		Name = "CmLimpiar", ;
		TabIndex = 6, ;
		Top = 398, ;
		Width = 49
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'Glab1' AS glab WITH ;
		Caption = "Tabla", ;
		ForeColor = 0,0,255, ;
		Left = 10, ;
		MousePointer = 15, ;
		Name = "Glab1", ;
		TabIndex = 7, ;
		Top = 8
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Glab2' AS glab WITH ;
		Caption = "SubCarpeta", ;
		Left = 199, ;
		Name = "Glab2", ;
		TabIndex = 10, ;
		Top = 48
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Glab3' AS glab WITH ;
		Caption = "Destino", ;
		Left = 9, ;
		Name = "Glab3", ;
		TabIndex = 8, ;
		Top = 48
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Glab4' AS glab WITH ;
		Caption = "Archivo prs", ;
		ForeColor = 0,0,255, ;
		Left = 9, ;
		MousePointer = 15, ;
		Name = "Glab4", ;
		TabIndex = 9, ;
		Top = 28
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Glab5' AS glab WITH ;
		Caption = "Carpeta", ;
		ForeColor = 0,0,255, ;
		Left = 9, ;
		MousePointer = 15, ;
		Name = "Glab5", ;
		TabIndex = 7, ;
		Top = 70
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Glist1' AS glist WITH ;
		Height = 323, ;
		Left = 73, ;
		Name = "Glist1", ;
		Top = 67, ;
		Width = 273
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="listbox" />

	ADD OBJECT 'Gmarco1' AS gmarco WITH ;
		Left = 5, ;
		Name = "Gmarco1", ;
		Top = 5
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gmarco2' AS gmarco WITH ;
		Left = 5, ;
		Name = "Gmarco2", ;
		Top = 25
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gmarco3' AS gmarco WITH ;
		Left = 5, ;
		Name = "Gmarco3", ;
		Top = 45
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gmarco4' AS gmarco WITH ;
		Left = 194, ;
		Name = "Gmarco4", ;
		Top = 45
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gmarco5' AS gmarco WITH ;
		Height = 323, ;
		Left = 5, ;
		Name = "Gmarco5", ;
		Top = 67, ;
		Width = 100
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gtext1' AS gtext WITH ;
		Height = 21, ;
		Left = 73, ;
		Name = "Gtext1", ;
		TabIndex = 1, ;
		Top = 5, ;
		Width = 273
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="textbox" />

	ADD OBJECT 'Gtext2' AS gtext WITH ;
		Height = 21, ;
		Left = 73, ;
		Name = "Gtext2", ;
		TabIndex = 2, ;
		Top = 25, ;
		Width = 273
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="textbox" />

	ADD OBJECT 'Gtext3' AS gtext WITH ;
		Height = 21, ;
		Left = 262, ;
		Name = "Gtext3", ;
		TabIndex = 4, ;
		Top = 45, ;
		Width = 84
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="textbox" />

	ADD OBJECT 'Shape3d1' AS shape3d WITH ;
		Height = 426, ;
		Left = 1, ;
		Name = "Shape3d1", ;
		Top = 1, ;
		Width = 350
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />
	
	PROCEDURE agrelist
		LPARAMETERS xcAdd
		LOCAL ARRAY gapath(1)
		LOCAL nl,lcPath,lnSep
		lcPath=""
		NL=ALINES(gaPath,xcAdd,1,"\")
		lnSep=IIF(LEFT(xcAdd,2)=="\\",5,3)
		IF nl>=lnSep
			lcPath=gaPath[nl-1]
		ENDIF
		
		SET EXACT ON
		
		IF ASCAN(this.gafiles,xcAdd)=0
			this.nfiles=this.nfiles+1
			
			DIMENSION this.gafiles[this.nfiles,2]
			this.gafiles[this.nfiles,1]=xcAdd
			this.gaFiles[this.nFiles,2]=lcPath
			this.glist1.AddItem(xcAdd)
		ENDIF
		SET EXACT OFF
		
			
		
	ENDPROC

	PROCEDURE gencmbdir
		ADDPROPERTY(_Screen,"tbFolder","")
		
		WITH this.cmbdir1
			.Clear
			.BoundColumn=2
			.ControlSource='_screen.tbfolder'
			.addlistitem("(Seleccione Destino)",1,1)
			.addlistitem("",1,2)
			.Addlistitem("Carpeta Local",2,1)
			.addlistitem("*ROOT_APPLY*",2,2)
			.Addlistitem("Carpeta en Servidor",3,1)
			.addlistitem("*ROOT_SERV*",3,2)
			.requery
			.refresh
		ENDWITH
		
	ENDPROC

	PROCEDURE genglist1
		IF !PEMSTATUS(_screen,"tbFile",5)
			ADDPROPERTY(_screen,"TbFile","")
		ENDIF
		_screen.tbFile=this.gafiles[1,1]
		WITH this.glist1
			.Clear
			.BoundColumn=1
			.ControlSource='_screen.tbFile'
			FOR i=1 TO this.nfiles
				.additem(this.gafiles[i,1])
			NEXT
			.requery
			.refresh
		ENDWITH
		
	ENDPROC

	PROCEDURE Init
		WITH this
			.BackStyle=0
			.SpecialEffect= 2
			.BorderWidth=0
			.Height=.shape3d1.Height+1
			.Width=.shape3d1.Width+1
		ENDWITH
		THIS.Gencmbdir()
		this.limpiar()
			
		
			
	ENDPROC

	PROCEDURE limpiar
		WITH this
			.gtabla=""
			.gprsfile=""
			.subcarpeta=""	
			.gtext1.Value=""
			.gtext2.Value=""
			.gtext3.Value=""
			.nfiles=0
			.glist1.Clear
		ENDWITH
		DIMENSION this.gafiles(1,2)
		STORE "" TO this.gafiles
		
		
		
	ENDPROC

	PROCEDURE quitalist
		LPARAMETERS xcQuit,xnItem
		_screen.tbFile=this.gafiles[1,1]
		ADEL(this.gafiles,xnItem)
		IF xnItem<2
			xnItem=1
		ENDIF
		IF xnItem=this.nfiles
			xnItem=xnItem-1
		ENDIF
		
		this.nfiles=this.nfiles-1
		IF this.nfiles>0
			DIMENSION this.gafiles(this.nfiles,2)
			_screen.tbfile=this.gafiles[xnItem,1]
		ELSE
			DIMENSION this.gafiles(1,2)
			STORE "" TO this.gafiles
			_Screen.tbfile=""
		ENDIF
		
		
		WITH this.glist1
			.Clear
			.BoundColumn=1
			.ControlSource='_screen.tbFile'
			FOR i=1 TO this.nfiles
				.additem(this.gafiles[i,1])
			NEXT
			.requery
			.refresh
		ENDWITH
		
	ENDPROC

	PROCEDURE CmAddTabla.Click
		LOCAL lcRoot,i
		IF EMPTY(_screen.tbfolder)
			MESSAGEBOX("Debe seleccionar destino",0,"Mensaje de PrsSys")
			this.Parent.cmbdir1.SetFocus
			RETURN
		ENDIF
		this.Parent.subcarpeta=ALLTRIM(this.Parent.gtext3.Value)
		
		
		lcRoot=ADDBS(_screen.tbFolder)	
		
		obPrs=NEWOBJECT("prsfun","clases\prssys.vcx")
		*LPARAMETERS xcTabla,xcRoot,xcAddInPrs
		
		lcPrs=this.Parent.gprsfile
		IF FILE(lcPrs)
			lcBack=ADDBS(JUSTPATH(lcPrs))+JUSTSTEM(lcPrs)+".bak"
			COPY FILE &lcPrs TO &lcBack
		ENDIF
		
		FOR i=1 TO this.Parent.nfiles
		
			lcRoot=IIF(EMPTY(this.Parent.gafiles[i,2]),;
				_screen.tbfolder,ADDBS(_screen.tbfolder)+this.Parent.gafiles[i,2])
		
		
			lcFile=OBPRS.ADDTABLE(this.Parent.gafiles[i,1],lcRoot,this.Parent.gprsfile)
		NEXT
		
		obprs=null
		
		IF !EMPTY(lcFile)
			o = CREATEOBJECT("Shell.Application")
			o.ShellExecute("write.exe", '&lcFILE', "", "open", 1)
		
		ENDIF
	ENDPROC

	PROCEDURE CmLimpiar.Click
		this.Parent.limpiar()
		
	ENDPROC

	PROCEDURE Glab1.Click
		IF this.ForeColor=RGB(0,0,255)
			LOCAL lcTabla
			DO WHILE .t.
				lcTAbla=GETFILE("DBF")
				IF EMPTY(lcTabla)
					EXIT
				ENDIF
		
				
				*this.Parent.glist1.AddItem(lcTabla)
				this.Parent.agrelist(lcTabla)
				
				THIS.Parent.Gtabla=LcTabla
				this.Parent.gtext1.Value=LOWER(lcTabla)
			ENDDO
			this.Parent.genglist1()
			
		ENDIF
		
	ENDPROC

	PROCEDURE Glab4.Click
		IF this.ForeColor=RGB(0,0,255)
			LOCAL lcTabla
			lcTAbla=GETFILE("PRS")
			IF !EMPTY(LCTABLA)
				this.Parent.gprsfile=lcTabla
				this.Parent.gtext2.Value=LOWER(lcTabla)
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE Glab5.Click
		LOCAL lcCarpeta
		lcCarpeta=FULLPATH("")
		IF this.ForeColor=RGB(0,0,255)
			LOCAL lcDir,i,nfiles,lcTabla
			LOCAL ARRAY gafiles(1)
			DO WHILE .t.
			*	lcTAbla=GETFILE("DBF")
				lcDir=GETDIR(lcCarpeta,"Carpeta","Ruta de Tablas",48)
				
				IF EMPTY(lcDir)
					EXIT
				ENDIF
				lcCarpeta=lcDir
				nFiles=ADIR(gaFiles,ADDBS(lcdir)+"*.dbf")
				IF nfiles=0
					EXIT
				ENDIF
				
				FOR i=1 TO nFiles
					
				*this.Parent.glist1.AddItem(lcTabla)
					lcTabla=ADDBS(lcdir)+gafiles[i,1]
					this.Parent.agrelist(lcTabla)
					THIS.Parent.Gtabla=LcTabla
					this.Parent.gtext1.Value=LOWER(lcTabla)
				NEXT
				
			ENDDO
			this.Parent.genglist1()
			
		ENDIF
		
	ENDPROC

	PROCEDURE Glist1.RightClick
		LOCAL nMess
		nMess=MESSAGEBOX("Desea quitar este item:"+CHR(13);
			+this.Value,4,"PrsSys Message")
		IF nMess=6
			this.Parent.quitalist(this.Value,this.ListItemId)
		
		ENDIF
		
	ENDPROC

	PROCEDURE Gtext1.ProgrammaticChange
		this.Parent.cmAddTabla.Enabled=IIF(!EMPTY(this.Value) AND !EMPTY(this.Parent.gtext2.Value),.t.,.f.)
		this.Parent.Cmlimpiar.Enabled=IIF(!EMPTY(this.Value) OR !EMPTY(this.Parent.gTExt2.Value),.t.,.f.)
		
	ENDPROC

	PROCEDURE Gtext2.ProgrammaticChange
		this.Parent.cmAddTabla.Enabled=IIF(!EMPTY(this.Value) AND !EMPTY(this.Parent.gtext1.Value),.t.,.f.)
		this.Parent.Cmlimpiar.Enabled=IIF(!EMPTY(this.Value) OR !EMPTY(this.Parent.gTExt1.Value),.t.,.f.)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntlab AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Gmarco1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab1" UniqueID="" Timestamp="" />

	BackStyle = 0
	BorderWidth = 0
	Height = 22
	Name = "cntlab"
	Width = 200

	ADD OBJECT 'Glab1' AS glab WITH ;
		Left = 6, ;
		Name = "Glab1", ;
		Top = 4
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Gmarco1' AS gmarco WITH ;
		Height = 21, ;
		Left = 1, ;
		Name = "Gmarco1", ;
		Top = 1, ;
		Width = 114
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

ENDDEFINE

DEFINE CLASS cntparam AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cmbdir1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gmarco1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GLAB1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gtext1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gmarco2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gtext2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gmarco3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Prsfun1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Ntext1" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: numbarra
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	Height = 24
	Name = "cntparam"
	numbarra = .F.
	Width = 627

	ADD OBJECT 'Cmbdir1' AS cmbdir WITH ;
		Height = 21, ;
		Left = 180, ;
		Name = "Cmbdir1", ;
		TabIndex = 2, ;
		Top = 1, ;
		Width = 100
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="combobox" />

	ADD OBJECT 'GLAB1' AS glab WITH ;
		Caption = "Variable", ;
		Left = 33, ;
		Name = "GLAB1", ;
		TabIndex = 4, ;
		Top = 4
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Glab2' AS glab WITH ;
		Caption = "Descripción", ;
		Left = 284, ;
		Name = "Glab2", ;
		TabIndex = 5, ;
		Top = 4
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Glab3' AS glab WITH ;
		Caption = "Quitar", ;
		ForeColor = 255,0,0, ;
		Left = 511, ;
		Name = "Glab3", ;
		Top = 4
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Gmarco1' AS gmarco WITH ;
		Left = 1, ;
		Name = "Gmarco1", ;
		Top = 1
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gmarco2' AS gmarco WITH ;
		Left = 279, ;
		Name = "Gmarco2", ;
		Top = 1
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gmarco3' AS gmarco WITH ;
		Height = 21, ;
		Left = 504, ;
		Name = "Gmarco3", ;
		Top = 1, ;
		Width = 44
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gtext1' AS gtext WITH ;
		Left = 81, ;
		Name = "Gtext1", ;
		TabIndex = 1, ;
		Top = 1
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="textbox" />

	ADD OBJECT 'Gtext2' AS gtext WITH ;
		Height = 21, ;
		Left = 350, ;
		Name = "Gtext2", ;
		TabIndex = 3, ;
		Top = 1, ;
		Width = 153
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="textbox" />

	ADD OBJECT 'Ntext1' AS ntext WITH ;
		Enabled = .F., ;
		InputMask = "99", ;
		Left = 1, ;
		Name = "Ntext1", ;
		Top = 1, ;
		Width = 26
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="textbox" />

	ADD OBJECT 'Prsfun1' AS prsfun WITH ;
		Left = 546, ;
		Name = "Prsfun1", ;
		Top = 5
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="custom" />
	
	PROCEDURE Init
		WITH THIS
			.Width=.gmaRCO1.Left+.gmarco3.Left+.gmarco3.Width
			.Height=.gmarco1.Height+1
		ENDWITH
		
	ENDPROC

	PROCEDURE Cmbdir1.Init
		WITH this
			.BoundColumn=2
			.AddListItem("(Tipo)",1,1)
			.AddListItem("",1,2)
			.AddListItem("Character",2,1)
			.AddListItem("C",2,2)
			.AddListItem("Numeric",3,1)
			.AddListItem("N",3,2)
			.AddListItem("Logical",4,1)
			.AddListItem("L",4,2)
			.AddListItem("Fecha",5,1)
			.AddListItem("D",5,2)
			.Requery
		ENDWITH
		
	ENDPROC

	PROCEDURE Glab3.Click
		this.Parent.prsfun1.quitcntparam(this.Parent)
	ENDPROC

ENDDEFINE

DEFINE CLASS cntscrip AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape3d1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GMARCO1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GLAB1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GMARCO2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GLAB4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GTEXT1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cnt1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cnt1.Gmarco3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cnt1.Cmbdir1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cnt1.Glab5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="CmbFun" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="CntParam" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="CntProp" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="gEdit1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gmarco3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="CmGen" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="CmLimpiar" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="CmRead" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="CmEje" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: changecaption
		*m: cleancaption
		*m: getmedida
		*m: getobjexcel
		*m: getparam
		*m: getproperties
		*m: greadfile		&& Leer un script existente para edición
		*m: grespparam
		*m: grespproper
		*m: guardar
		*m: limpiar
		*m: patext
		*p: esinit
		*p: fileused
		*p: forbiden
		*p: lastheight
		*p: lastwidth
		*p: noresize
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	esinit = .T.
	fileused = .F.
	forbiden = .F.
	Height = 437
	lastheight = 0
	lastwidth = 0
	Name = "cntscrip"
	noresize = .F.
	Width = 475

	ADD OBJECT 'CmbFun' AS cmbdir WITH ;
		Height = 21, ;
		Left = 293, ;
		Name = "CmbFun", ;
		TabIndex = 6, ;
		Top = 49, ;
		Width = 173
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="combobox" />

	ADD OBJECT 'CmEje' AS commandbutton WITH ;
		BackColor = 221,226,222, ;
		Caption = "\<Ejecutar", ;
		FontSize = 8, ;
		Height = 19, ;
		Left = 243, ;
		Name = "CmEje", ;
		SpecialEffect = 2, ;
		TabIndex = 10, ;
		Top = 28, ;
		Width = 55
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'CmGen' AS commandbutton WITH ;
		BackColor = 221,226,222, ;
		Caption = "\<Generar", ;
		FontSize = 8, ;
		Height = 19, ;
		Left = 408, ;
		Name = "CmGen", ;
		SpecialEffect = 2, ;
		TabIndex = 9, ;
		Top = 28, ;
		Width = 55
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'CmLimpiar' AS commandbutton WITH ;
		BackColor = 221,226,222, ;
		Caption = "\<Limpiar", ;
		FontSize = 8, ;
		Height = 19, ;
		Left = 353, ;
		Name = "CmLimpiar", ;
		SpecialEffect = 2, ;
		TabIndex = 8, ;
		Top = 28, ;
		Width = 55
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'CmRead' AS commandbutton WITH ;
		BackColor = 221,226,222, ;
		Caption = "\<Abrir", ;
		FontSize = 8, ;
		Height = 19, ;
		Left = 298, ;
		Name = "CmRead", ;
		SpecialEffect = 2, ;
		TabIndex = 7, ;
		Top = 28, ;
		Width = 55
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'Cnt1' AS container WITH ;
		BackStyle = 0, ;
		BorderWidth = 0, ;
		Height = 22, ;
		Left = 3, ;
		Name = "Cnt1", ;
		TabIndex = 1, ;
		Top = 4, ;
		Width = 333
		*< END OBJECT: BaseClass="container" />

	ADD OBJECT 'Cnt1.Cmbdir1' AS cmbdir WITH ;
		DisabledBackColor = 242,247,243, ;
		Height = 21, ;
		Left = 67, ;
		Name = "Cmbdir1", ;
		Top = 1, ;
		Width = 265
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="combobox" />

	ADD OBJECT 'Cnt1.Glab5' AS glab WITH ;
		Caption = "ScriptFiles", ;
		ForeColor = 0,0,255, ;
		Left = 6, ;
		MousePointer = 15, ;
		Name = "Glab5", ;
		ToolTipText = "Seleccione Carpeta de Scripts", ;
		Top = 4
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Cnt1.Gmarco3' AS gmarco WITH ;
		Height = 21, ;
		Left = 1, ;
		Name = "Gmarco3", ;
		Top = 1, ;
		Width = 67
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'CntParam' AS cnttitedit WITH ;
		Height = 180, ;
		Left = 3, ;
		Name = "CntParam", ;
		TabIndex = 4, ;
		Top = 227, ;
		Width = 232, ;
		Gedit1.FontName = "Courier New", ;
		Gedit1.FontSize = 10, ;
		Gedit1.Name = "Gedit1", ;
		Gedit1.ReadOnly = .T., ;
		GLAB1.Caption = "<Parameters>", ;
		GLAB1.Name = "GLAB1", ;
		GMARCO1.Name = "GMARCO1"
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="container" />

	ADD OBJECT 'CntProp' AS cnttitedit WITH ;
		Height = 180, ;
		Left = 234, ;
		Name = "CntProp", ;
		TabIndex = 5, ;
		Top = 227, ;
		Width = 232, ;
		Gedit1.FontName = "Courier New", ;
		Gedit1.FontSize = 10, ;
		Gedit1.Name = "Gedit1", ;
		Gedit1.ReadOnly = .T., ;
		GLAB1.Caption = "<Properties>", ;
		GLAB1.Name = "GLAB1", ;
		GMARCO1.Name = "GMARCO1"
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="container" />

	ADD OBJECT 'gEdit1' AS editbox WITH ;
		BorderColor = 114,136,141, ;
		FontName = "Courier New", ;
		FontSize = 10, ;
		Height = 158, ;
		Left = 4, ;
		Name = "gEdit1", ;
		SpecialEffect = 1, ;
		Top = 69, ;
		Width = 462
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'GLAB1' AS glab WITH ;
		Caption = "<ExecScript>", ;
		Left = 9, ;
		Name = "GLAB1", ;
		TabIndex = 11, ;
		ToolTipText = "Carpeta de Scripts", ;
		Top = 30
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'GLAB4' AS glab WITH ;
		Caption = "Asunto", ;
		Left = 8, ;
		Name = "GLAB4", ;
		TabIndex = 12, ;
		Top = 53
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'GMARCO1' AS gmarco WITH ;
		Height = 21, ;
		Left = 4, ;
		Name = "GMARCO1", ;
		Top = 27, ;
		Width = 462
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'GMARCO2' AS gmarco WITH ;
		Height = 21, ;
		Left = 4, ;
		Name = "GMARCO2", ;
		Top = 49, ;
		Width = 43
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gmarco3' AS gmarco WITH ;
		Height = 21, ;
		Left = 240, ;
		Name = "Gmarco3", ;
		Top = 27, ;
		Width = 226
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'GTEXT1' AS gtext WITH ;
		Height = 21, ;
		Left = 46, ;
		Name = "GTEXT1", ;
		TabIndex = 2, ;
		Top = 49, ;
		Width = 420
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="textbox" />

	ADD OBJECT 'Shape3d1' AS shape3d WITH ;
		Height = 409, ;
		Left = 1, ;
		Name = "Shape3d1", ;
		Top = 1, ;
		Width = 470
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />
	
	PROCEDURE changecaption
		LPARAMETERS xcfile
		this.fileused=xcFile
		this.cmgen.Caption="\<Guardar"
		this.cleancaption(187)
		this.cleancaption(42)
		this.Parent.Caption=ALLTRIM(this.Parent.Caption);
				+" » Editing "+LOWER(xcfile)
	ENDPROC

	PROCEDURE cleancaption
		LPARAMETERS xnChar
		* xcChar », * (42)
		LOCAL nat
		WITH this
			nat=AT(CHR(xnChar),.Parent.Caption)
			IF nat#0
				.Parent.Caption=ALLTRIM(LEFT(.Parent.Caption,nat-1))
			ENDIF
		ENDWITH
	ENDPROC

	PROCEDURE Destroy
		this.noresize=.t.
		
		
		
	ENDPROC

	PROCEDURE getmedida
		LPARAMETERS xlINit
		TRY
			LOCAL loex as Exception
			WITH this
				.Width=.Parent.Width-1
				.Height=.Parent.Height-1
				.Shape3d1.Width=.Width-1
				.Shape3d1.Height=.Height-1
				.gmarco1.Width=.shape3d1.Width-8
				.Cmbfun.Left=.gmarco1.Left+.gmarco1.Width-.CmbFun.width
				.gedit1.Width=.gmarco1.Width
				.gText1.Width=.gmarco1.width-.gmarco2.width+2-.CmbFun.width
				.cmgen.Left=.gmarco1.Left+.gmARCO1.Width-.Cmgen.Width-2
				.Cmlimpiar.Left=.cmGen.Left-.cmlimpiar.Width-1
				.CmREad.Left=.Cmlimpiar.Left-.cmRead.Width-1
				.CmEje.Left=.Cmread.Left-.Cmeje.Width-1
				.gedit1.Height=.Height-.cntParam.Height ;
					- .gText1.Height - .gText1.Top - 4
					
				.gmarco3.Left=.gmarCO1.Left+.gmarCO1.Width-.gmarco3.width
				.cntParam.Top=.gedit1.Top+.gedit1.Height
				.cntprop.Top=.Cntparam.top
				.cntParam.Width=FLOOR(.Width/2)-4
				.CntProp.Width=.cntParam.Width
				.CntProp.Left=.gedit1.Left+.gedit1.Width-.cntProp.width
				.Cnt1.Width=.gmARCO1.width+1
		
			ENDWITH
		CATCH TO loEx
			loex.UserValue=PROGRAM(0)
			LOCAL obj
			obj=NEWOBJECT("prsfun","clases\prssys.vcx")
			obj.showError(loex)
		FINALLY
			obj=null
		ENDTRY
		
	ENDPROC

	PROCEDURE getobjexcel
		LOCAL objFun,lcObjEmpty,lExisEmpty,;
			lcExecute,lcExport,lctitle,;
			lcColumns,lcHeaders,lcSumcolumns,;
			lcLine,nLines,;
			ttcol,tthea,ttsum,ttTit
		
		LOCAL ARRAY gaCols(1)	
			
		objFun=NEWOBJECT("prsfun","clases\prssys.vcx")
		lcObjEmpty=objFun.DetectEmpty(this.gedit1)
		objFun=null
		lExisEmpty=!EMPTY(lcObjEmpty)
		lcObjEmpty=EVL(lcObjEmpty,"loEmpty")
		
		STORE "" TO lcExecute,lcExport,lctitle,;
			lcColumns,lcHeaders,lcSumcolumns	
		LOCAL ARRAY gaComp(6,4),galines(1)
		STORE "" TO gacomp
		gaComp[1,1]=[ADDPROPERTY(]+lcObjEmpty+[,"EXECUTE","<EXCEL>"]
		gaComp[1,2]=[ADDPROPERTY(]+lcObjEmpty+[,'EXECUTE','<EXCEL>']
		gaComp[1,3]="lcExeCute"
		gaComp[2,1]=[ADDPROPERTY(]+lcObjEmpty+[,"MSE_EXPORT",]
		gaComp[2,2]=[ADDPROPERTY(]+lcObjEmpty+[,'MSE_EXPORT',]
		gaComp[2,3]="lcExport"
		gaComp[3,1]=[ADDPROPERTY(]+lcObjEmpty+[,"MSE_TITLE",]
		gaComp[3,2]=[ADDPROPERTY(]+lcObjEmpty+[,'MSE_TITLE',]
		gaComp[3,3]="lctitle"
		gaComp[4,1]=[ADDPROPERTY(]+lcObjEmpty+[,"MSE_COLUMNS",]
		gaComp[4,2]=[ADDPROPERTY(]+lcObjEmpty+[,'MSE_COLUMNS',]
		gacomp[4,3]="lcColumns"
		gaComp[5,1]=[ADDPROPERTY(]+lcObjEmpty+[,"MSE_HEADERS",]
		gaComp[5,2]=[ADDPROPERTY(]+lcObjEmpty+[,'MSE_HEADERS',]
		gaComp[5,3]="lcHeaders"
		gaComp[6,1]=[ADDPROPERTY(]+lcObjEmpty+[,"MSE_SUM",]
		gaComp[6,2]=[ADDPROPERTY(]+lcObjEmpty+[,'MSE_SUM',]
		gacomp[6,3]="lcSumColumns"
		
		
		
		nlines=ALINES(gaLines,this.gedit1.Text)
		
		FOR i=1 TO nLines
			LcLine=UPPER(CHRTRAN(gaLines[i],CHR(32),""))
			
			FOR di=1 TO ALEN(gacomp,1)
				FOR dj=1 TO 2
					IF LEFT(LcLine,LEN(gaComp[di,dj]))==gacomp[di,dj]
						gaComp[di,4]=CHRTRAN(SUBSTR(gaLines[i],AT(",",gaLines[i],2)+1),['")],"")
					ENDIF
				NEXT
			NEXT
		NEXT
		FOR i=1 TO ALEN(gacomp,1)
			lcVar=gaComp[i,3]
			&lcVar = gaComp[i,4]
		NEXT
		
		TRY
			LOCAL loex as Exception
			ADDPROPERTY(_screen,"ofrmExcel",null)
			_Screen.oFrmExcel=NEWOBJECT("FrmBas","clases\prssys.vcx")
			WITH _Screen.oFrmExcel
				.Windowtype=1
				.MaxButton=.f.
				.MinButton=.f.
				.backcolor=RGB(184,201,197)
				.Caption="Crear Conexión MS Excel"
			ENDWITH	
			_SCREEN.oFrmExcel.NewObject("Cnt1","CntExcel","clases\prssys.vcx")
			WITH _screen.oFrmExcel
				.Cnt1.top=1
				.Cnt1.left=1
				.Cnt1.Visible=.t.
				.Cnt1.objEdit=this.gedit1
				.Cnt1.ExisEmpty=lExisEmpty
				.Height=.cnt1.Height+1
				.Width=.Cnt1.Width+1
				.AutoCenter=.t.
			ENDWITH
			STORE "" TO ttcol,tthea,ttsum,tttit
			FOR i=1 TO ALINES(gaCols,lcColumns,5,",")
				ttcol=ttcol+gaCols[i]+CHR(13)
			NEXT
			FOR i=1 TO ALINES(gaCols,lcHeaders,5,",")
				tthea=ttHea+gaCols[i]+CHR(13)
			NEXT	
				
			FOR i=1 TO ALINES(gaCols,lcSumColumns,5,",")
				ttSum=ttsum+gaCols[i]+CHR(13)
			NEXT	
			FOR i=1 TO ALINES(gaCols,lctitle,5,",")
				ttTit=ttTit+gaCols[i]+CHR(13)
			NEXT
			
			WITH _Screen.oFrmExcel.Cnt1
				.gtext6.value=lcObjEmpty
				.gText1.value=lcExport
				.gEdit1.Value=ttcol
				.gEdit2.value=tthea
				.gEdit3.Value=ttsum
				.gEdit4.value=ttTit
			ENDWITH
				
			_screen.ofrmExcel.Show()
			
		CATCH TO loEx
			obj=NEWOBJECT("Prsfun","clases\prssys.vcx")
			loex.UserValue=PROGRAM()
			obj.ShowError(loEx)
		FINALLY
			REMOVEPROPERTY(_screen,"ofrmExcel")
		ENDTRY
		
		
		
	ENDPROC

	PROCEDURE getparam
		RELEASE objEmpty
		PUBLIC objEmpty
		objEmpty=NEWOBJECT("Empty")
		ADDPROPERTY(_screen,"oFrmParam",null)
		ADDPROPERTY(_Screen,"RespParam",.f.)
		TRY
			LOCAL loEx as Exception,objf,nl,cL,i,lcPaRT,np,;
				lnTop,ni,lnWid,lcObj,lci,objFun
			LOCAL ARRAY galines(1),gapart(1),gaItem(1)
			nl=ALINES(galines,this.cntParam.gedit1.Value)
			cl=TRANSFORM(MAX(1,nl))
			lnTop=1
			ADDPROPERTY(objEmpty,"gadob[&cl,3]","")
			ADDPROPERTY(objEmpty,"CntCount",0)
			objFun=NEWOBJECT("Prsfun","clases\prssys.vcx")
		
			FOR i=1 TO nl
				STORE "" TO lcVar,lcTyp,lcDes
				np=ALINES(gaPart,STREXTRACT(gaLines[i],"<","/>"),1,"=")
				IF np=2
					lcVAr=gaPart[1]
					ni=ALINES(gaItem,gaPart[2],1+4,",")
					IF ni=2
						lcTyp=UPPER(gaItem[1])
						lcDes=gaItem[2]		
					ENDIF
					
				ENDIF
				objEmpty.gadob[i,1]=lcVar
				objEmpty.gadob[i,2]=lcTyp
				objEmpty.gadob[i,3]=lcDes
			NEXT
			
			_Screen.oFrmParam=NEWOBJECT("FrmBas","clases\prssys.vcx")
			WITH _Screen.oFrmParam
				.Windowtype=1
				.MaxButton=.f.
				.MinButton=.f.
				.backcolor=RGB(184,201,197)
				.Caption="Define Parameters"
			ENDWITH	
			_Screen.oFrmParam.NewObject("ShapeGen","Shape3d","clases\prssys.vcx")	
			_Screen.oFrmParam.NewObject("CmAceptar","cmParam","clases\prssys.vcx")	
			_Screen.oFrmParam.NewObject("CmAgregar","cmAddParam","clases\prssys.vcx")		
			WITH _Screen.oFrmParam
				.Shapegen.top=1
				.Shapegen.left=1
				.Shapegen.visible=.t.
				.CmAceptar.visible=.t.
				.CmAgregar.visible=.t.
			ENDWITH
				
			FOR i=1 TO ALEN(objEmpty.gadob,1)
				objFun.AddcntParam(_Screen.oFrmParam,.t.)
			NEXT
		
			_Screen.ofrmParam.AutoCenter=.t.
			_screen.oFrmParam.Show()
		
			IF PEMSTATUS(_screen,"RespParam",5) 
				IF _screen.respparam
					this.grespparam()
				ENDIF
			ENDIF
			
		CATCH TO loEx
			loEx.UserValue=PROGRAM()+" Entry parameters"
			LOCAL objd
			objd=NEWOBJECT("prsfun","clases\prssys.vcx")
			objd.ShowError(loex)
		FINALLY
			objfun=null
			_Screen.oFrmParam=null
			REMOVEPROPERTY(_screen,"ofrmParam")
			REMOVEPROPERTY(_screen,"respParam")
			objEmpty=Null
			RELEASE objEmpty
		
		ENDTRY
			
		
	ENDPROC

	PROCEDURE getproperties
		
		RELEASE objEmpty
		PUBLIC objEmpty
		objEmpty=NEWOBJECT("Empty")
		ADDPROPERTY(objEmpty,"gadob[1,3]","")
		objEmpty.gadob[1,3]=0
		ADDPROPERTY(objEmpty,"CntCount",0)
		ADDPROPERTY(objEmpty,"Cadena",",")
		ADDPROPERTY(objEmpty,"gadel[1]",0)
		ADDPROPERTY(objEmpty,"nDelete",0)
		ADDPROPERTY(objEmpty,"DBCLOSE","")
		
		
		ADDPROPERTY(_screen,"oFrmParam",null)
		ADDPROPERTY(_Screen,"RespParam",.f.)
		
		LOCAL lnLines,i,lExisEmpty,lcNameEmpty,lnTom,;
			Lccomp,lnLen,lnProp,lExisClose,objFun,;
			lcVerclose,Lcclose,TTCLOSE
		lcNameEmpty="LoEmpty"
		lcComp=""
		lnLen=0
		LOCAL ARRAY galines(1),gatom(1),gaProp(1),GACOLS(1)
		lnLines=ALINES(galines,this.gedit1.Text)
		objFun=NEWOBJECT("Prsfun","clases\prssys.vcx")	
		TRY 
			LOCAL loex as Exception
			
			FOR i=1 TO lnLines
				IF AT([NEWOBJECT("EMPTY")],UPPER(gaLines[i]))#0 ;
					OR AT([NEWOBJECT('EMPTY')],UPPER(gaLines[i]))#0
				
					lnTom=ALINES(gatom,galines[i],1,"=")
					IF lntom=2
						lExisEmpty=.t.
						lcNameEmpty=UPPER(ALLTRIM(gatom[1]))
						exit
					ENDIF
				ENDIF
			NEXT
			
			lcVerClose=[ADDPROPERTY(]+UPPER(lcNameEmpty)+[,"CLOSE",]
			IF lExisEmpty
				lcComp=[ADDPROPERTY(]+lcNameEmpty+","
				lnLen=LEN(lcComp)
				FOR i=1 TO lnLines
					IF LEFT(UPPER(CHRTRAN(gaLines[i],CHR(32),"")),LEN(lcVerClose))==lcVerClose
						lcClose=SUBSTR(galines[i],LEN(lcVerClose)+1)
						objEmpty.dbClose=CHRTRAN(lcClose,CHR(34)+CHR(39)+CHR(40)+CHR(41),"")
					ENDIF		
					IF LEFT(UPPER(galines[i]),lnlen)==lcComp
						lnProp=ALINES(gaprop,CHRTRAN(SUBSTR(galines[i],lnLen+1),["'()],""),1,",")
						IF lnProp=2
							IF AT(","+UPPER(gaProp[1])+",",this.forbiden)=0
								objEmpty.CntCount=objEmpty.CntCount+1
								DIMENSION objEmpty.gadob[objEmpty.CntCount,3]
								objEmpty.gadob[objempty.CntCount,1]=gaProp[1]
								objEmpty.gadob[objempty.CntCount,2]=gaProp[2]
								objEmpty.gadob[objEmpty.Cntcount,3]=i
								objEmpty.cadena=objEmpty.CAdena+UPPER(gaprop[1])+","	
								IF UPPER(gaprop[1])=="CLOSE"
									objEmpty.dbClose=CHRTRAN(gaprop[2],CHR(34)+CHR(39),"")
									lExisClose=.t.
								ENDIF
							ENDIF
						ENDIF
					ENDIF
				NEXT
			ENDIF
			IF objEmpty.CntCount=0
				objEmpty.CntCount=1
			ENDIF
		
		* <rev> ***********
		
		
			_Screen.oFrmParam=NEWOBJECT("FrmBas","clases\prssys.vcx")
			WITH _Screen.oFrmParam
				.Windowtype=1
				.MaxButton=.f.
				.MinButton=.f.
				.backcolor=RGB(184,201,197)
				.Caption="Define Properties"
			ENDWITH	
			_Screen.oFrmParam.NewObject("ShapeGen","Shape3d","clases\prssys.vcx")
			_Screen.oFrmParam.NewObject("CmAceptar","cmParam","clases\prssys.vcx")	
			_Screen.oFrmParam.NewObject("CmAgregar","cmAddParam","clases\prssys.vcx")		
			WITH _Screen.oFrmParam
				.CmAgregar.funcion="R"
				.CmAgregar.Caption="\<Más Propiedades"
				.CmAceptar.visible=.t.
				.CmAgregar.visible=.t.
				.shapegen.top=1
				.Shapegen.left=1
				.ShapeGen.Visible=.t.
			ENDWITH
			_Screen.ofrmParam.Newobject("oClose","CntClose","clases\prssys.vcx")
			
			WITH _Screen.ofrmparam.oClose
				.gEdit1.ControlSource='objEmpty.dbClose'
				.gLab3.Enabled=!EMPTY(objEmpty.dbClose)
				.visible=.t.
			ENDWITH		
				
			FOR i=1 TO objEmpty.CntCount
				objFun.AddcntProp(_Screen.oFrmParam,.f.)
			NEXT
		
		
			
			_Screen.ofrmParam.AutoCenter=.t.
			
			lcLastCnt="oCnt"+TRANSFORM(ObjEmpty.Cntcount)
			_Screen.oFrmParam.&lcLastCnt..gText1.SetFocus	
			
			_screen.oFrmParam.Show()
		
		
		
			IF PEMSTATUS(_screen,"RespParam",5) AND _screen.respparam
				this.grespproper()
			ENDIF
		
			objFun.DetectEmpty(this.gedit1,this.cntProp.gedit1)
		
		* </rev>	
		CATCH TO loEx
			loex.UserValue=PROGRAM()
			LOCAL objd
			objd=NEWOBJECT("prsfun","clases\prssys.vcx")
		FINALLY
			objfun=null
			objd=null
			_Screen.oFrmParam=null
			REMOVEPROPERTY(_screen,"ofrmParam")
			REMOVEPROPERTY(_screen,"respParam")
			objEmpty=Null
			RELEASE objEmpty
		ENDTRY
		
		
		
		
	ENDPROC

	PROCEDURE greadfile		&& Leer un script existente para edición
		LPARAMETERS xcfile
		LOCAL lnHand,lcFile,lcGet,obj,lFopen,;
			lScript,ldefParam,lProper,;
			lcScript,lcParam,lcProper,obj,lBadFile,;
			lOpenScript,lShutScript,lcfolder,lcFullpath
			
		STORE "" TO lcScript,lcParam,lcProper
		STORE .t. TO lBadFile
		lnHand= -1
		lcFullPath=FULLPATH("")
		lcFolder=thisform.folder
		IF EMPTY(xcfile) OR !FILE(xcFile)
			IF !EMPTY(lcFolder) AND DIRECTORY(lcFolder)
				CD &lcFolder
			ENDIF
			lcfile=GETFILE("TXT")
			CD &lcFullpath
			IF EMPTY(lcFile)
				RETURN
			ENDIF
		ELSE
			lcFile=xcFile
		ENDIF
		
		this.limpiar(.t.)
		obj=NEWOBJECT("prsfun","clases\prssys.vcx")
		lFopen=obj.getfopen(lcFile,@lnHand,.f.,0)
		
		IF !lFopen
			RETURN
		ENDIF
		
		TRY
			LOCAL loex as Exception
		
			DO WHILE !FEOF(lnHand)
				lcGet=FGETS(lnHand,4096)
				lcComp=UPPER(ALLTRIM(CHRTRAN(lcGet,CHR(9),"")))
				DO case
					CASE LEFT(lcComp,LEN("<SCRIPT|C|="))=="<SCRIPT|C|="
						This.gtEXT1.value=obj.GetValtag(lcGet)
						LOOP
						
					CASE LEFT(lcComp,LEN("<EXECSCRIPT>"))=="<EXECSCRIPT>"
						lOPenScript=.t.
						lScript=.t.
						LOOP
					
					CASE LEFT(lcComp,LEN("</EXECSCRIPT>"))=="</EXECSCRIPT>"
						this.gedit1.Value=lcScript
						lShutScript=.t.
						lScript=.f.
						LOOP
					
					CASE LEFT(lcComp,LEN("<PARAMETERS>"))=="<PARAMETERS>"
						ldefParam=.t.
						LOOP
					
					CASE LEFT(lcComp,LEN("</PARAMETERS>"))=="</PARAMETERS>"		
						this.cntParam.gedit1.Value=lcparam
						ldefParam=.f.
						LOOP
					
					CASE LEFT(lcComp,LEN("<PROPERTIES>"))=="<PROPERTIES>"		
						lProper=.t.
						LOOP
					
					CASE LEFT(lcComp,LEN("</PROPERTIES>"))=="</PROPERTIES>"			
						this.cntprop.gedit1.Value=lcProper
						lProper=.f.
						LOOP
					
				
				ENDCASE
				IF lScript
					lcScript=lcScript+lcGet+CHR(13)
				ENDIF
				IF lDefParam
					lcParam=lcParam+lcGEt+CHR(13)
				ENDIF
				IF lProper
					lcProper=lcProper+lcget+CHR(13)
				ENDIF
			
			ENDDO
		
		CATCH TO loEx
			loex.UserValue=PROGRAM()
			obj.showError(loEx)
		
		FINALLY
			obj=null
			=FCLOSE(lnHand)
			IF EMPTY(lcScript)
				lBadfile=.t.
			ENDIF
			
		ENDTRY
		IF VARTYPE(loEx)#"O"
			DO case
				CASE !lOpenScript AND !lShutScript
					MESSAGEBOX("El archivo "+LOWER(lcFile);
					+CHR(13)+"No contiene las etiquetas <EXECSCRIPT> y </EXECSCRIPT>",0,"gReadFile Message")
					this.limpiar()		
				CASE !lOpenSCript
					MESSAGEBOX("El archivo "+LOWER(lcFile);
					+CHR(13)+"No contiene la etiqueta <EXECSCRIPT>",0,"gReadFile Message")
					this.limpiar()		
				CASE !lShutScript
					MESSAGEBOX("El archivo "+LOWER(lcFile);
					+CHR(13)+"No contiene la etiqueta </EXECSCRIPT>",0,"gReadFile Message")
					this.limpiar()		
				OTHERWISE
				
					this.changecaption(lcFile)
					this.patext()
					thisform.Closable=.t.
					this.gedit1.Click()
					this.gedit1.SetFocus
			ENDCASE
			
		ENDIF
		
	ENDPROC

	PROCEDURE grespparam
		LOCAL lcJunta,lcObj,i,lcParam,lnScript,lcAdd,lcWrite
		STORE "" TO lcJunta,lcParam,lcAdd
		LOCAL ARRAY gascript(1)
		TRY
			LOCAL loex as Exception
			
			FOR i=1 TO ALEN(objEmpty.gadob,1)
				lcParam=lcParam+ALLTRIM(objEmpty.gadob[i,1])+","
				lcJunta=lcJunta+"<";
					+ALLTRIM(objEmpty.gadob[i,1])+"=";
					+objEmpty.gadob[i,2]+",";
					+PROPER(ALLTRIM(objEmpty.gadob[i,3]));
					+"/>"+CHR(13)
			ENDFOR
			lcParam=LEFT(lcParam,LEN(lcParam)-1)
		
			this.cntparam.gedit1.Value=lcJunta
		
			lnScript=ALINES(gaScript,this.gedit1.Text)
			IF UPPER(LEFT(gaScript[1],LEN("PARAMETERS")))=="PARAMETERS" ;
				OR UPPER(LEFT(gaScript[1],LEN("LPARAMETERS")))=="LPARAMETERS"
				
				gaScript[1]="LPARAMETERS "+lcParam
			ELSE
				lcAdd=lcParam
			ENDIF
			lcWrite=IIF(EMPTY(lcAdd),"","LPARAMETERS "+lcAdd+CHR(13))
			FOR i=1 TO lnScript
				lcWrite=lcWrite+gaScript[i]+CHR(13)
			NEXT
			this.gedit1.Value=lcWrite
		
		CATCH TO loex
			loex.UserValue=PROGRAM()
			LOCAL objd
			objd=NEWOBJECT("prsfun","clases\prssys.vcx")
			prsfun.showError(loex)
		FINALLY
			objd=null
		
		ENDTRY
		
	ENDPROC

	PROCEDURE grespproper
		LOCAL lcObj,i,j,lnScript,lcComp,lnMOd,nfop,;
			lcWrite,lnLines,lExisEmpty,lExisReturn,lcNameEmpty,;
			lnComp,lcClose,lcQuit
		STORE "" TO lcWrite,lcClose
		lcQuit=CHR(32)+CHR(34)+CHR(39)+CHR(9)+CHR(10)+CHR(13)
		lcNameEmpty="LoEmpty"
		LOCAL ARRAY gascript(1,3),gaLines(1)
		STORE 0 TO lnScript
		TRY
			LOCAL loex as Exception
			* Detectar Newobject("Empty")
			lnLines=ALINES(gaLines,this.gedit1.Text)
		
			FOR i=1 TO lnLines
				IF AT([NEWOBJECT("EMPTY")],UPPER(gaLines[i]))>0 ;
					OR AT([NEWOBJECT('EMPTY')],UPPER(gaLines[i]))>0
					lExisEmpty=.t.
					lcNameEmpty=ALLTRIM(LEFT(galines[i],AT("=",gaLInes[i])-1))
					EXIT
				ENDIF
			NEXT
			lcComp=[RETURN ]+UPPER(lcNameEmpty)
			lcVerClose=[ADDPROPERTY(]+UPPER(lcNameEmpty)+[,"CLOSE",]
			FOR i=1 TO lnLines
			*	IF AT(lcComp,UPPER(galines[i]))>0
				IF UPPER(LEFT(galines[i],LEN(lcComp)))==lcComp
					*lExisReturn=.t.
					gaLines[i]=""
				ENDIF
		
				IF LEFT(UPPER(CHRTRAN(gaLines[i],CHR(32),"")),LEN(lcVerClose))==lcVerClose
					lcClose=galines[i]
					galines[i]=""
				ENDIF
				
			NEXT
			IF !EMPTY(objEmpty.dbClose)
				objEmpty.dbClose=CHRTRAN(objEmpty.dbclose,CHR(13),",")
				objEmpty.dbClose=CHRTRAN(objEmpty.dbclose,CHR(32)+CHR(10),"")
				DO WHILE AT(",,",objEmpty.dbclose)>0
					objEmpty.dbclose=CHRTRAN(objEmpty.dbclose,",,",",")
				ENDDO
				
				lcClose=[ADDPROPERTY(]+lcNameEmpty+[,"CLOSE",];
					+["]+CHRTRAN(ObjEmpty.dbClose,lcQuit,"")+[")]
			ELSE
				lcClose=""
			ENDIF
			
			
			IF !lExisEmpty
				lnScript=lnScript+1
				DIMENSION gaSCript(lnScript,3)
				gaSCript[lnScript,1]=lcNameEmpty+[=NEWOBJECT("Empty")]
				gaScript[lnScript,2]=.t.
				gaScript[lnScript,3]=0
			ENDIF
			
			
			FOR i=1 TO ALEN(objEmpty.gadob,1)
				lnScript=lnScript + 1
				DIMENSION gaSCript(lnScript,3)
				gaScript[lnScript,1]=[AddProperty(]+lcNameEmpty+[,"];
					+ALLTRIM(objEmpty.gadob[i,1])+[",];
					+ALLTRIM(objEmpty.gadob[i,2])+[)]		
				gaScript[lnScript,2]=.t.
				gaScript[lnScript,3]=0					
			ENDFOR
			IF !EMPTY(lcClose)
				lnSCript=lnScript+1
				DIMENSION gaSCript(lnScript,3)
				gascript[lnScript,1]=lcClose
				gaScript[lnScript,2]=.t.
				gaScript[lnScript,3]=0
			ENDIF
							
			IF !lExisReturn
				lnScript=lnScript+1
				DIMENSION gaSCript(lnScript,3)
				gaSCript[lnScript,1]=[RETURN ]+lcNameEmpty
				gaScript[lnScript,2]=.t.
				gaScript[lnScript,3]=0		
			
			ENDIF
		
		*	Revisar si existen las propiedades en gaLines.
		*	Addproperty(loEmpty,"Propiedad","Valor")
		
		
			lcComp=[ADDPROPERTY(]+UPPER(lcNameEmpty)
			lncomp=LEN(LcComp)
		
			lcAt=","
			IF lnLines>0
				FOR i=1 TO lnScript
					lcVer=CHRTRAN(gaScript[i,1],CHR(32),"")
					nat=AT(lcAt,lcver,2)
					IF nat=0
						LOOP
					ENDIF
				
					lcVer=UPPER(LEFT(lcVer,nat))
		
		
					FOR j=1 TO lnLines
						lcLeft=ALLTRIM(gaLines[j])
						IF EMPTY(lcleft)
							LOOP
						ENDIF
						
						lcLeft=CHRTRAN(lcLeft,CHR(32),"")
						lcLeft=UPPER(LEFT(lcLeft,lnComp))
		
						IF lcLeft==lcComp
							lcEdit=CHRTRAN(gaLines[j],CHR(32),"")
							net=AT(lcAt , lcEdit , 2)
							IF net=0
								LOOP
							ENDIF
						
							lcEdit=UPPER(LEFT(lcEdit,net))
		
							IF lcEdit==lcVer
								gascript[i,2]=.f.
								gaSCript[i,3]=j
								EXIT
							ENDIF
						
						ENDIF
					NEXT
				NEXT
			ENDIF
			
			
		
			
			FOR i=1 TO lnScript
				lcput=gaScript[i,1]+" "+TRANSFORM(gaSCript[i,2]);
					+" "+TRANSFORM(gaSCript[i,3])
				IF !gaScript[i,2]
					lnMod=gaScript[i,3]
					gaLines[lnMod]=gaScript[i,1]
				ENDIF
			NEXT
		
			IF objEmpty.nDelete>0
				FOR i=1 TO objEmpty.nDelete
					lnBorr=objEmpty.gadel[i]
					galines[lnborr]=""
				NEXT
				
			ENDIF
				
		
			LcWrite=""
			FOR i=1 TO lnLines
				IF !EMPTY(gaLines[i])
					lcWrite=lcWrite + gaLines[i]+CHR(13)
				ENDIF
				
			NEXT
			
			FOR i=1 TO lnScript
				IF gaScript[i,2]
					lcWrite=lcWrite + gaScript[i,1] + CHR(13)
				ENDIF
			NEXT
			this.gedit1.Value=""
			this.gedit1.Value=lcWrite
			this.gedit1.SelStart=LEN(lcWrite)
			this.gedit1.SetFocus
			
		CATCH TO loex
			loex.UserValue=PROGRAM()
			LOCAL objd
			objd=NEWOBJECT("prsfun","clases\prssys.vcx")
			objd.showError(loex)
		FINALLY
			objd=null
		
		ENDTRY
		
	ENDPROC

	PROCEDURE guardar
		lparameters xlComo
		LOCAL lcFile,lnHand,nl,lnMess,i,obj,lcFullpath,lcFolder
		LOCAL ARRAY galines(1)
		lcFullpath=FULLPATH("")
		lcFolder=thisform.folder
		lcFile=iif(xlComo,"",this.fileused)
		if empty(lcfile)
			lcFile=PUTFILE("Archivo",this.fileused,"txt")
		ENDIF
		IF EMPTY(lcFile)
			RETURN
		ENDIF
		obj=NEWOBJECT("prsfun","clases\prssys.vcx")
		TRY
			LOCAL loex as Exception
			lnHand=FCREATE(lcFile)	
			
			=FPUTS(lnHand,Obj.puttag("SCRIPT",ALLTRIM(THIS.gText1.Value)))
			
			nl=ALINES(gaLines,this.gedit1.Value)
		
			=FPUTS(lnHand,"<EXECSCRIPT>")
			FOR I=1 TO NL
				IF !EMPTY(galines[i])
					=FPUTS(lnHand,gaLines[i])
				ENDIF
			ENDFOR
			=FPUTS(lnHand,"</EXECSCRIPT>")
		
			nl=ALINES(gaLines,this.cntParam.gedit1.Value)
			=FPUTS(lnHand,"<PARAMETERS>")
			FOR I=1 TO NL
				IF !EMPTY(galines[i])
					=FPUTS(lnHand,gaLines[i])
				ENDIF
			ENDFOR
			=FPUTS(lnHand,"</PARAMETERS>")
		
			nl=ALINES(gaLines,this.cntProp.gedit1.Value)
			=FPUTS(lnHand,"<PROPERTIES>")
			FOR I=1 TO NL
				IF !EMPTY(galines[i])
					=FPUTS(lnHand,gaLines[i])
				ENDIF
			ENDFOR
			=FPUTS(lnHand,"</PROPERTIES>")
			this.changecaption(lcfile)
			this.patext()
			thisform.Closable=.t.	
			
		CATCH TO loEx
			loex.UserValue=PROGRAM()+" Generando "+lcFile
		
			obj.ShowError(loEx)
		FINALLY
			=FCLOSE(LnHand)
			obj.genscriptdir(This.parent,This,this.parent.Folder)
			
			obj=null
			this.Cnt1.cmbdir1.Enabled=.f.
			
		ENDTRY
		
	ENDPROC

	PROCEDURE Init
		WITH this
			.BackStyle=0
			.SpecialEffect= 2
			.BorderWidth=0
			.fileused=""
			.ESinit=.T.
			.noresize=.t.
			.Width=.shape3d1.Width+1
			.Height=.shape3d1.Height+1
			.forbiden=",EXECUTE,MSE_EXPORT,MSE_TITLE,MSE_COLUMNS,MSE_HEADERS,MSE_SUMCOL,"
		ENDWITH
		this.limpiar()
		
		
		
	ENDPROC

	PROCEDURE limpiar
		LPARAMETERS lCmRead
		IF !lCmRead
			thisform.selfile=""
		ENDIF
		
		WITH this
			.gedit1.Value=""
			.gText1.Value=""
			.cntParam.gedit1.Value=""
			.cntprop.gedit1.Value=""
			IF !lCmRead		
				.Cmlimpiar.Enabled=.f.
				.cmgen.Enabled=.f.
				.Cmread.Enabled=.t.
				.CmGen.Caption="\<Generar"
				.fileused=""
				.Cnt1.cmbdir1.Refresh		
			ENDIF
			.cmeje.Enabled=.f.
			.Parent.funsel=""
			.cmbFun.Refresh
		ENDWITH
		This.cleancaption(187)
		this.cleancaption(42)
		thisform.Closable=.t.
	ENDPROC

	PROCEDURE patext
		LOCAL lcJoin,nColor
		ncolor=0
		lcJoin=""
		lcJoin=lcJoin+ALLTRIM(this.gedit1.Value)
		IF !EMPTY(lcJoin)
			nColor=255
		ENDIF
		
		lcJoin=lcJOin+ALLTRIM(this.cntParam.gedit1.Value)
		lcJoin=lcJOin+ALLTRIM(this.CntProp.gedit1.Value)
		WITH this
			.cmlimpiar.Enabled=!EMPTY(lcJoin)
			.cmread.Enabled=EMPTY(lcJoin)
			.cmgen.Enabled=!EMPTY(lcJoin)
			.cmEje.Enabled=IIF(!EMPTY(.fileused) and AT("*",.Parent.Caption)=0,.t.,.f.)
			.cnt1.cmbdir1.Enabled=EMPTY(lcJoin)
		ENDWITH
		
		
		
		
		
		
	ENDPROC

	PROCEDURE Resize
		IF !this.noresize
			this.getmedida()
		ENDIF
		
		
	ENDPROC

	PROCEDURE CmbFun.Click
		LOCAL lnItem,lcSel
		lnItem=this.ListItemId
		lcSel=ALLTRIM(this.ListItem(lnItem,2))
		DO case
			CASE EMPTY(lcSel)
			CASE lcsel="P"
				this.Parent.getparam()
			
			CASE lcSEl="X"
				This.Parent.getobjexcel()
			
			CASE lcSel="Y"
				this.Parent.getproperties()
		ENDCASE
		
		
		
		
	ENDPROC

	PROCEDURE CmbFun.Init
		ADDPROPERTY(thisform,"Funsel","")
		WITH this
			.clear
			.BoundColumn=2
			.ControlSource='Thisform.Funsel'
			.AddListItem("(Seleccione Tarea)",1,1)
			.AddListItem("",1,2)
			.AddListItem("Parámetros",2,1)
			.AddListItem("P",2,2)
			.AddListItem("Empty Class Properties",3,1)
			.AddListItem("Y",3,2)
			.AddListItem("Microsoft Excel ® Conection",4,1)
			.AddListItem("X",4,2)
			.Requery
			.Refresh
		ENDWITH
		
	ENDPROC

	PROCEDURE CmEje.Click
		LOCAL lcfile,objs
		*<ExecScript>
		lcFile=this.Parent.fileused
		IF EMPTY(lcFile) OR !FILE(lcFile)
			this.Parent.fileused=""
			this.Visible=.f.
			RETURN
		ENDIF
		
		objs=NEWOBJECT("prsfun","clases\prssys.vcx")
		objs.gSCript(lcFile)
		objs=null
	ENDPROC

	PROCEDURE CmGen.Click
		This.parent.guardar()
		
	ENDPROC

	PROCEDURE CmLimpiar.Click
		this.Parent.limpiar()
		
	ENDPROC

	PROCEDURE CmRead.Click
		this.Parent.greadfile()
		
	ENDPROC

	PROCEDURE Cnt1.Cmbdir1.Click
		LOCAL lnItem
		lnItem=this.ListItemId
		lcfile=ALLTRIM(this.ListItem(lnItem,2))
		IF !EMPTY(lcFile)
			this.Parent.Parent.greadfile(lcfile)
		ENDIF
		
		
	ENDPROC

	PROCEDURE Cnt1.Glab5.Click
		LOCAL lcFolder,objFun,lcDapli
		lcDapli=_screen.dapli
		lcFolder=thisform.folder
		IF DIRECTORY(lcFolder)
		*	CD &lcFolder
			lcFolder=GETDIR(lcFolder,"Carpeta","Carpeta de Scripts",64)
			CD &lcdapli
			IF !EMPTY(lcFolder)
				thisform.folder=IIF(RIGHT(lcFolder,1)="\",JUSTPATH(lcfolder),lcFolder)
				objFun=NEWOBJECT("prsfun","clases\prssys.vcx")
				objFun.genscriptdir(thisform,This.Parent.Parent,thisform.Folder)
				objFun=null
			ENDIF
		ENDIF
	ENDPROC

	PROCEDURE Cnt1.Resize
		LOCAL lnWidth,lnp1,lnp2
		
		WITH this
			lnWidth=.width-.gmarco3.Width-.gmarco3.Left+1
		ENDWITH
		lnp1=FLOOR(lnWidth*0.60)
		lnp2=lnWidth-lnp1
		
		WITH this.cmbdir1
			.width=lnWidth
			.columnWidths=TRANSFORM(lnp1)+","+TRANSFORM(lnp2)
		ENDWITH
		
		
	ENDPROC

	PROCEDURE CntParam.Gedit1.ProgrammaticChange
		this.Parent.Parent.patext()
		IF AT("*",thisform.Caption)=0
			thisform.Caption=ALLTRIM(thisform.Caption)+" *"
			thisform.Closable=.f.
		ENDIF
	ENDPROC

	PROCEDURE CntProp.Gedit1.ProgrammaticChange
		this.Parent.Parent.patext()
		IF AT("*",thisform.Caption)=0
			thisform.Caption=ALLTRIM(thisform.Caption)+" *"
			thisform.Closable=.f.
		ENDIF
	ENDPROC

	PROCEDURE gEdit1.Destroy
		IF PEMSTATUS(_screen,"ObjCopy",5)
			_screen.objcopy=null
			REMOVEPROPERTY(_screen,"ObjCopy")
		ENDIF
		IF PEMSTATUS(_screen,"ofrmCopy",5)
			_screen.oFrmCopy=null
			REMOVEPROPERTY(_screen,"oFrmCopy")
		ENDIF
		IF PEMSTATUS(thisform,"gmenu1",5)
			thisform.RemoveObject("gMenu1")
		ENDIF
	ENDPROC

	PROCEDURE gEdit1.GotFocus
		Thisform.Funsel=""
		this.Parent.cmbFun.Refresh
	ENDPROC

	PROCEDURE gEdit1.Init
		IF !PEMSTATUS(thisform,"gmenu1",5)
			thisform.NewObject("gmenu1","gmenu","clases\thmenu.vcx","",.t.)
		ENDIF
	ENDPROC

	PROCEDURE gEdit1.InteractiveChange
		this.Parent.patext()
		IF AT("*",thisform.Caption)=0
			thisform.Caption=ALLTRIM(thisform.Caption)+" *"
			thisform.Closable=.f.
		ENDIF
	ENDPROC

	PROCEDURE gEdit1.KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		LOCAL nSelStart
		IF nKeyCode=9
			NODEFAULT
			nSelStart=this.SelStart
			IF INLIST(ASC(SUBSTR(this.Value,nSelstart,1)),9,10,13)
				nSelStart=nSelStart+1
			ENDIF
			this.Value=STUFF(this.Value,nSelStart,0,CHR(9))
			this.SelStart=nSelStart
		ENDIF
	ENDPROC

	PROCEDURE gEdit1.ProgrammaticChange
		this.Parent.patext()
		IF AT("*",thisform.Caption)=0
			thisform.Caption=ALLTRIM(thisform.Caption)+" *"
			thisform.Closable=.f.
		ENDIF
	ENDPROC

	PROCEDURE gEdit1.RightClick
		thisform.gmenu1.gCopyPaste(thisform,this)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cnttitedit AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="GMARCO1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GLAB1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="gEdit1" UniqueID="" Timestamp="" />

	BackStyle = 0
	BorderWidth = 0
	Height = 200
	Name = "cnttitedit"
	Width = 200

	ADD OBJECT 'gEdit1' AS editbox WITH ;
		BorderColor = 114,136,141, ;
		DisabledBackColor = 242,247,243, ;
		DisabledForeColor = 0,0,0, ;
		FontName = "Courier New", ;
		FontSize = 10, ;
		Height = 81, ;
		Left = 1, ;
		Name = "gEdit1", ;
		ScrollBars = 0, ;
		SpecialEffect = 1, ;
		Top = 21, ;
		Width = 150
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'GLAB1' AS glab WITH ;
		Left = 5, ;
		Name = "GLAB1", ;
		Top = 4
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'GMARCO1' AS gmarco WITH ;
		Left = 1, ;
		Name = "GMARCO1", ;
		Top = 1, ;
		Width = 150
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />
	
	PROCEDURE Resize
		FOR EACH ocontrol IN this.Controls
			DO case
				CASE LOWER(ocontrol.baseclass)="editbox"
					oControl.Width=this.Width-1
					oControl.Height=this.Height-oControl.top		
				CASE LOWER(ocontrol.baseclass)="shape"
					oControl.Width=this.Width-1
			ENDCASE
		ENDFOR
		
	ENDPROC

	PROCEDURE gEdit1.Destroy
		IF PEMSTATUS(_screen,"ObjCopy",5)
			_screen.objcopy=null
			REMOVEPROPERTY(_screen,"ObjCopy")
		ENDIF
		IF PEMSTATUS(_screen,"ofrmCopy",5)
			_screen.oFrmCopy=null
			REMOVEPROPERTY(_screen,"oFrmCopy")
		ENDIF
		IF PEMSTATUS(thisform,"gmenu1",5)
			thisform.RemoveObject("gMenu1")
		ENDIF
	ENDPROC

	PROCEDURE gEdit1.Init
		IF !PEMSTATUS(thisform,"gmenu1",5)
			thisform.NewObject("gmenu1","gmenu","clases\thmenu.vcx","",.t.)
		ENDIF
	ENDPROC

	PROCEDURE gEdit1.RightClick
		thisform.gmenu1.gCopyPaste(thisform,this)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS dtext AS textbox 
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	Alignment = 3
	BorderColor = 114,136,141
	DisabledBackColor = 220,228,224
	DisabledForeColor = 0,0,0
	FontSize = 8
	Format = "D"
	Height = 21
	Name = "dtext"
	SpecialEffect = 1
	Value = (CTOD(""))
	Width = 63

ENDDEFINE

DEFINE CLASS frmbackup AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	BackColor = 184,201,197
	Caption = "Form"
	Desktop = .T.
	DoCreate = .T.
	Name = "frmbackup"
	ShowWindow = 1
	
	PROCEDURE Init
		LPARAMETERS xcDirApp
		thisform.NewObject("CntBackup1","CntBackup","clases\prssys.vcx","",xcDirApp)
		WITH this.CntBackup1
			.top=3
			.left=3
			.visible=.t.
		ENDWITH
		WITH thisform
			.Caption="Respaldo de Proyectos » FoxBin2prg ®"
			.Width=.CntBackup1.left*2+.CntBackup1.width
			.Height=.CntBackup1.top*2+.CntBackup1.height
			.MaxWidth=.width
			.Maxheight=.height
			.Maxbutton=.f.
		ENDWITH
		
			
	ENDPROC

	PROCEDURE Load
		LOCAL objFun
		objFun=NEWOBJECT("prsfun","clases\prssys.vcx")
		objFun.testmessage()
		objFun=null
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmbas AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	BackColor = 184,201,197
	Caption = "Form"
	DoCreate = .T.
	Name = "frmbas"
	ShowTips = .T.
	ShowWindow = 1
	
	PROCEDURE Destroy
		* For Eventual BindEvent
	ENDPROC

	PROCEDURE Init
		LPARAMETERS xnWinType
		this.WindowType=EVL(xnWinType,0)
		
	ENDPROC

	PROCEDURE Load
		LOCAL objFun
		objFun=NEWOBJECT("prsfun","clases\prssys.vcx")
		objFun.testmessage()
		objFun=null
	ENDPROC

ENDDEFINE

DEFINE CLASS frmdiff AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="GMARCO1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GMARCO2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GLAB1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gmarco3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cmbdir1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cmbdir2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gedit1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gedit2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cnt1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cnt1.Cmbdir1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cnt1.Cmbdir2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cnt1.Cmbdir3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cnt1.Cmbdir4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glab5" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: filcombo1
		*m: filcombo2
		*m: filcombo3
		*m: filcombo4
		*m: gencombo2
		*m: getmedida
		*m: getrefresh
		*p: addproc
		*p: fileused
		*p: folder
		*p: pcombo2
		*p: pcombo3
		*p: pcombo4
		*p: trydef
	*</DefinedPropArrayMethod>

	addproc = .F.
	BackColor = 184,201,197
	Caption = "FoxBin2prg » Análisis de Diferencias"
	DoCreate = .T.
	fileused = .F.
	folder = .F.
	Height = 341
	Left = 0
	Name = "frmdiff"
	pcombo2 = .F.
	pcombo3 = .F.
	pcombo4 = .F.
	ShowTips = .T.
	ShowWindow = 2
	Top = 0
	trydef = .F.
	Width = 756

	ADD OBJECT 'Cmbdir1' AS cmbdir WITH ;
		Height = 22, ;
		Left = 3, ;
		Name = "Cmbdir1", ;
		Top = 308, ;
		Visible = .F., ;
		Width = 375
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="combobox" />

	ADD OBJECT 'Cmbdir2' AS cmbdir WITH ;
		Left = 375, ;
		Name = "Cmbdir2", ;
		Top = 309, ;
		Visible = .F., ;
		Width = 375
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="combobox" />

	ADD OBJECT 'Cnt1' AS container WITH ;
		BackStyle = 0, ;
		BorderWidth = 0, ;
		Height = 22, ;
		Left = 2, ;
		Name = "Cnt1", ;
		Top = 2, ;
		Width = 683
		*< END OBJECT: BaseClass="container" />

	ADD OBJECT 'Cnt1.Cmbdir1' AS cmbdir WITH ;
		Height = 21, ;
		Left = 1, ;
		Name = "Cmbdir1", ;
		Top = 0, ;
		Width = 183
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="combobox" />

	ADD OBJECT 'Cnt1.Cmbdir2' AS cmbdir WITH ;
		Height = 21, ;
		Left = 183, ;
		Name = "Cmbdir2", ;
		Top = 0, ;
		Width = 180
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="combobox" />

	ADD OBJECT 'Cnt1.Cmbdir3' AS cmbdir WITH ;
		Height = 21, ;
		Left = 363, ;
		Name = "Cmbdir3", ;
		Top = 0, ;
		Width = 150
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="combobox" />

	ADD OBJECT 'Cnt1.Cmbdir4' AS cmbdir WITH ;
		Height = 21, ;
		Left = 511, ;
		Name = "Cmbdir4", ;
		Top = 0, ;
		Width = 120
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="combobox" />

	ADD OBJECT 'Gedit1' AS gedit WITH ;
		Height = 220, ;
		Left = 3, ;
		Name = "Gedit1", ;
		Top = 62, ;
		Width = 375
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="editbox" />

	ADD OBJECT 'Gedit2' AS gedit WITH ;
		Height = 220, ;
		Left = 377, ;
		Name = "Gedit2", ;
		Top = 62, ;
		Width = 375
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="editbox" />

	ADD OBJECT 'GLAB1' AS glab WITH ;
		Caption = "glab1", ;
		Left = 8, ;
		Name = "GLAB1", ;
		Top = 46
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Glab2' AS glab WITH ;
		Caption = "gLab2", ;
		Left = 382, ;
		Name = "Glab2", ;
		Top = 45
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Glab3' AS glab WITH ;
		Caption = "glab1", ;
		FontBold = .T., ;
		Left = 8, ;
		Name = "Glab3", ;
		Top = 26
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Glab4' AS glab WITH ;
		Caption = "Browse", ;
		ForeColor = 0,0,255, ;
		Left = 706, ;
		Name = "Glab4", ;
		Top = 25
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'Glab5' AS glab WITH ;
		Caption = "Mínimo", ;
		ForeColor = 0,0,255, ;
		Left = 666, ;
		Name = "Glab5", ;
		Top = 25
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="label" />

	ADD OBJECT 'GMARCO1' AS gmarco WITH ;
		Left = 3, ;
		Name = "GMARCO1", ;
		Top = 42, ;
		Width = 375
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'GMARCO2' AS gmarco WITH ;
		Left = 377, ;
		Name = "GMARCO2", ;
		Top = 42, ;
		Width = 375
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />

	ADD OBJECT 'Gmarco3' AS gmarco WITH ;
		BackColor = 242,247,243, ;
		Height = 21, ;
		Left = 3, ;
		Name = "Gmarco3", ;
		Top = 22, ;
		Width = 749
		*< END OBJECT: ClassLib="prssys.vcx" BaseClass="shape" />
	
	PROCEDURE Destroy
		* for any bindEvent
		LOCAL fcr,nfop,obj,objFun
		
		TRY
			LOCAL loex as Exception
			obj=NEWOBJECT("prsfun","clases\prssys.vcx")
			fcr=ADDBS(_Screen.Dapli)+"frmDiff.txt"
			nfop=FCREATE(fcr)
			=FPUTS(nfop,obj.PutTag("Top",this.Top))
			=FPUTS(nfop,obj.PutTag("Left",this.Left))
			=FPUTS(nfop,obj.PutTag("WindowState",this.WindowState))
			=FPUTS(nfop,obj.PutTag("Width",this.Width))
			=FPUTS(nfop,obj.putTag("Height",this.Height))
			=FPUTS(nfop,obj.PutTag("Folder",this.folder))
		CATCH TO loEx
			loEx.UserValue=PROGRAM()
			objFun=NEWOBJECT("Prsfun","clases\prssys.vcx")
			objFun.ShowError(loex)
		FINALLY 
			objfun=null
			obj=null
			=FCLOSE(nfop)
		ENDTRY
		
	ENDPROC

	PROCEDURE filcombo1
		LOCAL ARRAY gadef(1,3)
		LOCAL ndef,i,nat
		ndef=0
		gadef[1,1]=""
		gadef[1,2]=0
		gadef[1,3]=0
		WAIT WINDOW "Generando Define Class..." AT 12,15 NOWAIT 
		
		SELECT (thisform.fileused)
		SCAN
			DO case
				CASE LEFT(UPPER(TRYDEF),LEN("HEADER"))=="HEADER"
					NDEF=NDEF+1
					DIMENSION gadef(ndef,3)
					gadef[ndef,1]=TRIM(tryDef)
					gadef[ndef,2]=RECNO()
					gaDef[ndef,3]=0		
				
				CASE LEFT(UPPER(trydef),LEN("DEFINE"))=="DEFINE"
					IF ASCAN(gadef,TRIM(tryDef))=0
						NDEF=NDEF+1
						DIMENSION gadef(ndef,3)
						gadef[ndef,1]=TRIM(tryDef)
						gadef[ndef,2]=RECNO()
						gaDef[ndef,3]=0
					ENDIF
					
				CASE LEFT(UPPER(tryDef),LEN("ENDDEFINE"))=="ENDDEFINE"
					GADEF[ndef,3]=RECNO()
			ENDCASE
			
		ENDSCAN
		
		WAIT WINDOW "Filling Define Class..." AT 12,15 NOWAIT 
		thisform.trydef=gadef[1,1]
		WITH thisform.Cnt1.cmbdir1
			.BoundColumn=1
			.ControlSource='thisform.trydef'
			FOR i=1 TO ndef
				.Addlistitem(gaDef[i,1],i,1)
				.AddListitem(TRANSFORM(gadef[i,2]),i,2)
				.addlistitem(TRANSFORM(gaDef[i,3]),i,3)
			NEXT
			
			.requery
			.refresh
		ENDWITH
		Thisform.Filcombo2(gaDef[1,2],gadef[1,3])
		
	ENDPROC

	PROCEDURE filcombo2
		LPARAMETERS xnREc1,xnREc2
		LOCAL lcTryDef,ndef,i,nat,lcOrder
		LOCAL ARRAY gadef(1,4)
		gadef[1,2]=0
		gadef[1,3]=0
		STORE "" TO gadef
		ndef=0
		WAIT WINDOW "Generando Categorías..." AT 12,15 NOWAIT 
		lcTryDef=thisform.trydef
		*MESSAGEBOX("lcTryDef="+lcTryDef)
		IF !EMPTY(xnREc1) AND !EMPTY(xnREc2)
			SELECT (thisform.fileused)
			lcOrder=ORDER()
			SET ORDER TO
			GO xnRec1
			DO WHILE !EOF()
		*	SCAN FOR BETWEEN(RECNO(),xnREc1,xnREc2)
				IF RECNO()>xnREc2
					EXIT
				ENDIF
				
				DO case
					CASE EMPTY(addproc)
						IF LEFT(TRYDEF,LEN("ENDDEFINE"))=="ENDDEFINE"
						ELSE
							nat=AT(" ",trydef,3)
							IF nat=0
								lcTry=TRIM(tryDef)
							ELSE
								lcTry=LEFT(trydef,nat-1)
							ENDIF
							IF ASCAN(gadef,lcTRy)=0
								NDEF=NDEF+1
								DIMENSION gadef(ndef,4)
								gaDef[ndef,1]=PROPER(lcTry)
								gadef[ndef,2]=RECNO()
								gadef[ndef,3]=RECNO()
								gaDef[nDef,4]=lcTRy
							ELSE
								gadef[nDef,3]=RECNO()
							ENDIF			
						ENDIF
						
					
					CASE LEFT(addproc,LEN("ADD OBJECT"))=="ADD OBJECT"
						lcTry="ADD OBJECT"
						IF ASCAN(gadef,lcTRy)=0
							NDEF=NDEF+1
							DIMENSION gadef(ndef,4)
							gaDef[ndef,1]=PROPER(lcTry)
							gadef[ndef,2]=RECNO()
							gadef[ndef,3]=RECNO()
							gaDef[nDef,4]=lcTRy
						ELSE
							gadef[nDef,3]=RECNO()
						ENDIF
					CASE LEFT(addproc,LEN("PROCEDURE"))=="PROCEDURE"
						LcTRy="PROCEDURE"
						IF ASCAN(gadef,lcTRy)=0
							NDEF=NDEF+1
							DIMENSION gadef(ndef,4)
							gaDef[ndef,1]=PROPER(lcTry)
							gadef[ndef,2]=RECNO()
							gadef[ndef,3]=RECNO()
							gaDef[nDef,4]=lcTRy
						ELSE
							gadef[nDef,3]=RECNO()
						ENDIF
				ENDCASE
				SKIP
			ENDDO
			
			*ENDSCAN
			IF !EMPTY(lcOrder)
				SET ORDER TO (lcOrder)
			ENDIF
			
		ENDIF
		WAIT WINDOW "Filling Categorías..." AT 12,15 NOWAIT 
		thisform.pcombo2=gadef[1,4]
		WITH this.cnt1.cmbdir2
			.Clear
			.boundcolumn=4
			.Controlsource='Thisform.pcombo2'
			FOR i=1 TO ndef
				.addlistitem(gaDef[i,1],i,1)
				.addlistitem(TRANSFORM(gadef[i,2]),i,2)
				.addlistitem(TRANSFORM(gadef[i,3]),i,3)		
				.addlistitem(gaDef[i,4],i,4)			
			NEXT
			.requery
			.refresh
		ENDWITH
		thisform.filcombo3(gadef[1,2],gadef[1,3],gadef[1,4])
		
		
	ENDPROC

	PROCEDURE filcombo3
		LPARAMETERS xnREc1,xnREc2,xcpCombo2
		LOCAL lcCombo2,ndef,i,nat,LcAddproc,lcOrder
		LOCAL ARRAY gadef(1,3)
		gadef[1]="Define"
		gadef[2]=0
		gadef[3]="DEFINE"
		ndef=0
		WAIT WINDOW "Generando Objetos y Procedures..." AT 12,15 NOWAIT 
		lcCombo2=thisform.pCombo2
		IF !EMPTY(xnREc1) AND !EMPTY(xnREc2)
			SELECT (thisform.fileused)
			lcOrder=ORDER()
			SET ORDER TO
			GO xnREc1
			DO WHILE !EOF()
		*	SCAN FOR BETWEEN(RECNO(),xnREc1,xnREc2)
				IF RECNO()>xnREc2
					EXIT
				ENDIF
				lcAddproc=EVL(TRIM(addproc),GETWORDNUM(trydef,1))
				IF LEFT(lcAddproc,LEN("ADD OBJECT"))=="ADD OBJECT"
					lcAddproc=CHRTRAN(GETWORDNUM(lcAddproc,3),["'],"")
				ENDIF
				ndef=ndef+1
				DIMENSION gadef[ndef,3]
				gadef[ndef,1]=PROPER(ALLTRIM(lcAddproc))
				gadef[ndef,2]=RECNO()
				gadef[ndef,3]=TRIM(lcAddproc)
			*ENDSCAN
				SKIP
			ENDDO
			IF !EMPTY(lcOrder)
				SET ORDER TO (lcOrder)
			ENDIF
			
			
		ENDIF
		WAIT WINDOW "Filling Objetos y Procedures..." AT 12,15 NOWAIT
		thisform.pcombo3=gadef[1,3]
		WITH thisform.cnt1.cmbdir3
			.clear
			.BoundColumn=3
			.ControlSource='thisform.pcombo3'
			FOR i=1 TO ALEN(gadef,1)
				gadef[i,1]=CHRTRAN(gadef[i,1],CHR(9),CHR(32))
				nat=AT(CHR(32),gadef[i,1],2)
				lcPut=IIF(nat>0,LEFT(gadef[i,1],nat-1),gadef[i,1])
				.addlistitem(lcPut,i,1)
				.addlistitem(TRANSFORM(gadef[i,2]),i,2)
				.addlistitem(gadef[i,3],i,3)
			NEXT
			.requery
			.refresh
		ENDWITH
		thisform.filcombo4(xcpCombo2,gadef[1,3])
			
	ENDPROC

	PROCEDURE filcombo4
		LPARAMETERS xpcombo2,xpcombo3
		*!*	MESSAGEBOX("xpCombo2="+xpcombo2+CHR(13);
		*!*		+"xpCombo3="+xpCombo3)
			
		WITH THISFORM.CNT1.CMBdir4
			.CLEAR
			.Enabled=.f.
		ENDWITH
		
		
		IF UPPER(xpCombo2)#"ADD OBJECT"
			WAIT clear
				
			RETURN
		ENDIF
		WAIT WINDOW "Generando Procedures..." AT 12,15 NOWAIT
		LOCAL lcObjeto,ndef,i,lcTryDef
		LOCAL ARRAY gadef(1,3)
		gadef[1,1]="(Procedures)"
		gadef[1,2]=0
		gadef[1,3]=""
		nDef=1
		lcTryDef=thisform.trydef
		lcObjeto=UPPER("PROCEDURE "+ALLTRIM(xpCombo3))+"."
		
		
		SELECT (thisform.fileused)
		SCAN FOR UPPER(LEFT(addproc,LEN(lcobjeto)))==lcObjeto
			IF ALLTRIM(trydef)==lcTrydef
				ndef=ndef+1
				DIMENSION gadef(ndef,3)
				gadef[ndef,1]=PROPER(SUBSTR(addproc,AT(".",addproc)+1))
				gadef[ndef,2]=RECNO()
				gadef[ndef,3]=ALLTRIM(addproc)
			ENDIF
			
		ENDSCAN
		
		WAIT WINDOW "Filling Procedures..." AT 12,15 NOWAIT
		thisform.pcombo4=gadef[1,3]
		WITH thisform.cnt1.cmbdir4
			.clear
			.Boundcolumn=3
			.ControlSource='thisform.pcombo4'
			FOR i=1 TO ndef
				.addlistitem(gadef[i,1],i,1)
				.addlistitem(TRANSFORM(gadef[i,2]),i,2)
				.addlistitem(gadef[i,3],i,3)
			NEXT
			.Enabled=IIF(ndef>1,.t.,.f.)
			.requery
			.refresh
		ENDWITH
		WAIT clear
	ENDPROC

	PROCEDURE gencombo2
		LPARAMETERS xnREc1,xnRec2
		LOCAL lcTabla,nit,lnRecGo,lcAddproc,lcTryDef,nat,lcbus
		lnREcGo=0
		lcBus=REPLICATE(CHR(38),2)
		
		lcTabla=thisform.fileused
		SELECT (lcTabla)
		IF !EOF()
			lnREcGo=RECNO()
		ENDIF
		
		GO xnREc1
		nit=0
		lcAddproc=CHRTRAN(EVL(tRIM(addproc),PROPER(trydef)),CHR(9),"")
		nat=AT(lcBus,lcAddproc)
		IF nat>0
			lcAddproc=LEFT(lcAddproc,nat-1)
		ENDIF
		thisform.addproc=TRIM(lcAddProc)
		WITH thisform.cmbdir2
			.Clear
			.ControlSource='Thisform.addproc'
			SELECT (lcTabla)
			DO WHILE !EOF()
				nit=nit+1
				lcAddproc=CHRTRAN(EVL(tRIM(addproc),PROPER(trydef)),CHR(9),"")
				IF UPPER(LEFT(lcAddproc,LEN("ADD OBJECT")))=="ADD OBJECT"
					lcAddProc=LEFT(lcAddproc,AT("WITH",LcAddproc)-1)
				ENDIF
				nat=AT(lcbus,lcAddproc)
				IF nat>0
					lcAddproc=LEFT(lcAddproc,nat-1)
				ENDIF		
				.AddListitem(TRIM(lcAddProc),nit,1)
				.addlistitem(TRANSFORM(RECNO()),nit,2)
				SKIP
				IF EOF() OR RECNO() >= xnREc2
					EXIT
				ENDIF
			ENDDO
			.requery
			.refresh
		ENDWITH
		SELECT (lcTabla)
		IF lnRecGo>0
			GO lnRecGo
		ELSE
			GO top
		ENDIF
	ENDPROC

	PROCEDURE getmedida
		LOCAL lnWid,lnHei,objFun
		objFun=NewObject("prsfun","clases\prssys.vcx")
		lnWid=thisform.Width
		lnHei=thisform.Height
		TRY
			LOCAL loex as Exception
			WITH thisform
			*	.Grid1.Width=lnWid-6
				.gmarco3.width=lnWid-6
			*	.Grid1.Columns(2).Width=FLOOR((.Grid1.Width-15-.Grid1.Columns(3).Width)*0.60)
			*	.Grid1.Columns(1).Width=.Grid1.Width-15-.GRid1.Columns(3).Width-.Grid1.Columns(2).Width
		
				.gMarco1.Width=FLOOR((.gmarco3.width)/2)
				.gEdit1.Width=.gmarco1.Width
				.gEdit2.Width=.Gmarco3.Width-.gmarco1.Width+1
				.gmarco2.Width=.gEdit2.Width
				.Gmarco2.Left=.Gmarco1.left+.gmarco1.Width-1
				.gEdit2.left=.gmarco2.left
				.gLab2.left=.gmarco2.left+3
				.gEdit1.Height=lnHei-(.gmarco1.top+.gmarco1.Height)-4
				.gEdit2.height=.gEdit1.height
		*!*			.Cmbdir1.width=.gmarco1.Width
		*!*			.CmbDir2.Width=.gmarco2.Width
		*!*			.CmbDir2.left=.gmarco2.left
				.Glab4.left=.gmarco3.left+.gmarco3.width - .glab4.Width-2
				.glab5.left=.glab4.left-.glab5.width-2
				.Cnt1.Width=.gmarco3.width
			ENDWITH
		CATCH TO loex
			loex.UserValue=PROGRAM()
			objFun.ShowError(loex)
		FINALLY
			objfun=null
		ENDTRY
		
	ENDPROC

	PROCEDURE getrefresh
		LPARAMETERS xnREc
		LOCAL lcTabla
		lcTabla=this.fileused
		SELECT (lcTabla)
		GO xnREc
		WITH this
			.gedit1.refresh
			.gedit2.refresh
			.glab3.Caption="[";
				+TRIM(EVALUATE(lcTabla+".TryDef"));
				+"] » ";
				+TRIM(EVALUATE(lcTabla+".AddProc"))+" » ";
				+IIF(EVALUATE(lcTabla+".calif"),"Iguales","Difiere")			
		ENDWITH	
	ENDPROC

	PROCEDURE Init
		LPARAMETERS xcTabla,xcOri,xcNew
		
		LOCAL fcr,nfop,LnTop,lnLeft,lnWindowState,;
			lnMinHei,lnMinWid,lnWidth,lnHeight,lcFolder,objFun
		WITH this
			.folder=""
			lnTop=.Top
			lnLeft=.Left
			lnHeight=.Height
			lnWidth=.Width
			lnWindowState=0
			lnMinHei=300
			lnMinWid=630
			lcFolder=FULLPATH("")
		ENDWITH
		
		TRY
			
			LOCAL loex as Exception
			objFun=NEWOBJECT("prsfun","clases\prssys.vcx")
			lnTop=5
			lnLeft=20
			STORE 0 TO lnWindowState,lnHeight,lnWidth
			fcr=ADDBS(_Screen.Dapli)+"frmDiff.txt"
			IF FILE(fcr)
				nfop= -1
				IF objFun.getFopen(fcr,@nfop,.f.,0)
					DO WHILE !FEOF(nfop)
						lcGet=UPPER(FGETS(nfop,2048))
						DO case
							CASE LEFT(lcget,LEN("<TOP|N|="))=="<TOP|N|="
								lntop=objFun.GetValTag(lcGet)	
							CASE LEFT(lcget,LEN("<LEFT|N|="))=="<LEFT|N|="
								lnLeft=objFun.GetValtag(lcGet)
							CASE LEFT(lcget,LEN("<WINDOWSTATE|N|="))=="<WINDOWSTATE|N|="
								lnWindowState=objFun.getvaltag(lcGet)	
								
							CASE LEFT(lcget,LEN("<WIDTH|N|="))=="<WIDTH|N|="
								lnWidth=objFun.GetValTag(lcGet)	
								
							CASE LEFT(lcget,LEN("<HEIGHT|N|="))=="<HEIGHT|N|="
								lnHeight=objFun.GetValTag(lcGet)	
							CASE LEFT(lcGet,LEN("<FOLDER|C|="))=="<FOLDER|C|="
								LcFolder=objFun.GetValTag(lcget)
						ENDCASE
					ENDDO
				ENDIF
			ENDIF
		
		CATCH TO loEx
			loEx.UserValue=PROGRAM()
			objFun.ShowError(loex)
		FINALLY 
			=FCLOSE(nfop)
			obfun=null
		ENDTRY
		IF lnWindowState=1
			lnWindowState=0
		ENDIF
		
		WITH thisform
			.top=lnTop
			.left=lnLeft
			.Width=lnWidth
			.Height=lnHeight
			.WindowState=lnWindowState
			.MinWidth=lnMinWid
			.MinHeight=lnMinHei
			.fileused=xctabla
			.folder=lcFolder
			.gEdit1.controlsource='&xctabla..original'
			.gEdit2.ControlSource='&xctabla..foxbin'
			.gLab1.caption=xcOri
			.glab2.Caption=xcNew
		ENDWITH
		thisform.getmedida()
		
		LOCAL ARRAY gadef(1,3)
		LOCAL nDef
		nDef=0
		
		
		SCAN
			DO case
				CASE LEFT(UPPER(TRYDEF),LEN("HEADER"))=="HEADER"
					NDEF=NDEF+1
					DIMENSION gadef(ndef,3)
					gadef[ndef,1]=TRIM(tryDef)
					gadef[ndef,2]=RECNO()
					gaDef[ndef,3]=0		
				
				CASE LEFT(UPPER(trydef),LEN("DEFINE"))=="DEFINE"
					IF ASCAN(gadef,TRIM(tryDef))=0
						NDEF=NDEF+1
						DIMENSION gadef(ndef,3)
						gadef[ndef,1]=TRIM(tryDef)
						gadef[ndef,2]=RECNO()
						gaDef[ndef,3]=0
					ENDIF
					
				CASE LEFT(UPPER(tryDef),LEN("ENDDEFINE"))=="ENDDEFINE"
					GADEF[ndef,3]=RECNO()
			ENDCASE
			
		ENDSCAN
		GO top
		*!*	thisform.getrefresh(RECNO())
		*!*	IF nDef>0
		*!*		thisform.trydef=gadef[1,1]
		*!*		WITH thisform.cmbdir1
		*!*			.BoundColumn=1
		*!*			.ControlSource='thisform.trydef'
		*!*			FOR i=1 TO ndef
		*!*				.Addlistitem(gaDef[i,1],i,1)
		*!*				.AddListitem(TRANSFORM(gadef[i,2]),i,2)
		*!*				.addlistitem(TRANSFORM(gaDef[i,3]),i,3)
		*!*			NEXT
		*!*			
		*!*			.requery
		*!*			.refresh
		*!*		ENDWITH
		*!*		thisform.GenCombo2(gadef[1,2],gadef[1,3])
		*!*	ENDIF
		
		this.filcombo1()
		thisform.getrefresh(1)
		
		
		
	ENDPROC

	PROCEDURE Load
		LOCAL objFun
		objFun=NEWOBJECT("prsfun","clases\prssys.vcx")
		objFun.testmessage()
		objFun=null
	ENDPROC

	PROCEDURE Resize
		this.getmedida()
	ENDPROC

	PROCEDURE Cmbdir1.Click
		LOCAL lnItem,lnRec1,lnRec2
		lnItem=This.ListItemId
		IF lnitem#0
			lnREc1=VAL(this.ListItem(lnItem,2))
			lnRec2=VAL(this.ListItem(lnItem,3))
			thisform.GenCombo2(lnREc1,lnRec2)
			IF lnREc1#0
		
				thisform.getrefresh(lnREc1)
			
			ENDIF
			
			
		ENDIF
		
		
		
	ENDPROC

	PROCEDURE Cmbdir2.Click
		LOCAL lnItem,lnRec1,lnRec2
		lnItem=This.ListItemId
		IF lnitem#0
			lnREc1=VAL(this.ListItem(lnItem,2))
			IF lnREc1>0
				thisform.getrefresh(lnREc1)
			ENDIF
		ENDIF
	ENDPROC

	PROCEDURE Cnt1.Cmbdir1.Click
		LOCAL lnItem,lnRec1,lnRec2
		lnItem=This.ListItemId
		IF lnitem#0
			lnREc1=VAL(this.ListItem(lnItem,2))
			lnRec2=VAL(this.ListItem(lnItem,3))
			thisform.GenCombo2(lnREc1,lnRec2)
			thisform.Filcombo2(lnREc1,lnREc2)
			IF lnREc1#0
		
				thisform.getrefresh(lnREc1)
			
			ENDIF
			
			
		ENDIF
		
		
		
	ENDPROC

	PROCEDURE Cnt1.Cmbdir2.Click
		LOCAL lnItem,lnRec1,lnRec2
		lnItem=This.ListItemId
		IF lnitem#0
			lnREc1=VAL(this.ListItem(lnItem,2))
			lnRec2=VAL(this.ListItem(lnItem,3))
		*	thisform.GenCombo2(lnREc1,lnRec2)
			thisform.filCombo3(LnREc1,lnREc2,this.ListItem(lnitem,4))
			IF lnREc1#0
		
				thisform.getrefresh(lnREc1)
			
			ENDIF
			
			
		ENDIF
		
		
		
	ENDPROC

	PROCEDURE Cnt1.Cmbdir3.Click
		LOCAL lnItem,lnRec1,lnRec2
		lnItem=This.ListItemId
		IF lnitem#0
			lnREc1=VAL(this.ListItem(lnItem,2))
			Thisform.filcombo4(thisform.pcombo2,this.ListItem(lnitem,3))
			IF lnREc1#0
		
				thisform.getrefresh(lnREc1)
			
			ENDIF
			
			
		ENDIF
		
		
		
	ENDPROC

	PROCEDURE Cnt1.Cmbdir4.Click
		LOCAL lnItem,lnRec1,lnRec2
		lnItem=This.ListItemId
		IF lnitem#0
			lnREc1=VAL(this.ListItem(lnItem,2))
		
			IF lnREc1#0
		
				thisform.getrefresh(lnREc1)
			
			ENDIF
			
			
		ENDIF
		
		
		
	ENDPROC

	PROCEDURE Cnt1.Resize
		WITH this
			.Cmbdir4.Left=.Width-.Cmbdir4.Width-1
			.cmbdir3.Left=.Cmbdir4.left-.CmbDir3.Width
			.Cmbdir2.Left=.CmbDir3.left-.Cmbdir2.Width
			.CmbDir1.Width=.CmbDir2.Left-1
		ENDWITH
		
	ENDPROC

	PROCEDURE Gedit1.Click
		Thisform.gedit2.SelStart=this.SelStart
	ENDPROC

	PROCEDURE Gedit1.KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		LOCAL nSelStart
		DO case
			CASE nKeyCode=9
				NODEFAULT
				nSelStart=this.SelStart
				IF INLIST(ASC(SUBSTR(this.Value,nSelstart,1)),9,10,13)
					nSelStart=nSelStart+1
				ENDIF
				this.Value=STUFF(this.Value,nSelStart,0,CHR(9))
				this.SelStart=nSelStart
		
			CASE nKeyCode=-1
				thisform.gEdit2.SetFocus
		ENDCASE
		
	ENDPROC

	PROCEDURE Gedit2.Click
		Thisform.gedit1.SelStart=this.SelStart
	ENDPROC

	PROCEDURE Gedit2.KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		LOCAL nSelStart
		DO case
			CASE nKeyCode=9
				NODEFAULT
				nSelStart=this.SelStart
				IF INLIST(ASC(SUBSTR(this.Value,nSelstart,1)),9,10,13)
					nSelStart=nSelStart+1
				ENDIF
				this.Value=STUFF(this.Value,nSelStart,0,CHR(9))
				this.SelStart=nSelStart
			CASE nKeyCode=-1
				thisform.gEdit1.SetFocus
		ENDCASE
	ENDPROC

	PROCEDURE Glab4.Click
		SELECT (thisform.fileused)
		BROWSE
		
		
	ENDPROC

	PROCEDURE Glab5.Click
		IF thisform.windowState#0
			thisform.WindowState= 0
		ENDIF
		
		WITH thisform
			.MinHeight=300
			.MinWidth=630
			.Height=.minheight
			.Width=.minWidth
		ENDWITH
		
		
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmscript AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: noresize
		*p: selfile
	*</DefinedPropArrayMethod>

	BackColor = 184,201,197
	Caption = "Gen ExecScript"
	DoCreate = .T.
	Height = 424
	Left = 0
	Name = "frmscript"
	noresize = .F.
	selfile = .F.
	ShowTips = .T.
	ShowWindow = 2
	Top = 0
	Width = 477
	
	PROCEDURE Activate
		this.noresize=.f.
		
		
	ENDPROC

	PROCEDURE Destroy
		LOCAL fcr,nfop,obj,objFun
		TRY
			LOCAL loex as Exception
			obj=NEWOBJECT("prsfun","clases\prssys.vcx")
			fcr=ADDBS(_Screen.Dapli)+"frmScript.txt"
			nfop=FCREATE(fcr)
			=FPUTS(nfop,obj.PutTag("Top",this.Top))
			=FPUTS(nfop,obj.PutTag("Left",this.Left))
			=FPUTS(nfop,obj.PutTag("WindowState",this.WindowState))
			=FPUTS(nfop,obj.PutTag("Width",this.Width))
			=FPUTS(nfop,obj.putTag("Height",this.Height))
			=FPUTS(nfop,obj.PutTag("Folder",this.folder))
		CATCH TO loEx
			loEx.UserValue=PROGRAM()
			objFun=NEWOBJECT("Prsfun","clases\prssys.vcx")
			objFun.ShowError(loex)
		FINALLY 
			objfun=null
			obj=null
			=FCLOSE(nfop)
		ENDTRY
		
		
	ENDPROC

	PROCEDURE Load
		LOCAL objFun
		objFun=NEWOBJECT("prsfun","clases\prssys.vcx")
		objFun.testmessage()
		objFun=null
		
		this.noresize=.t.
		this.selfile=""
	ENDPROC

	PROCEDURE Moved
		*MESSAGEBOX("this.WindowState="+TRANSFORM(this.WindowState))
		
	ENDPROC

	PROCEDURE QueryUnload
		*MESSAGEBOX("QueryUnLoad Event")
		
	ENDPROC

	PROCEDURE Resize
		IF !this.noresize
			this.cntSCrip1.resize()
		ENDIF
		
		
	ENDPROC

	PROCEDURE Unload
		*MESSAGEBOX("Unload Event")
	ENDPROC

ENDDEFINE

DEFINE CLASS funmark AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: aadd
		*m: addgarelea
		*m: addtagtofile
		*m: addtofile
		*m: arraytocursor
		*m: comparetags
		*m: cursortoarray
		*m: detfecha
		*m: dt_emptyobj
		*m: fonlydigit
		*m: foxbinversion
		*m: galltags
		*m: gencursor
		*m: getbackup
		*m: getfoxbin1
		*m: getfoxbin2
		*m: getfoxbinrep
		*m: getlinea
		*m: getmask
		*m: guserprop
		*m: inone
		*m: mensajero
		*m: parserform		&& Obtiene en un archivo de texto marcado el contenido de un Form scx
		*m: parsermemo
		*m: parsermnu
		*m: parservcx
		*m: pdifmnu
		*m: readfoxbin		&& Leer un archivo base 2 de Foxbinprg (Fernando Bozzo)
		*m: rescueproy
		*m: rv_fdate
		*m: selbackup
		*m: showerror
		*m: suredir
		*m: teldecim
		*m: testmessage
		*m: tradutoc		&& Convierte String fecha AAAAMMDDHHMMSS en un formato legible
		*m: writeerror
		*p: dirformu
		*p: fileo
		*p: filetext
		*p: filew
		*p: garelea
		*p: menutype
		*p: seltag
		*p: th_mensaje		&& Mensaje para Messagebox(,,)
		*p: tipout
	*</DefinedPropArrayMethod>

	dirformu = 
	fileo = .F.
	filetext = .F.
	filew = .F.
	menutype = 1
	Name = "funmark"
	seltag = .F.
	tipout = .F.
	Width = 35
	
	PROCEDURE aadd
		lparameters xgaMatriz,xnPos,xcString
		EXTERNAL ARRAY xgaMatriz
		if vartype(xnPos)#"N"
			xnPos=0
		endif
		if vartype(xcString)#"C"
			xcString=""
		endif
		
		xnPos=xnPOs+1
		dimension xgaMatriz(xnPos)
		xgaMatriz[xnpos]=xcString
		return xnPos
	ENDPROC

	PROCEDURE addgarelea
		LPARAMETERS xcNameForm
		* this.addgarelea(cNOm)
		xcNameForm=Upper(alltrim(xcNameForm))
		if at(xcNameform+",",this.garelea)=0
			this.garelea=this.garelea+xcNameForm+","
		endif
	ENDPROC

	PROCEDURE addtagtofile
		LPARAMETERS xcFile,xcTag,xlDelete
		*!*	Agregar o reemplazar una tag en un archivo plano
		*!* xlDelete permite eliminar la tag del archivo.
		*!*	-------------------------------------------------
		LOCAL lnTag,lcGet,lcTag,lnHand
		LOCAL ARRAY gatags(1)
		lnTag=0
		nAt=AT("|=",xctag)
		IF nat=0
			lcTag=LEFT(xcTag,AT("=",xcTag)-1)
		ELSE
			lcTag=LEFT(xcTag,nat+1)
		ENDIF
		
		IF !FILE(xcfile)
			* crear xcfile vacío
			lnHand=FCREATE(xcfile)
			=FCLOSE(lnHand)
		ENDIF
		
		*<Lectura y armado de Array>
		lnHand=FOPEN(xcfile,0)
		IF lnHand < 0
			RETURN
		ENDIF
		DO WHILE !FEOF(lnHand)
			lcGEt=FGETS(lnHand,2048)
			IF EMPTY(lcGet)
				LOOP
			ENDIF
			lntag=lnTag+1
			DIMENSION gaTAgs(lnTag)
			IF LEFT(lcGet,LEN(lcTag))==lcTag
				* reemplazo
				gaTags[lnTag]=IIF(xlDelete,"",xcTag)
			ELSE
				gaTags[lnTag]=lcGet
			ENDIF
		ENDDO
		=FCLOSE(lnHand)
		*</Lectura y armado de Array>
		
		*<Reemplazo>
		lnHand=FCREATE(xcFile)
		FOR i=1 TO ALEN(gaTAgs)
			IF !EMPTY(gaTags[i])
				=FPUTS(lnHand,gaTags[i])
			ENDIF
			
		NEXT
		=FCLOSE(lnhand)
		*</Reemplazo>
		RETURN 
	ENDPROC

	PROCEDURE addtofile
		LPARAMETERS xnHand,xcStore,xcPut
		* nHand=.addtoFile(nHand,lcFile,lcget)
		IF xnHand=-1
			xnHand=FCREATE(xcStore)
		ENDIF
		=FPUTS(xnHand,xcPut)
		RETURN xnHand
		
	ENDPROC

	PROCEDURE arraytocursor
		LPARAMETERS xgamat,xcNameCur
		EXTERNAL ARRAY xgamat
		
		LOCAL lnf,i,j,lcDecim,lcNumero
		IF EMPTY(xcNameCur)
			xcNamecur="Curgen"
		ENDIF
		IF USED(xcnamecur)
			SELECT (xcNamecur)
			USE
		ENDIF
		
		LNF=ALEN(xgamat,2)
		LOCAL ARRAY gatype(lnf,3)
		FOR j=1 TO ALEN(xgamat,2)
			gatype[j,1]=VARTYPE(xgamat[1,j])
			gatype[j,2]=0
			gatype[j,3]=0
		
		NEXT
		FOR i=1 TO ALEN(xgamat,1)
			FOR j=1 TO lnf
				DO case
					CASE gatype[j,1]="C"
						gatype[j,2]=MAX(gatype[j,2],LEN(xgamat[i,j]))	
					CASE gatype[j,1]="N"
						*InputMask=this.getmask(lnNUmero,2,.t.)
						lnDecim=TelDecim(xgamat[i,j])
						lcNumero=CHRTRAN(this.getmask(xgamat[i,j],lnDecim),",","")
						gatype[j,2]=MAX(gatype[j,2],LEN(lcNumero))
						gatype[j,3]=MAX(gatype[j,3],lnDecim)
					CASE gatype[j,1]="L"
						gatype[j,2]=1
					CASE gatype[j,1]="D"
						gatype[j,2]=8
					CASE gatype[j,1]="T"
						gatype[j,2]=16
					
					OTHERWISE
						gatype[j,2]=20
				ENDCASE
				
			
			NEXT
			
		
		NEXT
		
		
		LOCAL ARRAY GACUR(LNF,4)
		FOR I=1 TO LNF
			gaCur[i,1]="CAMPO"+TRANSFORM(I)
			gaCur[i,2]=gatype[i,1]
			gacur[i,3]=gatype[i,2]
			gacur[i,4]=gatype[i,3]
		NEXT
		
		CREATE CURSOR &xcNameCur FROM ARRAY gacur
		SELECT (xcNameCur)
		FOR i=1 TO ALEN(xgamat,1)
			APPEND BLANK
			
			FOR j=1 TO ALEN(xgamat,2)
				lcCampo=FIELD(j)
				replace (lcCampo) WITH xgamat[i,j]
			NEXT
		NEXT
		SELECT (xcNameCur)
		
		
	ENDPROC

	PROCEDURE comparetags
		LPARAMETERS xlContinue,xcTable,xcEtiq
		*,xcSelTag,xcTipOut,xcFileo,xcFilew
		
		LOCAL lcd,lcfile,lntags,lcTag,lcTipOut,;
			nfop,nfap,lfap,lwrite,fcr,i,j,nj,lnOrden,nHand,;
			lcTable,lcFitab,lcEtiq,lcRoot,objfun
		objFun=NewObject("Prsfun","clases\prssys.vcx")
		
		IF xlContinue
			lcTable=xcTable
			lcEtiq=xcEtiq
		ENDIF
		lcRoot=ADDBS(dserv)
		lcTag=this.SelTag
		lctipOut=This.TipOut
		lcEnd="</"+SUBSTR(lcTag,2)
		lcfile=This.fileo
		lcFilew=this.filew
		
		
		LOCAL ARRAY gaText(2,5)
		gaText[1,1]=lcFile
		gaTExt[1,2]=-1
		gatext[1,3]=ADDBS(_Screen.dtemp)+JUSTSTEM(lcfile)+"_"+lctipout+".txt"
		gaTExt[1,4]=-1
		gaTExt[1,5]=0
		gaText[2,1]=lcFilew
		gaText[2,2]=-1
		gaTExt[2,3]=ADDBS(_Screen.dtemp)+JUSTSTEM(lcfilew)+"_"+LcTipout+".txt"
		gaText[2,4]=-1
		gaTExt[2,5]=0
		LOCAL lnOpen
		lnOPen=-1
		FOR i=1 TO ALEN(gatext,1)
			IF Getfopen(gaText[i,1],@lnOPen,.f.,12)
				gaText[i,2]=lnOPen
			ENDIF
			gaTExt[i,4]=FCREATE(gaText[i,3])
		NEXT
		* Control de fopen,fcreate
		lFalla=.f.
		FOR i=1 TO ALEN(gatext,1)
			IF gaTExt[i,2]=-1 OR gaText[i,4]=-1
				lFalla=.t.
				EXIT
			ENDIF
		NEXT
		IF lFalla
			FOR i=1 TO ALEN(gaText,1)
				IF gaText[i,2]# -1
					FCLOSE(gaText[i,2])
				ENDIF
				IF gaTExt[i,4]# -1
					FCLOSE(gaText[i,4])
				ENDIF
			NEXT
			MESSAGEBOX("Algún archivo no pudo reabrirse")
			RETURN
		ENDIF
		
		
		FOR i=1 TO ALEN(gatext,1)
			=FPUTS(gaTExt[i,4],"*Detección de Tags "+lcTag+" en "+gaTExt[i,1])
			=FPUTS(gaTExt[i,4],"*"+TTOC(DATETIME()))
			=FPUTS(gaTExt[i,4],REPLICATE("=",30))	
			gatext[i,5]=this.guserprop(gaText[i,2],gaTExt[i,4])
		NEXT
		
		FOR i=1 TO ALEN(gaText,1)
			FCLOSE(gaTExt[i,2])
		NEXT
		
		IF !xlContinue
			lcTable=JUSTSTEM(lcFile)
			lcEtiq="i"+lcTable
			
			IF USED(lcTable)
				SELECT (lcTable)
				USE
			ENDIF
		ENDIF
		
		
		lnSumTags=0
		FOR i=1 TO ALEN(gatext,1)
			lnSumTags=lnsumTags+gatext[i,5]
		NEXT
		
		IF LnSumTags=0
			IF !xlContinue
				MESSAGEBOX("Los archivos examinados no contienen la etiqueta "+lcTag,0,Th_mensaje)
			ENDIF
			
			*Close files
			FOR i=1 TO ALEN(gaText,1)
				FCLOSE(gaTExt[i,4])
			NEXT
			RETURN
			
		ENDIF
		
		IF !xlContinue
			THIS.GEncursor(LcTable)
		ENDIF
		
		
		lnOrder=1	&& 1 o 2
		
		
		LcObjeName="<ObjName|C|="
		lcObjeto=""
		*lcShut="<ObjName|C|="
		LcShut="</TAG>"
		lnLen=LEN(lcShut)
		Lcclass="<BaseClass|C|="
		lnClass=LEN(lcClass)
		
		lcParentTag="<Parent|C|="
		lnParent=LEN(lcParentTag)
		
		lWrite=.f.
		STORE "" TO lcObjeto,lcBaseClass,lcParent
		LOCAL ARRAY gajun(1)
		SET EXACT ON
		
		FOR i=1 TO ALEN(gaText,1)
			xnfop=gaText[i,4]
			DIMENSION GAJUN(1)
			nj=0
			lnOrden=i
			FSEEK(XNFOP,0,0)
			DO WHILE !FEOF(XNFOP)
				lcGet=ALLTRIM(FGETS(xnfop,2048))
				DO case
					CASE lcGet==lcEnd
						lwrite=.f.
					CASE LEFT(lcGet,lnClass)=lcClass
						lcBaseclass=objfun.getValTag(UPPER(lcGet))
					CASE LEFT(lcGet,lnParent)==lcparentTag
						lcParent=objfun.getValTag(UPPER(lcGet))
					CASE LEFT(lcGEt,LEN(lcObjeName))==lcObjeName
						lcObjeto=objfun.getValTag(UPPER(lcGet))
					CASE LEFT(lcGet,LEN(lcShut))==lcShut
						
						lcPut=""
						FOR j=1 TO nj
							lcPut=lcput+gajun[j]+CHR(13)
						NEXT
						lcPut=LEFT(lcPut,LEN(lcPut)-1)
						nj=0
						DIMENSION gajun(1)
						lcBusca=lcParent+lcObjeto+lcTag
						*IF !INDEXSEEK(lcObjeto,.f.,lcTable,lcEtiq)
						IF !INDEXSEEK(lcBusca,.f.,lcTable,lcEtiq)
							IF lnOrden=1
								INSERT INTO &lctable (objeto,parent,baseclass,nametag,original) ;
									VALUES (lcObjeto,lcParent,lcBaseClass,lcTag,lcPUt)
							ELSE
								INSERT INTO &lctable (objeto,parent,baseclass,nametag,foxbin2) ;
									VALUES (lcObjeto,lcParent,lcBaseClass,lcTag,lcPUt)
							ENDIF
						ELSE
							lcRempla=IIF(lnOrden=1,"Original","Foxbin2")
							SELECT (lcTable)
							*INDEXSEEK(lcObjeto,.t.,lcTable,lcEtiq)
							INDEXSEEK(lcBusca,.t.,lcTAble,lcEtiq)
							replace (lcRempla) WITH lcput
						ENDIF
						STORE "" TO lcParent
					CASE lcGet==lcTag
						lWrite=.t.
						loop			
		
					
				ENDCASE
				IF lWrite
					nj=nj+1
					DIMENSION gaJun(nj)
					gajun[nj]=lcGet
				ENDIF
			ENDDO
		NEXT
		
		*Close files
		FOR i=1 TO ALEN(gaText,1)
			FCLOSE(gaTExt[i,4])
		NEXT
		
		IF USED(lcTable)
			SELECT (lcTable)
			SCAN
				lnLenOri=LEN(original)
				lnLenBin=LEN(foxbin2)
				LnLinOri=ALINES(gaLinor,Original)
				lnLinBin=ALINES(gaLinbn,foxbin2)
				REPLACE LENORI WITH lnLenOri,;
					LENBIN WITH lnLenBin,;
					COMPARA WITH IIF(ORIGINAL=FOXBIN2,.T.,.F.),;
					LENDIF WITH lnLenOri-lnLenBin,;
					linori WITH lnLinori,;
					linbin WITH lnLinBin,;
					Lindif WITH lnLinOri-lnLinBin
				
			ENDSCAN
			IF !xlContinue
				GO top
				BROWSE
			ENDIF
			
		ENDIF
		IF !xlContinue
			IF USED(lcTable)
				SELECT (lcTable)
				USE
			ENDIF
		ENDIF
		SET EXACT OFF
		objfun=null
		
	ENDPROC

	PROCEDURE cursortoarray
		LPARAMETERS xcNameCur,xgaArray,xlClose
		LOCAL lnfields,lnPas,xvalor
		IF !USED(xcNameCur)
			DIMENSION xgaArray(1)
			STORE "" TO xgaArray
			RETURN .f.
		ENDIF
		
		SELECT (xcNameCur)
		COUNT TO LnRegis
		LNPas=0
		LnFields=AFIELDS(gaFields,xcNameCur)
		
		DIMENSION xgaArray(LnRegis,Lnfields)
		SCAN
			LNPAS=LNPAS+1
			FOR i=1 TO Lnfields
				lcCampo=FIELD(i)
				xValor=EVALUATE(lcCampo)
				IF gaFields[i,2]="C"
					xValor=ALLTRIM(xValor)
				ENDIF
				xgaArray[lnPas,i]=xValor
			NEXT
		ENDSCAN
		IF xlClose
			USE
		ENDIF
		
		RETURN .T.
		
	ENDPROC

	PROCEDURE Destroy
		*release oform
		if !empty(this.garelea)
			kerelea=alltrim(this.garelea)
			if right(kerelea,1)=","
				nlen=len(kerelea)
				kerelea=Substr(kerelea,1,nlen-1)
			endif
			release &kerelea
		endif	
	ENDPROC

	PROCEDURE detfecha
		LPARAMETERS xcFEcha
		LOCAL dfecha,lnLen,lnBar,lnAno,lnMes,lnDia
		lnAno=YEAR(DATE())
		lnMes=MONTH(DATE())
		lnDia=DAY(DATE())
		
		dfecha=CTOD("")
		* 25/12/2013
		* 20132512
		lnLen=LEN(xcFecha)
		lnBar=OCCURS("/",xcFecha)
		
		DO case
			CASE lnBarr=0
				DO case
					CASE lnLen=8
					*dtos(date())
						lnAno=VAL(left(xcFecha,4))
						lnMes=VAL(SUBSTR(xcFecha,5,2))
						lnDia=VAL(RIGHT(xcFecha,2))
						dFecha=DATE(lnAno,lnMes,lndia)
					CASE lnLen=7
						lnAno=VAL(left(xcFecha,4))
						lnMes=VAL(SUBSTR(xcFecha,5,2))
						IF BETWEEN(lnMes,1,12)
							lnDia=VAL(RIGHT(xcFecha,1))		
						ELSE
							lnMes=VAL(SUBSTR(xcFecha,5,1))
							lnDia=VAL(RIGHT(xcFecha,2))
						ENDIF
						dFecha=DATE(lnAno,lnMes,lndia)			
					CASE lnLen=6
						lnAno=VAL(left(xcFecha,4))
						lnMes=VAL(SUBSTR(xcFecha,5,2))
						lndia=1	
						dFecha=DATE(lnAno,lnMes,lndia)				
					OTHERWISE
				ENDCASE
			
			CASE lnBarr=2
				nl=ALINES(gaDAte,xcFEcha,1,"/")
				IF nl=3
					DO case
						CASE LEN(gaDate[3])=4
							lnAno=VAL(gadate[3])
							lnMes=VAL(gadate[2])
							lnDia=VAL(gadate[1])	
						
						CASE LEN(gadate[1])=4
							lnAno=VAL(gaDate[1])
							lnMes=VAL(gadate[2])
							lndia=VAL(gadate(3))
						
					ENDCASE
					dfecha=DATE(lnAno,lnMes,lnDia)
						
					
				ENDIF
		
		ENDCASE
		
		RETURN dfecha
		
	ENDPROC

	PROCEDURE dt_emptyobj
		LPARAMETERS xoObjeto
		LOCAL ocontrol,ocont,objPict,opage
		
		DO case
			CASE UPPER(xoObjeto.Baseclass)=="FORM"
				* Se crea la propiedad dtoSalir como bandera 
				* de salida de recursividad
				ADDPROPERTY(_Screen,"dtoSalir",.f.)
				FOR EACH oControl IN xoObjeto.Controls
					This.Dt_EmptyObj(oControl)
					IF _screen.dtoSalir
						RETURN !_Screen.dtosalir
					ENDIF
				ENDFOR
				
			CASE UPPER(xoObjeto.Baseclass)="CONTAINER"
		
				FOR EACH xoObjeto IN xoObjeto.Controls
					This.Dt_EmptyObj(xoObjeto)
					IF _screen.dtoSalir
						RETURN !_Screen.dtosalir
					ENDIF			
				ENDFOR		
		
			CASE UPPER(xoObjeto.Baseclass)="PAGEFRAME"
		
				FOR EACH OPAGE IN xoObjeto.pages
					FOR EACH objPict IN opage.controls
						This.Dt_EmptyObj(OBJPICT)
						IF _screen.dtoSalir
							RETURN !_Screen.dtosalir
						ENDIF				
					ENDFOR
				ENDFOR
		
			CASE INLIST(UPPER(xoObjeto.BaseClass),"TEXTBOX","EDITBOX","COMBOBOX","LIST","SPINNER")
				IF PEMSTATUS(xoObjeto,"validar_mensajes",5)
					IF EMPTY(xoObjeto.value) AND xoObjeto.validar_mensajes
						MESSAGEBOX("Faltan completar valores")
		
						* Si es un PageFrame, será necesario Activar la Page Correcta
						* de lo contrario el SetFocus quedará oculto.				
						
						IF xoObjeto.parent.baseclass="Page"
							xoObjeto.parent.parent.ActivePage=xoObjeto.parent.PageOrder
					
						ENDIF
						xoObjeto.setfocus
					
						_screen.dtoSalir=.t.
						RETURN !_Screen.dtosalir				
					ENDIF
				ENDIF
		ENDCASE
		RETURN !_Screen.dtosalir
		
		
		
	ENDPROC

	PROCEDURE fonlydigit
		LPARAMETERS xlcCadena
		***********************************
		** Luis María Guayan
		** Devuelve únicamente los números que contiene una cadena
		return CHRTRAN(xlcCadena,CHRTRAN(xlcCadena,"1234567890",""),"")
	ENDPROC

	PROCEDURE foxbinversion
		#DEFINE HISTORIAL_I	'* <HISTORIAL DE CAMBIOS Y NOTAS IMPORTANTES>'
		#DEFINE HISTORIAL_F	'* </HISTORIAL DE CAMBIOS Y NOTAS IMPORTANTES>'
		
		LOCAL lcHistorial, laLinea(1), laHistorial(1,4),objRsp,i,nLines,lnInf,xi
		
		lcHistorial	= STREXTRACT(FILETOSTR('FOXBIN2PRG.PRG') , HISTORIAL_I, HISTORIAL_F )
		
		nLines=ALINES(laLinea, lcHistorial, 1+4+8)
		FOR I = 1 TO nLines
			DIMENSION laHistorial(I,4)
			laHistorial(I,1)	= GETWORDNUM( laLinea(I), 2 )
			laHistorial(I,2)	= GETWORDNUM( laLinea(I), 3 )
			laHistorial(I,3)	= GETWORDNUM( laLinea(I), 4 )
			laHistorial(I,4)	= SUBSTR( laLinea(I), AT(laHistorial(I,3), laLinea(I)) + LEN(laHistorial(I,3)) + 1 )
		
		ENDFOR
		
		lnInf=nLines+5
		objRsp=NEWOBJECT("empty")
		lcProp="gaProp["+TRANSFORM(lnInf)+"]"
		Addproperty(objRsp,lcProp,"")
		objRsp.gaProp[1]="<VERSION>"
		objRsp.gaProp[2]=CHR(9)+"* Módulo.........: FOXBIN2PRG.PRG - PARA VISUAL FOXPRO 9.0"
		objRsp.gaprop[3]=CHR(9)+"* Autor..........: Fernando D. Bozzo (mailto:fdbozzo@gmail.com)"
		objRsp.gaprop[4]=CHR(9)+"* Fecha creación.: 04/11/2013"
		FOR xi=1 TO nLines
			objRsp.gaProp[xi+4]=CHR(9)+'['+laHistorial(xI,1)+']'+'['+laHistorial(xI,2)+']'+'['+laHistorial(xI,3)+']'+'['+laHistorial(xI,4)+']'
		ENDFOR
		objRsp.gaprop[lnInf]="</VERSION>"
		RETURN objRsp
		
	ENDPROC

	PROCEDURE galltags
		LPARAMETERS objInfo
		
		LOCAL lcfile,lcfilew,lcTable,lcFitab,;
			nitems,nit,i,lcvis,lcTag,lcMemb,xi,lcEtiq,;
			lcp,ncp,npas,lcVersion,lcFindVersion,lvFound,;
			lcParent,nco,ncg,lcFileType,lcObjName,;
			objVer,objfun,ldoit,lcSelTag
		
		objfun=NEWOBJECT("prsfun","clases\prssys.vcx")
		nItems=7
		lcSelTag=this.seltag
		STORE 0 TO nco,ncg
		LOCAL ARRAY gaRevi(nItems,3),gaComOri(1,2),gaComGen(1,2)
		gaRevi[1,1]=[PROPERTIES]
		gaRevi[2,1]=[USER_PROPERTIES]
		gaRevi[3,1]=[USER_PROCEDURE]
		gaRevi[4,1]=[NATIVE_PROCEDURE]
		gaRevi[5,1]=[METHODS]
		gaRevi[6,1]=[USER_METHODS]
		gaRevi[7,1]=[COMMENT]
		
		gaRevi[1,2]=[<PROPERTIES>]
		gaRevi[2,2]=[<USER_PROPERTIES>]
		gaRevi[3,2]=[<USER_PROCEDURE>]
		gaRevi[4,2]=[<NATIVE_PROCEDURE>]
		gaRevi[5,2]=[<METHODS>]
		gaRevi[6,2]=[<USER_METHODS>]
		gaRevi[7,2]=[<COMMENT>]
		
		gaRevi[1,3]=[DPROP]
		gaRevi[2,3]=[UPROP]
		gaRevi[3,3]=[UPROC]
		gaRevi[4,3]=[NPROP]
		gaRevi[5,3]=[MET]
		gaRevi[6,3]=[UMET]
		gaRevi[7,3]=[COMEN]
		
		
		lcVersion="FDBOZZO		v"
		lcFindVersion=""
		LOCAL ARRAY gaEncabe(5),gaTema(3),gaTemab(3)
		STORE "" TO gaEncabe,gatema
		
		
		objVer=this.FoxBinVersion()
		
		lcfile=objInfo.fileo
		lcFilew=ObjInfo.filew
		
		lcFileType=""
		nHa=-1
		lnPas=0
		nit=0
		lOpentag=.f.
		lcObjName="class"
		IF getfopen(lcFile,@nha,.F.,12)
			DO WHILE !FEOF(nha)
				lcGet=FGETS(nha,2048)
				lcGetMod=ALLTRIM(CHRTRAN(lcGet,CHR(9),""))
				lnPas=lnPas+1
				
				IF lnPas<3
					LOOP
				ENDIF
				IF LEFT(lcGetMod,9)=="<FORM|C|="
					lcFileType=JUSTEXT(objfun.getValTag(UPPER(lcGet)))
					
				ENDIF		
				IF lcGetMod=="</COMMENT>"
					lOpentag=.f.
					EXIT
				ENDIF	
				IF lcGetMod=="<COMMENT>"
					lOpenTag=.t.
					LOOP
				ENDIF			
				IF lnPas<6
					nit=nit+1
					gaTema[nit]=lcget
				ENDIF
				IF lOPenTag
					IF LEFT(lcgetMod,12)=="<OBJNAME|C|="
						lcObjName=objfun.getValTag(lcGetMod)
					ENDIF
					DO case
						CASE lcFileType=="VCX"
							IF !INLIST(lcGetMOd,"<RESERVED>","</RESERVED>")
								nco=nco+1
								DIMENSION gaComOri(nco,2)
								gaComOri[nco,1]=LcObjName
								gaComOri[nco,2]=lcGet
							ENDIF				
						
						CASE lcFiletype=="SCX"
							nco=nco+1
							DIMENSION gaComOri(nco,2)
							gaComOri[nco,1]="FORM"
							gaComOri[nco,2]=lcGet
						
						
					ENDCASE
					
		
				ENDIF
		
		
			ENDDO
			FCLOSE(nha)
		ENDIF
		
		nHa=-1
		lnPas=0
		nit=0
		lcObjName=""
		IF getfopen(lcFilew,@nha,.F.,12)
			DO WHILE !FEOF(nha)
				lcGet=FGETS(nha,2048)
				lcGetMod=ALLTRIM(CHRTRAN(lcGet,CHR(9),""))
				lnPas=lnPas+1
		
		
				IF lcGetMod=="</COMMENT>"
					lOPenTag=.f.
					EXIT
				ENDIF	
				IF lcGetMod=="<COMMENT>"
					lOpenTag=.t.
					LOOP
				ENDIF			
				IF lnPas<3
					LOOP
				ENDIF
		
				
				IF lnPas<6
					nit=nit+1
					gaTemab[nit]=lcget
				ENDIF
				IF lOPenTag
					DO CASE
						CASE lcFileType=="VCX"
							IF !INLIST(lcGetMOd,"<RESERVED>","</RESERVED>")
								IF LEFT(lcgetMod,12)=="<OBJNAME|C|="
									lcObjName=objfun.getValTag(lcGetMod)
								ENDIF		
								ncg=ncg+1
								DIMENSION gaComGen(ncg,2)
								gaComGen[ncG,1]=LcObjName
								gaComGen[ncG,2]=lcGet
							ENDIF
						CASE lcFileType=="SCX"
						*	IF LEFT(lcgetMod,12)=="<OBJNAME|C|="
						*		lcObjName=objfun.getValTag(lcGetMod)
						*	ENDIF		
							ncg=ncg+1
							DIMENSION gaComGen(ncg,2)
							gaComGen[ncG,1]="FORM"
							gaComGen[ncG,2]=lcGet				
					
					ENDCASE
				ENDIF			
			ENDDO
			FCLOSE(nha)
		ENDIF
		
		
		lcTable=JUSTSTEM(lcFile)
		lcEtiq="i"+IIF(LEN(lcTable)>9,LEFT(lcTable,9),lcTable)
		lcRoot=ADDBS(dserv)
		
		objInfo.NameCur=this.gencursor(lcTable)
		
		
		nit=0
		LOCAL ARRAY galltag(nitems,2)
		FOR i=1 TO nItems
			lcVis=gaRevi[i,1]
			lcTag=gaRevi[i,2]
			lcMemb=gaRevi[i,3]
		
			IF !EMPTY(lcTag)
				nit=nit+1
				galltag[nit,1]=lcTag
				galltag[nit,2]=lcMemb
			ENDIF
		NEXT
		WITH this
			.Fileo=lcFile
			.Filew=lcfilew
		ENDWITH
		
		FOR xi=1 TO ALEN(galltag,1)
		
			WITH this
				.SelTag=galltag[xi,1]
				.tipOut=gallTag[xi,2]
			ENDWITH
			
			
			IF VARTYPE(oMens)="O"
				? "Comparando "+this.seltag+"..."
			ELSE
				WAIT WINDOW "Comparando "+this.seltag+"..." AT 12,20 nowait
			ENDIF
			this.comparetags(.t.,lcTable,lcEtiq)
		NEXT
		IF VARTYPE(oMens)#"O"
			WAIT clear
		ENDIF
		
		
		IF USED(lcTable)
			SELECT (lcTable)
			DO CASE
			CASE lcFileType=="SCX"
				LOCATE FOR TRIM(baseclass)=="FORM" AND TRIM(NAMETAG)=="<COMMENT>"
				IF FOUND()
					LcPut=""
					FOR xi=1 TO nco
						lcPut=lcPut+gaComOri[xi,2]+CHR(13)
					NEXT
					IF !EMPTY(lcPut)
						lcPut=LEFT(lcPut,LEN(lcPut)-1)
					ENDIF
					REPLACE ORIGINAL WITH lcPut,LENORI WITH LEN(LCPUT),;
						LINORI WITH NCO
		
					LcPut=""
					FOR xi=1 TO ncg
						lcPut=lcPut+gaComGen[xi,2]+CHR(13)
					NEXT
					IF !EMPTY(lcPut)
						lcPut=LEFT(lcPut,LEN(lcPut)-1)
					ENDIF
					REPLACE FOXBIN2 WITH lcPut,;
						LENBIN WITH LEN(LCPUT),;
						LINBIN WITH NCG
					REPLACE LENDIF WITH LENORI - LENBIN,;
						LINDIF WITH LINORI - LINBIN
		
				ENDIF
			CASE lcFileType=="VCX"
				LOCAL ARRAY gasuOri(1,2),gasugen(1,2)
				LOCAL gOri,gGen
				STORE 0 TO gori,gGen
				FOR i=1 TO ALEN(gaComOri,1)
					lctik=gacomOri[i,1]
					lcCon=gaComOri[i,2]
					nas=ASCAN(gasuOri,lcTik)
					IF nas=0
						gOri=gOri+1
						DIMENSION gaSuOri[gOri,2]
						gaSuOri[gOri,1]=lcTik
						gaSuOri[gOri,2]=lcCon
					ELSE
						gaSuOri[nas+1]=gaSuOri[nas+1]+CHR(13)+lcCon
					ENDIF
				NEXT
				FOR i=1 TO ALEN(gaComGen,1)
					lctik=gacomGen[i,1]
					lcCon=gaComGen[i,2]
					nas=ASCAN(gasuGen,lcTik)
					IF nas=0
						gGen=gGen+1
						DIMENSION gaSuGen[gGen,2]
						gaSuGen[gGen,1]=lcTik
						gaSuGen[gGen,2]=lcCon
					ELSE
						gaSuGen[nas+1]=gaSuGen[nas+1]+CHR(13)+lcCon
					ENDIF
				NEXT		
				FOR i=1 TO gOri
					LOCATE FOR TRIM(objeto)==UPPER(gaSuOri[i,1]) AND ALLTRIM(nametag)=="<COMMENT>"
					IF FOUND()
						REPLACE ORIGINAL WITH gaSuOri[i,2],;
							lenori WITH LEN(gaSuOri[i,2]),;
							linori WITH ALEN(gaComOri,1)
					ENDIF
					
				NEXT
				FOR i=1 TO ggen
					LOCATE FOR TRIM(objeto)==UPPER(gaSugen[i,1]) AND ALLTRIM(nametag)=="<COMMENT>"
					IF FOUND()
						REPLACE FOXBIN2 WITH gaSuGen[i,2],;
							lenBIN WITH LEN(gaSuGen[i,2]),;
							linBIN WITH ALEN(gaComGen,1)
					ENDIF
					
				NEXT		
				REPLACE LENDIF WITH LENORI - LENBIN,;
					LINDIF WITH LINORI - LINBIN
		
			ENDCASE	
			
		
			
			COUNT FOR lendif#0 TO lnDiflen
			COUNT FOR LINDIF#0 TO lnDiflin
			
			GO top
			IF EMPTY(LnDiflen) AND EMPTY(lnDifLin)
				MESSAGEBOX("That's OK. I couldn't found any difference!")
				fof=ADDBS(_Screen.Dapli)+"entrada\"+JUSTSTEM(lcTable)+"_Ok.txt"
				nha=FCREATE(fof)
				ObjInfo.filetext=fof		
				=FPUTS(nha,"<FOXBIN2PRG>")
				IF !ISNULL(objVer)
					FOR i=1 TO ALEN(objVer.gaprop)
						=FPUTS(nHa,CHR(9)+objVer.gaprop[i])
					NEXT
				ENDIF
				=FPUTS(nha,"</FOXBIN2PRG>")	
				=FPUTS(nha,"<ANALIZE>")
				=FPUTS(nha,CHR(9)+"<ORIGINAL>")
				FOR i=1 TO ALEN(gaTema)
					=FPUTS(nha,REPLICATE(CHR(9),2)+gaTema[i])
				NEXT
				=FPUTS(nha,CHR(9)+"</ORIGINAL>")
				=FPUTS(nha,CHR(9)+"<FOXBIN2>")
				FOR i=1 TO ALEN(gaTemaB)
					=FPUTS(nha,REPLICATE(CHR(9),2)+gaTemaB[i])
				NEXT
				=FPUTS(nha,CHR(9)+"</FOXBIN2>")		
				=FPUTS(nha,CHR(9)+"<REFERENCE>")		
				=FPUTS(nha,objFun.PutTag("DIFER:ORI_BIN","Existe en Original * No existe en FoxBin2prg",2))
				=FPUTS(nha,objFun.PutTag("DIFER:BIN_ORI","Existe en FoxBin2prg * No existe en original",2))
				=FPUTS(nha,CHR(9)+"</REFERENCE>")
				=FPUTS(nha,objFun.PutTag("RESULT","OK",1))		
				=FPUTS(nha,"</ANALIZE>")		
				=FCLOSE(nha)		
			ELSE
		
				fof=ADDBS(_Screen.Dapli)+"entrada\"+JUSTSTEM(lcTable)+"_dif.txt"
				ObjInfo.filetext=fof
		
				nha=FCREATE(fof)
				=FPUTS(nha,"<FOXBIN2PRG>")
				IF !ISNULL(objVer)
					FOR i=1 TO ALEN(objVer.gaprop)
						=FPUTS(nHa,CHR(9)+objVer.gaprop[i])
					NEXT
				ENDIF
				=FPUTS(nha,"</FOXBIN2PRG>")		
		
				=FPUTS(nha,"<ANALIZE>")
				=FPUTS(nha,CHR(9)+"<ORIGINAL>")
				FOR i=1 TO ALEN(gaTema)
					=FPUTS(nha,REPLICATE(CHR(9),2)+gaTema[i])
				NEXT
				=FPUTS(nha,CHR(9)+"</ORIGINAL>")
				=FPUTS(nha,CHR(9)+"<FOXBIN2>")
				FOR i=1 TO ALEN(gaTemaB)
					=FPUTS(nha,REPLICATE(CHR(9),2)+gaTemaB[i])
				NEXT
				=FPUTS(nha,CHR(9)+"</FOXBIN2>")		
				
				=FPUTS(nha,CHR(9)+"<REFERENCE>")		
				=FPUTS(nha,objFun.PutTag("DIFER:ORI_BIN","Existe en Original * No existe en FoxBin2prg",2))
				=FPUTS(nha,objFun.PutTag("DIFER:BIN_ORI","Existe en FoxBin2prg * No existe en original",2))
				=FPUTS(nha,CHR(9)+"</REFERENCE>")
				=FPUTS(nha,objFun.PutTag("RESULT","BAD",1))		
				SCAN
					IF lendif#0 OR lindif#0
						lcObjeto=TRIM(objeto)
						lcparent=TRIM(Parent)
						lcBaseClass=TRIM(baseclass)
						lcNametag=STREXTRACT(TRIM(nametag),"<",">")
						lnLinOri=ALINES(gaOri,original)
						LnLinBin=ALINES(gabin,FoxBin2)
						
						DIMENSION gaOriDif(1),gaBinDif(1)
						STORE 0 TO no,nb
						FOR i=1 TO lnLinOri
							lcLin=gaOri[i]
							IF ASCAN(gabin,lcLin)=0
								no=no+1
								DIMENSION gaOriDif(no)
								gaOriDif[no]=lcLin
							ENDIF
						NEXT
						
						FOR i=1 TO lnLinBin
							lcLin=gaBin[i]
							IF ASCAN(gaOri,lcLin)=0
								nb=nb+1
								DIMENSION gaBinDif(nb)
								gaBinDif[nb]=lcLin
							ENDIF
						NEXT
						
		*				lcOrigi=original
		*				lcFoxbin=Foxbin2
						=FPUTS(nha,CHR(9)+"<DIFIERE>")
						* objFun.PutTag(xcClave,xcValor,xnLevel,xlNotype,xcSep1,xcSep2)
						=FPUTS(nha,objFun.PutTag("OBJNAME",lcObjeto,2))
						=FPUTS(nha,objFun.PutTag("BASECLASS",lcBaseClass,2))
						=FPUTS(nha,objFun.PutTag("PARENT",lcParent,2))
						=FPUTS(nha,objFun.PutTag("TAG",lcNameTag,2))
						
						=FPUTS(nha,REPLICATE(CHR(9),2)+"<ORIGINAL>")
						FOR i=1 TO lnLinOri
							=FPUTS(nha,REPLICATE(CHR(9),3)+gaOri[i])
						NEXT
						=FPUTS(nha,REPLICATE(CHR(9),2)+"</ORIGINAL>")
						
						=FPUTS(nha,REPLICATE(CHR(9),2)+"<FOXBIN2>")
						FOR i=1 TO lnLinBin
							=FPUTS(nha,REPLICATE(CHR(9),3)+gaBin[i])
						NEXT
						=FPUTS(nha,REPLICATE(CHR(9),2)+"</FOXBIN2>")
						
						IF NO#0
							=FPUTS(nha,REPLICATE(CHR(9),2)+"<DIFER:ORI_BIN>")
							FOR i=1 TO no
								=FPUTS(nha,REPLICATE(CHR(9),3)+gaOriDif[i])
							NEXT
							=FPUTS(nha,REPLICATE(CHR(9),2)+"</DIFER:ORI_BIN>")
						ENDIF
						IF Nb#0
							=FPUTS(nha,REPLICATE(CHR(9),2)+"<DIFER:BIN_ORI>")
							FOR i=1 TO nb
								=FPUTS(nha,REPLICATE(CHR(9),3)+gaBinDif[i])
							NEXT
							=FPUTS(nha,REPLICATE(CHR(9),2)+"</DIFER:BIN_ORI>")
						ENDIF				
														
						=FPUTS(nha,CHR(9)+"</DIFIERE>")
					ENDIF
					
				ENDSCAN
				=FPUTS(nha,"</ANALIZE>")
				=FCLOSE(NHA)
				GO TOP
				
				MESSAGEBOX("Proceso con diferencias detectadas",0,_screen.th_mensaje)
			ENDIF
				
		*	BROWSE
			
			USE
		ENDIF
		objVer=null
		objFun=null
	ENDPROC

	PROCEDURE gencursor
		LPARAMETERS xcTabla
		LOCAL lcEtiq,lcFitab
		IF USED(xcTabla)
			SELECT (xcTabla)
			USE
		ENDIF
		LcFitab=ADDBS(dserv)+xcTabla
		lcEtiq="i"+IIF(LEN(xcTAbla)>9,LEFT(xcTabla,9),xcTabla)
		CREATE TABLE &lcFitab FREE ;
			("OBJETO" C(30),;
			"BASECLASS" C(20),;
			"PARENT" C(60),;
			"NAMETAG" C(30),;
			"ORIGINAL" M,;
			"FOXBIN2" M,;
			"LENORI" I,;
			"LENBIN" I,;
			"LENDIF" I,;
			"COMPARA" L,;
			"LINORI" I,;
			"LINBIN" I,;
			"LINDIF" I)
		SELECT (xcTabla)
		INDEX on TRIM(parent)+TRIM(objeto)+nametag TAG &lcEtiq
		RETURN ADDBS(dserv)+xcTabla+".dbf"
		
	ENDPROC

	PROCEDURE getbackup
		LPARAMETERS xcFile,xcFolderBack
		LOCAL nHand,lcFile,lcGet,lnTags,lcType,lcKey,;
			LcPath,lcCopy,fsObj,lnErr,lnCount,i,j,lnExito,;
			lnSeconds,lnTime,lRead,lcProy,lcOmite,ObPRS,DBFILE,;
			lcParser,lcParserDest
		
		LOCAL ARRAY gatags(1),gatError(1)
		STORE 0 TO lnErr,lnCount,lnExito
		lnSeconds=SECONDS()
		obPrs=NEWOBJECT("prsfun","clases\prssys.vcx")
		
		LOCAL loCnv AS c_foxbin2prg OF "FOXBIN2PRG.PRG"
		loCnv = NEWOBJECT("c_foxbin2prg",ADDBS(_Screen.dprog)+"FOXBIN2PRG.PRG")
		*loCnv.Ejecutar( xcFile )
		
		* Ruta de Backup Provisoria para Pruebas
		IF EMPTY(xcFolderBack)
			lcRoot=ADDBS(_Screen.Dapli)+"Backup1"
		ELSE
			lcRoot=xcFolderBack
		ENDIF
		
		IF !DIRECTORY(lcRoot)
			MD &lcRoot
		ENDIF
		
		fsObj=CreateObject('Scripting.FileSystemObject')
		IF VARTYPE(fsObj)#"O"
			MESSAGEBOX("No se pudo crear el objeto Scripting",0,_screen.th_mensaje)
			RETURN
		ENDIF
		
		nHand=-1
		IF !obPrs.getfopen(xcFile,@nHand,.f.,12)
			RETURN
		ENDIF
		*<Type|C|=K/>
		*<Name|C|=c:\theocont\forms\acticlien.scx/>
		*<Key|C|=ACTICLIEN/>
		RELEASE mensajero
		PUBLIC mensajero
		Mensajero=this.mensajero("Backup foxBin2")
		
		lRead=.f.
		LcOmite="\archivos de programa\microsoft visual foxpro"
		DO WHILE !FEOF(nHand)
			lcGet=CHRTRAN(FGETS(nhand,2048),CHR(9),"")
			IF LOWER(LEFT(lcGet,LEN("<proyecto|c|=")))=="<proyecto|c|="
				LcProy=obPrs.GetValTag(lcGet)
				*DO foxbin2prg WITH lcProy
				loCnv.Ejecutar(lcProy)
			ENDIF
			
			IF lcGet=="<REG>"
				lRead=.t.
				LOOP
			ENDIF
			IF lcGet=="</REG>"
				LREAD=.F.
				EXIT
			ENDIF
		
			
			IF lREad
				lnTags=ALINES(gaTags,lcGet,16,"/>")
				lcType=obPrs.GetValTag(gaTags[1])
				lcFile=obPrs.GetValTag(gaTAgs[2])
				
				IF AT(lcOmite,LOWER(lcFile))#0
					* Archivo de sistema
					LOOP
				ENDIF		
				
				lcKey=obprs.GetValTag(gaTAgs[3])
				lnCount=lnCount+1
		
				nl=ALINES(gapath,JUSTPATH(lcfile),1,"\")
				lcPath=ADDBS(lcRoot)
				FOR ix=2 TO nl
					lcPath=lcPath+ADDBS(gapath[ix])
				NEXT
				IF RIGHT(lcPath,1)="\"
					lcPath=LEFT(lcPath,LEN(lcPath)-1)
				ENDIF
				IF !DIRECTORY(lcPath)
					MD &lcpath
				ENDIF
			
				DO case
		
					CASE INLIST(lctype,"K","V","R","M")
						IF LcType="M"
							lcParser=ADDBS(_Screen.dtemp)+JUSTSTEM(lcFile)+".txt"
							lcCopy=LOWER(FORCEEXT(lcfile,"mpr"))
							? " Copiando archivo &lcCopy..."
							FSObj.CopyFile(lcCopy,ADDBS(lcPath))
						
							this.ParserMnu(lcFile+"<N>",1)
							IF FILE(lcParser)
								fsObj.copyFile(lcParser,ADDBS(lcPath))
							ENDIF				
						
						
						ENDIF
						
						lcOld_Err=lcFile+".err"
						IF FILE(lcOld_Err)
							fsObj.DeleteFile(lcOld_err)
						ENDIF
			
						? " Generando Foxbin2 para &lcFile..."
		
						loCnv.Ejecutar(lcFile)
						lDoit=.t.
						IF FILE(lcOld_Err)
							lnErr=lnErr+1
							DIMENSION gatError(lnErr)
							gatError[lnErr]=lcfile
							lDoit=.f.
						ENDIF
			
						IF ldoit
							DO case
								CASE lctype="V"
									lcCopy=FORCEEXT(lcfile,"vc2")
								CASE lcType="K"
									LcCopy=FORCEEXT(lcFile,"sc2")
								CASE lctype="R"
									lcCopy=FORCEEXT(lcFile,"fr2")
								CASE lctype="M"
									lcCopy=FORCEEXT(lcFile,"mn2")
							ENDCASE
							lcCopy=LOWER(lcCopy)
							IF FILE(lcCopy)
								TRY
									LOCAL loEx AS EXCEPTION
									FSObj.CopyFile(lcCopy,ADDBS(lcPath))
								*	lcTarget=ADDBS(lcPath)+LOWER(JUSTFNAME(lcCopy))
								*	COPY FILE &lcCopy TO &lcTarget
								CATCH TO loEx
									cr_lf=CHR(10)+CHR(13)
									This.writeError( 'ERROR: ' + TRANSFORM(loEx.ERRORNO) + ', ' + loEx.MESSAGE + CR_LF ;
										+ loEx.PROCEDURE + ', line ' + TRANSFORM(loEx.LINENO) + CR_LF ;
										+ loEx.DETAILS )
				
								FINALLY
									fsObj.DeleteFile(lcCopy)
									lnExito=lnExito + 1
								ENDTRY
							ENDIF
						ENDIF
					CASE INLIST(LCTYPE,"I","x","T","P")
						? "Copiando &lcFile a &lcPath..."
						fsobj.CopyFile(lcFile,ADDBS(lcPath))
					CASE LCTYPE="D"
						* Prs?
						? " Generando prsfile de "+lcFile+"..."
						dbFile=JUSTSTEM(lcfile)
						USE (lcFile) IN 0 SHARED
						*LPARAMETERS xcTextFile,xgapas,xcProceso,xcProcId,xcClaveId
						*GAPAS[1]="MOVIM|*|FECHA BETWEEN DIA1 AND DIA2"
						LOCAL ARRAY gaWhere(1)
						gaWhere[1]=dbfile+"|*|.t."
						obPrs.genPrs(ADDBS(lcPath)+dbFile,@gaWhere,"FOXBIN")
						IF USED(dbFile)
							SELECT (dbFile)
							USE
						ENDIF
						
						*oprs.genprs(,"MOVIM|*|.T.")
					OTHERWISE
						* H,  M
				ENDCASE
			endif
		ENDDO
		=FCLOSE(nHand)
		obPrs=null
		
		IF !EMPTY(lcProy)
			nl=ALINES(gapath,JUSTPATH(lcproy),1,"\")
			lcPath=ADDBS(lcRoot)
			FOR ix=2 TO nl
				lcPath=lcPath+ADDBS(gapath[ix])
			NEXT
			IF RIGHT(lcPath,1)="\"
				lcPath=LEFT(lcPath,LEN(lcPath)-1)
			ENDIF
			IF !DIRECTORY(lcPath)
				MD &lcpath
			ENDIF
			
			FSObj.CopyFile(xcfile,ADDBS(lcpath))
			lcGen=FORCEEXT(lcProy,"pj2")
			IF FILE(LCGEN)
				fsObj.copyfile(lcGen,ADDBS(lcPath))
				fsObj.DeleteFile(lcGen)
			ENDIF
			
		ENDIF
		
		STORE null TO fsObj,obPrs,loCnv
		RELEASE mensajero,fsObj,obPrs
		IF lnErr#0
			lcMens=""
			FOR i=1 TO lnErr
				lcMens=lcMens+gatError[i]+CHR(13)
			NEXT
			lcMens=LEFT(lcMens,LEN(lcMens)-1)
			MESSAGEBOX("Se han producido "+TRANSFORM(lnErr)+" errores en "+TRANSFORM(lnCount)+" archivos."+CHR(13);
				+lcMens,0,_screen.th_mensaje)
		ELSE
			lnTime=SECONDS()-lnSeconds
			MESSAGEBOX("Carpeta de Backup: "+LOWER(xcFolderback)+CHR(13);
				+TRANSFORM(lnCount)+" archivos procesados"+CHR(13);
				+TRANSFORM(lnExito)+" procesos cumplidos"+CHR(13);
				+"No se detectaron problemas."+CHR(13);
				+"Tiempo="+TRANSFORM(lnTime),0,_screen.th_mensaje)
		ENDIF
			
		
	ENDPROC

	PROCEDURE getfoxbin1
		LPARAMETERS xcFile
		
		LOCAL lcOrex,lcExten,lcFileGen,lcFileCopy1,lcFileCopy2,;
			lcParser,lcParserDest
		
		LOCAL loCnv AS c_foxbin2prg OF "FOXBIN2PRG.PRG"
		loCnv = NEWOBJECT("c_foxbin2prg",ADDBS(_Screen.dprog)+"FOXBIN2PRG.PRG")
		*loCnv.Ejecutar( xcFile )
		
		lcOrex=UPPER(JUSTEXT(xcFile))
		
		lcExten=""
		DO case
			CASE lcOrex="SCX"
				lcExten="SC2"
			CASE lcOrex="VCX"
				lcExten="VC2"
			CASE lcOrex="PJX"
				LcExten="PJ2"
			CASE lcOrex="MNX"
				lcExten="MN2"
			CASE lcOrex="DBF"
				lcExten="DB2"
			CASE lcOrex="DBC"
				lcExten="DC2"
			OTHERWISE
				RETURN ""
		ENDCASE
		
		
		lcFileGen=FORCEEXT(xcFile,lcExten)
		IF FILE(lcFilegen)
			DELETE FILE &lcFilegen
		ENDIF
		lcFileCopy1=ADDBS(_Screen.Dapli)+"Entrada\"+JUSTFNAME(lcfileGen)
		lcFileCopy2=ADDBS(_Screen.Dapli)+"Entrada\"+JUSTSTEM(xcFile)+"_Ori."+JUSTEXT(lcfileGen)
		lcParser=ADDBS(_Screen.dtemp)+JUSTSTEM(xcFile)+".txt"
		lcParserDest=ADDBS(_Screen.Dapli)+"Entrada\"+JUSTFNAME(lcParser)
		*DO foxbin2prg WITH xcFile
		
		loCnv.Ejecutar( xcFile )
		loCnv=null
		
		IF FILE(LCFILEGEN)
			COPY FILE &lcFileGen TO &lcFileCopy1
			COPY FILE &lcFilegen TO &lcFileCopy2
		ENDIF
		
		
		DO case
			CASE lcOrex="SCX"
				this.ParserForm(xcFile+"<N>",.t.)
				IF FILE(lcParser)
					COPY FILE &lcParser TO &lcParserDest
				ENDIF
				
			CASE lcOrex="VCX"
				this.ParserVcx(xcFile+"<N>",.t.)
		
				IF FILE(lcParser)
					COPY FILE &lcParser TO &lcParserDest
				ENDIF	
			CASE lcOrex="MNX"
				this.parsermnu(xcfile+"<N>",1)
				IF FILE(lcParser)
					COPY FILE &lcParser TO &lcParserDest
				ENDIF			
		ENDCASE
		*RELEASE obj
		*MESSAGEBOX("Retorna="+lcFilegen)
		RETURN lcFileGen
		
	ENDPROC

	PROCEDURE getfoxbin2
		LPARAMETERS xcFile
		LOCAL lcRoot,lcFilegen,lcOrex,lcExten
		
		LOCAL loCnv AS c_foxbin2prg OF "FOXBIN2PRG.PRG"
		loCnv = NEWOBJECT("c_foxbin2prg",ADDBS(_Screen.dprog)+"FOXBIN2PRG.PRG")
		*loCnv.Ejecutar( xcFile )
		
		lcRoot=ADDBS(_Screen.Dapli)+"Entrada"
		
		
		lcOrex=UPPER(JUSTEXT(xcFile))
		lcExten=""
		DO case
			CASE lcOrex="SC2"
				lcExten="SCX"
				
			CASE lcOrex="VC2"
				lcExten="VCX"
				
			CASE lcOrex="PJ2"
				LcExten="PJX"
				
			CASE lcOrex="MN2"
				lcExten="MNX"
				
			CASE lcOrex="DB2"
				lcExten="DBF"
				
			CASE lcOrex="DC2"
				lcExten="DBC"
			OTHERWISE
				RETURN ""
		ENDCASE
		lcFilegen=FORCEEXT(xcFile,lcExten)
		
		* MESSAGEBOX(xcFile+" "+TRANSFORM(FILE(xcFile)))
		
		
		*DO foxbin2prg WITH xcFile
		loCnv.Ejecutar( xcFile )
		LoCnv=null
		
		IF FILE(lcFilegen)
			
		
			lcParser=ADDBS(_Screen.dtemp)+JUSTSTEM(xcFile)+".txt"
			lcParserDest=ADDBS(lcRoot)+JUSTSTEM(lcParser)+"_new.txt"
		
		
		
			DO case
				CASE lcOrex="SC2"
					this.ParserForm(lcFilegen+"<N>",.t.)
					IF FILE(lcParser)
						COPY FILE &lcParser TO &lcParserDest
					ENDIF
				
				CASE lcOrex="VC2"
					this.ParserVcx(lcFilegen+"<N>",.t.)
		
					IF FILE(lcParser)
						COPY FILE &lcParser TO &lcParserDest
					ENDIF
				CASE LCOREX="MN2"
					this.parsermnu(lcFilegen+"<N>",2)	
					IF FILE(lcParser)
						COPY FILE &lcParser TO &lcParserDest
					ENDIF			
							
			ENDCASE
		
		ENDIF
		RETURN lcFilegen
		
	ENDPROC

	PROCEDURE getfoxbinrep
		LPARAMETERS xcFile
		LOCAL lcOrex,lcExten,lcFileGen,lcFileCopy1,lcFileCopy2,;
			nfas,lnOri,lnNew,lnRecOri,lnRecnew,;
			i,lnREc,fcr,lcQuit,lcEol,LcRegistro,;
			lnbOri,lnbNew,gb,lnLenOri,lnLenNew,ji,si,xi,nres,objfun
		
		LOCAL loCnv AS c_foxbin2prg OF "FOXBIN2PRG.PRG"
		loCnv = NEWOBJECT("c_foxbin2prg",ADDBS(_Screen.dprog)+"FOXBIN2PRG.PRG")
		*loCnv.Ejecutar( xcFile )
		objfun=NEWOBJECT("prsfun","clases\prssys.vcx")
		
		lcQuit=CHR(9)+CHR(10)+CHR(13)
		lcEol=CHR(10)+CHR(13)
		lcOrex=JUSTEXT(xcFile)
		lcExten=""
		DO case
			CASE lcOrex="FRX"
				lcExten="FR2"
		
			OTHERWISE
				RETURN
		ENDCASE
		
		USE (xcfile) IN 0 ALIAS original
		SELECT original
		REPLACE ALL UNIQUEID WITH SYS(2015) FOR EMPTY(UNIQUEID)
		GO top
		USE
		
		lcFileGen=FORCEEXT(xcFile,lcExten)
		IF FILE(lcFilegen)
			DELETE FILE &lcFilegen
		ENDIF
		
		lcFileCopy1=ADDBS(_Screen.Dapli)+"Entrada\"+JUSTFNAME(lcfileGen)
		lcFileCopy2=ADDBS(_Screen.Dapli)+"Entrada\"+JUSTSTEM(xcFile)+"_Ori."+JUSTEXT(lcfileGen)
		*lcParser=ADDBS(_Screen.dtemp)+JUSTSTEM(xcFile)+".txt"
		*lcParserDest=ADDBS(_Screen.Dapli)+"Entrada\"+JUSTFNAME(lcParser)
		*DO foxbin2prg WITH xcFile
		loCnv.Ejecutar( xcFile )
		
		
		IF FILE(LCFILEGEN)
			COPY FILE &lcFileGen TO &lcFileCopy1
			COPY FILE &lcFilegen TO &lcFileCopy2
		ENDIF
		
		*DO foxbin2prg WITH lcFilecopy1	&& regenera el reporte en "\Entrada\"
		loCnv.Ejecutar( lcFileCopy1 )
		lcx=ADDBS(_Screen.Dapli)+"Entrada\"+JUSTFNAME(xcFile)
		lcm=ADDBS(_Screen.Dapli)+"Entrada\"+JUSTSTEM(xcfile)+".FRT"
		
		lcdx=ADDBS(JUSTPATH(lcx))+JUSTSTEM(lcx)+"_new."+JUSTEXT(lcx)
		lcdm=ADDBS(JUSTPATH(lcm))+JUSTSTEM(lcm)+"_new."+JUSTEXT(lcm)
		COPY file &lcx TO &lcdx
		COPY file &lcm TO &lcdm
		
		USE (xcfile) IN 0 ALIAS original
		USE (lcdx) IN 0 ALIAS nuevo
		fcr=ADDBS(_Screen.Dapli)+"entrada\"+JUSTSTEM(xcfile)+"_dif.txt"
		nfas=FCREATE(fcr)
		
		fcr=ADDBS(_Screen.Dapli)+"entrada\"+JUSTSTEM(xcfile)+"_difres.txt"
		nres=FCREATE(fcr)
		
		LOCAL ARRAY gabind(1),gaResdif(1)
		
		lnOri=FCOUNT("original")
		lnNew=FCOUNT("nuevo")
		lnRecOri=RECCOUNT("original")
		lnRecNew=RECCOUNT("Nuevo")
		=FPUTS(nfas,objFun.PutTag("REPORT",xcfile))
		=FPUTS(nfas,objFun.PutTag("GENERADO",LCX))
		=FPUTS(nfas,objFun.PutTag("RENAME",LCDX))
		=FPUTS(NFAS,objFun.PutTag("Campos_original",lnOri))
		=FPUTS(nfas,objFun.PutTag("Campos_foxbin2",lnNew))
		=FPUTS(NFAS,objFun.PutTag("Records_original",lnRecOri))
		=FPUTS(nfas,objFun.PutTag("Records_foxbin2",lnRecNew))
		
		=FPUTS(nREs,objFun.PutTag("REPORT",xcfile))
		=FPUTS(nREs,objFun.PutTag("GENERADO",LCX))
		=FPUTS(nREs,objFun.PutTag("RENAME",LCDX))
		=FPUTS(nREs,objFun.PutTag("Campos_original",lnOri))
		=FPUTS(nREs,objFun.PutTag("Campos_foxbin2",lnNew))
		=FPUTS(nREs,objFun.PutTag("Records_original",lnRecOri))
		=FPUTS(nREs,objFun.PutTag("Records_foxbin2",lnRecNew))
		=FPUTS(nres," ")
		SET EXACT ON
		
		SELECT original
		SCAN
			ndif=0
			lnRec=RECNO()
			lnObjType=objType
			lcUniqueid=ALLTRIM(uniqueid)	
			lcMet="UniqueId"
			DIMENSION gaVeri(lnOri,3)
			FOR i=1 TO lnOri
				lcCampo=FIELD(i)
				gaVeri[i,1]=lcCampo
				gaVeri[i,2]=EVALUATE(lcCampo)
				gaVeri[i,3]=""
				
			NEXT
			SELECT nuevo
			LOCATE FOR ALLTRIM(uniqueid)==lcUniqueId
			IF !FOUND()
				lcMet="Recno"
				GO lnrec
			ENDIF
			
			FOR i=1 TO lnOri
				lcCampo=FIELD(i)
				IF allTRIM(lcCampo)==gaVeri[i,1]
					gaVeri[i,3]=EVALUATE(lcCampo)
				ENDIF
			NEXT
			lcRegistro="REGISTRO_"+TRANSFORM(lnRec)
			=FPUTS(nfas,"<"+LcRegistro+">")
			=FPUTS(nfas,CHR(9)+objFun.PutTag("Busqueda",lcMet))
			FOR i=1 TO ALEN(gaVeri,1)
				=FPUTS(nfas,REPLICATE(CHR(9),1)+"<"+gaVeri[i,1]+">")
				DO case
					CASE LOWER(gaVeri[i,1])=="expr"
						nExpr_Ori=ALINES(gaPutOri,gaVeri[i,2])
						nExpr_New=ALINES(gaPutNew,gaVeri[i,3])
						=FPUTS(nfas,REPLICATE(CHR(9),2)+"<Ori>")
						FOR xi=1 TO nExpr_Ori
							=FPUTS(nfas,REPLICATE(CHR(9),3)+gaPutOri[xi])
						NEXT
						=FPUTS(nfas,REPLICATE(CHR(9),2)+"</Ori>")
						
						=FPUTS(nfas,REPLICATE(CHR(9),2)+"<New>")
						FOR xi=1 TO nExpr_New
							=FPUTS(nfas,REPLICATE(CHR(9),3)+gaPutNew[xi])
						NEXT				
						=FPUTS(nfas,REPLICATE(CHR(9),2)+"</New>")				
						ldif=.f.
						FOR xi=1 TO ALEN(gaPutnew)
							IF ASCAN(gaPutOri,gaPutnew[xi])=0
								ldif=.t.
								EXIT
							ENDIF
						NEXT
						IF ldif
							ASORT(gaputOri)
							ASORT(gaputNew)
							nDif=nDif+1
							DIMENSION gaREsDif(ndif)
							gaResDif[ndif]=REPLICATE(CHR(9),1)+"<"+gaVeri[i,1]+">"
			
							FOR xi=1 TO ALEN(gaPutnew)
								IF gaPutOri[xi]#gaputNew[xi]
									nDif=nDif+1
									DIMENSION gaREsDif(ndif)
									gaResDif[ndif]=REPLICATE(CHR(9),2)+objFun.PutTag("Ori",gaPutOri[xi])
		
									nDif=nDif+1
									DIMENSION gaREsDif(ndif)
									gaREsDif[ndif]=REPLICATE(CHR(9),2)+objFun.PutTag("New",gaPutNew[xi])
								ENDIF
							NEXT
							nDif=nDif+1
							DIMENSION gaREsDif(ndif)
							gaResDif[ndif]=REPLICATE(CHR(9),1)+"</"+gaVeri[i,1]+">"					
		
						ENDIF
						
					CASE LOWER(gaVeri[i,1])=="style"
						nVfpData2=OCCURS("<VFPData>",gaveri[i,2])
						nVfpData3=OCCURS("<VFPData>",gaveri[i,3])
						FOR xi=2 TO 3
							gaveri[i,xi]=STRTRAN(gaveri[i,xi],"<VFPData>","")
							gaveri[i,xi]=STRTRAN(gaveri[i,xi],"</VFPData>","")
						NEXT
									
						nExpr_Ori=ALINES(gaPutOri,gaVeri[i,2],16,"/>")
						nExpr_New=ALINES(gaPutNew,gaVeri[i,3],16,"/>")
						FOR xi=1 TO nExpr_ori
							gaPutOri[xi]=CHRTRAN(gaputOri[xi],lcQuit,"")
						NEXT
						FOR xi=1 TO nExpr_New
							gaPutNew[xi]=CHRTRAN(gaputNew[xi],lcQuit,"")
						NEXT				
						=FPUTS(nfas,REPLICATE(CHR(9),2)+"<Ori>")
						IF nvFpData2#0
							=FPUTS(nfas,REPLICATE(CHR(9),3)+"<VFPData>")
						ENDIF				
						FOR xi=1 TO nExpr_Ori
							=FPUTS(nfas,REPLICATE(CHR(9),3)+gaPutOri[xi])
						NEXT
						IF nvFpData2#0
							=FPUTS(nfas,REPLICATE(CHR(9),3)+"</VFPData>")
						ENDIF				
						=FPUTS(nfas,REPLICATE(CHR(9),2)+"</Ori>")
						
						=FPUTS(nfas,REPLICATE(CHR(9),2)+"<New>")
						IF nvFpData3#0
							=FPUTS(nfas,REPLICATE(CHR(9),3)+"<VFPData>")
						ENDIF				
						FOR xi=1 TO nExpr_New
							=FPUTS(nfas,REPLICATE(CHR(9),3)+gaPutNew[xi])
						NEXT	
						IF nvFpData3#0
							=FPUTS(nfas,REPLICATE(CHR(9),3)+"</VFPData>")
						ENDIF							
						=FPUTS(nfas,REPLICATE(CHR(9),2)+"</New>")				
		
						ldif=.f.
						FOR xi=1 TO ALEN(gaPutnew)
							IF ASCAN(gaPutOri,gaPutnew[xi])=0
								ldif=.t.
								EXIT
							ENDIF
						NEXT
						IF ldif
						*	ASORT(gaputOri)
						*	ASORT(gaputNew)
							nDif=nDif+1
							DIMENSION gaREsDif(ndif)
							gaResDif[ndif]=REPLICATE(CHR(9),1)+"<"+gaVeri[i,1]+">"
							IF nvFpData2#0
								nDif=nDif+1
								DIMENSION gaResDif(ndif)
								gaResDif[ndif]=REPLICATE(CHR(9),3)+"<VFPData>"
							ENDIF	
							FOR xi=1 TO ALEN(gaPutnew)
								IF gaPutOri[xi]#gaputNew[xi]
									nDif=nDif+1
									DIMENSION gaREsDif(ndif)
									gaResDif[ndif]=REPLICATE(CHR(9),2)+"<Ori>"
									nDif=nDif+1
									DIMENSION gaREsDif(ndif)							
									gaResDif[ndif]=REPLICATE(CHR(9),3)+gaPutOri[xi]
									nDif=nDif+1
									DIMENSION gaREsDif(ndif)
									gaResDif[ndif]=REPLICATE(CHR(9),2)+"</Ori>"
									
									nDif=nDif+1
									DIMENSION gaREsDif(ndif)
									gaResDif[ndif]=REPLICATE(CHR(9),2)+"<New>"							
									
									nDif=nDif+1
									DIMENSION gaREsDif(ndif)
									gaREsDif[ndif]=REPLICATE(CHR(9),3)+gaPutNew[xi]
									nDif=nDif+1
									DIMENSION gaREsDif(ndif)
									gaResDif[ndif]=REPLICATE(CHR(9),2)+"</New>"								
									
								ENDIF
							NEXT
							IF nvFpData2#0
								nDif=nDif+1
								DIMENSION gaResDif(ndif)
								gaResDif[ndif]=REPLICATE(CHR(9),3)+"</VFPData>"
							ENDIF					
							nDif=nDif+1
							DIMENSION gaREsDif(ndif)
							gaResDif[ndif]=REPLICATE(CHR(9),1)+"</"+gaVeri[i,1]+">"					
		
						ENDIF
		
					CASE LOWER(gaVeri[i,1])=="tag"
		
					*	nExpr_Ori=ALINES(gaPutOri,gaVeri[i,2],16,"/>")
					*	nExpr_New=ALINES(gaPutNew,gaVeri[i,3],16,"/>")
					
						nExpr_Ori=ALINES(gaPutOri,gaVeri[i,2])
						nExpr_New=ALINES(gaPutNew,gaVeri[i,3])			
						=FPUTS(nfas,REPLICATE(CHR(9),2)+"<Ori>")
						
						
						FOR xi=1 TO nExpr_Ori
							=FPUTS(nfas,REPLICATE(CHR(9),3)+gaPutOri[xi])
						NEXT					
							
						=FPUTS(nfas,REPLICATE(CHR(9),2)+"</Ori>")
						
						=FPUTS(nfas,REPLICATE(CHR(9),2)+"<New>")
							
						FOR xi=1 TO nExpr_New
							=FPUTS(nfas,REPLICATE(CHR(9),3)+gaPutNew[xi])
						NEXT		
								
						=FPUTS(nfas,REPLICATE(CHR(9),2)+"</New>")	
						
						ldif=.f.
						FOR xi=1 TO nExpr_ori
							gaPutOri[xi]=ALLTRIM(CHRTRAN(gaputOri[xi],CHR(9),""))
						NEXT
						FOR xi=1 TO nExpr_New
							gaPutNew[xi]=ALLTRIM(CHRTRAN(gaputNew[xi],CHR(9),""))
						NEXT				
						
						FOR xi=1 TO ALEN(gaPutnew)
							IF ASCAN(gaPutOri,gaPutnew[xi])=0
								ldif=.t.
								EXIT
							ENDIF
						NEXT
						IF ldif
		
							nDif=nDif+1
							DIMENSION gaREsDif(ndif)
							gaResDif[ndif]=REPLICATE(CHR(9),1)+"<"+gaVeri[i,1]+">"
							
							
			
							FOR xi=1 TO ALEN(gaPutnew)
								IF gaPutOri[xi]#gaputNew[xi]
									nDif=nDif+1
									DIMENSION gaREsDif(ndif)
									gaResDif[ndif]=REPLICATE(CHR(9),2)+"<Ori>"
															
									nDif=nDif+1
									DIMENSION gaREsDif(ndif)
									gaResDif[ndif]=REPLICATE(CHR(9),2)+gaPutOri[xi]
		
									nDif=nDif+1
									DIMENSION gaREsDif(ndif)
									gaResDif[ndif]=REPLICATE(CHR(9),2)+"</Ori>"
		
									nDif=nDif+1
									DIMENSION gaREsDif(ndif)
									gaResDif[ndif]=REPLICATE(CHR(9),2)+"<New>"
		
									nDif=nDif+1
									DIMENSION gaREsDif(ndif)
									gaREsDif[ndif]=REPLICATE(CHR(9),2)+gaPutNew[xi]
		
									nDif=nDif+1
									DIMENSION gaREsDif(ndif)
									gaResDif[ndif]=REPLICATE(CHR(9),2)+"</New>"							
								ENDIF
							NEXT
								
							
							nDif=nDif+1
							DIMENSION gaREsDif(ndif)
							gaResDif[ndif]=REPLICATE(CHR(9),1)+"</"+gaVeri[i,1]+">"					
		
						ENDIF				
						
										
					CASE LOWER(gaVeri[i,1])=="tag2"	
		
						STORE 0 TO lnbOri,lnbNew,gb
						lnLenOri=LEN(gaVeri[i,2])
						lnLenNew=LEN(gaVeri[i,3])
						FOR ji=1 TO lnLenOri
							lnbOri=lnbOri+CTOBIN(SUBSTR(gaVeri[i,2],ji,1))
						NEXT
						FOR ji=1 TO LnLenNew
							lnbNew=lnbNew+CTOBIN(SUBSTR(gaVeri[i,3],ji,1))
						NEXT
							
						IF lnLenOri=lnLenNew
							IF lnbOri#lnbNew
								FOR ji=1 TO lnLenOri
									IF CTOBIN(SUBSTR(gaVeri[i,2],ji,1))#CTOBIN(SUBSTR(gaVeri[i,3],ji,1))
										gb=gb+1
										DIMENSION gaBind(gb)
									*	gabind[gb]=TRANSFORM(ji);
									*		+":<Ori=";
									*		+SUBSTR(gaVeri[i,2],ji,1);
									*		+"/>";
									*		+"<New=";
									*		+SUBSTR(gaVeri[i,3],ji,1);
									*		+"/>"
		
										DIMENSION gaBind(gb)
										gabind[gb]=TRANSFORM(ji);
											+":<Ori=";
											+TRANSFORM(CTOBIN(SUBSTR(gaVeri[i,2],ji,1)));
											+"/>";
											+"<New=";
											+TRANSFORM(CTOBIN(SUBSTR(gaVeri[i,3],ji,1)));
											+"/>"
		
									ENDIF
									
								NEXT
								
							
							ENDIF
						ENDIF
						
						
						=FPUTS(nfas,REPLICATE(CHR(9),2)+objFun.PutTag("LenOri",lnLenOri))
						=FPUTS(nfas,REPLICATE(CHR(9),2)+objFun.PutTag("SumBinOri",lnbOri))
						
						=FPUTS(nfas,REPLICATE(CHR(9),2)+objFun.PutTag("LenNew",lnLenNew))				
						=FPUTS(nfas,REPLICATE(CHR(9),2)+objFun.PutTag("SumBinNew",lnbNew))
						IF gb#0		
							=FPUTS(nfas,REPLICATE(CHR(9),2)+"<TAG2_BINTOC_DIF>")
							FOR si=1 TO gb
								
								=FPUTS(nfas,REPLICATE(CHR(9),3)+gabind[si])
							NEXT
							=FPUTS(nfas,REPLICATE(CHR(9),2)+"</TAG2_BINTOC_DIF>")
							
							* resumen
							ndif=ndif+1
							DIMENSION gaResDif(ndif)
							gaResDif[ndif]=REPLICATE(CHR(9),1)+"<"+gaVeri[i,1]+">"
												
							ndif=ndif+1
							DIMENSION gaResDif(ndif)
							gaREsdif[ndif]=REPLICATE(CHR(9),2)+objFun.PutTag("LenOri",lnLenOri)					
							ndif=ndif+1
							DIMENSION gaResDif(ndif)
							gaREsdif[ndif]=REPLICATE(CHR(9),2)+objFun.PutTag("SumBinOri",lnbOri)
							ndif=ndif+1
							DIMENSION gaResDif(ndif)
							gaREsdif[ndif]=REPLICATE(CHR(9),2)+objFun.PutTag("LenNew",lnLenNew)		
							ndif=ndif+1
							DIMENSION gaResDif(ndif)
							gaREsdif[ndif]=REPLICATE(CHR(9),2)+objFun.PutTag("SumBinNew",lnbNew)					
						
		
							ndif=ndif+1
							DIMENSION gaResDif(ndif)
							gaResDif[ndif]=REPLICATE(CHR(9),2)+"<TAG2_BINTOC_DIF>"					
						*	FOR xi=1 TO ALEN(gaPutnew)
								FOR si=1 TO gb
									ndif=ndif+1
									DIMENSION gaResDif(ndif)
									gaResDif[ndif]=REPLICATE(CHR(9),3)+gabind[si]
								NEXT
						*	NEXT
							ndif=ndif+1
							DIMENSION gaResDif(ndif)
							gaResDif[ndif]=REPLICATE(CHR(9),2)+"</TAG2_BINTOC_DIF>"						
							ndif=ndif+1
							DIMENSION gaResDif(ndif)
							gaResDif[ndif]=REPLICATE(CHR(9),1)+"</"+gaVeri[i,1]+">"					
												
						ENDIF
						
							
					OTHERWISE
					
						
						=FPUTS(nfas,REPLICATE(CHR(9),2)+objFun.PutTag("Ori",gaVeri[i,2]))
						=FPUTS(nfas,REPLICATE(CHR(9),2)+objFun.PutTag("New",gaVeri[i,3]))
						
						IF gaVeri[i,2]#gaVeri[i,3]
							=FPUTS(nREs,REPLICATE(CHR(9),1)+"<"+gaVeri[i,1]+">")
								=FPUTS(nres,REPLICATE(CHR(9),2)+objFun.PutTag("Ori",gaVeri[i,2]))
								=FPUTS(nres,REPLICATE(CHR(9),2)+objFun.PutTag("New",gaVeri[i,3]))
							=FPUTS(nREs,REPLICATE(CHR(9),1)+"</"+gaVeri[i,1]+">")					
							
						ENDIF
						
							
				ENDCASE
				=FPUTS(nfas,REPLICATE(CHR(9),1)+"</"+gaVeri[i,1]+">")	
			NEXT
			=FPUTS(nfas,"</"+lcREGISTRO+">")
			IF ndif#0
				=FPUTS(nres,"<"+lcREGISTRO+">")
				FOR i=1 TO ndif
					=FPUTS(nres,gaResDif[i])
				NEXT
				=FPUTS(nres,"</"+lcREGISTRO+">")		
			ENDIF
			
		ENDSCAN
		SET EXACT OFF
		
		=FCLOSE(nfas)
		=FCLOSE(nres)
		loCnv=null
		objfun=null
		SELECT original
		USE
		SELECT nuevo
		USE
		RETURN fcr
	ENDPROC

	PROCEDURE getlinea
		LPARAMETERS xnHand,xlFin
		IF FEOF(xnHand)
			xlFin=.t.
			RETURN ""
		ENDIF
		RETURN FGETS(xnHand,2048)
		
	ENDPROC

	PROCEDURE getmask
		LPARAMETERS xnNumero,xnMinDec,xlVAcio
		********************************************
		* Obtiene la máscara de un número para un cuadro
		* InputMask=GetMask(lnNumero)
		* InputMask=GetMask(lnNUmero,2,.t.) (dos decimales, no muestra valor cero)
		****************************************************************************
		LOCAL lnDecim,lcBasic
		IF VARTYPE(xnMinDec)="N"
			xnNumero=INT(xnNumero) + 0.10 ** xnMinDec
			lnDecim=xnMinDec
		ELSE
			lnDecim=this.Teldecim(xnNumero)
		ENDIF
		lcBAsic="999,999,999,999"+IIF(!EMPTY(lnDecim),".","")+REPLICATE("9",lnDecim)
		RETURN CHRTRAN(LTRIM(TRANSFORM(xnNumero,lcBasic)),'0123456789',REPLICATE("9",10))
		
	ENDPROC

	PROCEDURE guserprop
		LPARAMETERS xnfop,xnfap
		
		LOCAL lctag,lcShat,lcQuit,lnTags,lfap,;
			lcINi,lnIni,lcFin,lnFin,lWrite
		 
		lcIni="<OBJETO_"
		LnIni=LEN(lcIni)
		lcFin="</OBJETO_"
		lnFin=LEN(lcFin)
		
		
		lcTag=this.seltag
		lcShat="</"+SUBSTR(lcTag,2)
		
		lcQuit=CHR(9)+CHR(10)+CHR(13)
		lnTags=0
		lOpenob=.f.
		lWrite=.f.
		lTagINclu=.f.
		lCloseTag=.f.
		lOPenTag=.f.
		LOCAL ARRAY gaCont(1)
		ng=0
		DO WHILE !FEOF(xnfop)
			lcget=FGETS(xnfop,2048)
			lnEspa=OCCURS(CHR(9),lcGet)
			lcGet=ALLTRIM(CHRTRAN(lcGet,lcQuit,""))
				
			IF LEFT(lcGet,1)="<" AND RIGHT(lcGEt,1)=">"
				* Etiqueta
			
				DO case
					CASE LEFT(lcGet,lnIni)==lcINi
		
						* Apertura de objeto <OBJETO_20>
						lOpenOb=.t.	
						ng=0
						DIMENSION gaCont(1)
						ng=ng+1
						DIMENSION gaCont(ng)
						gaCont[ng]="<TAG>"
					CASE LEFT(lcGet,lnFin)==lcFin
						* Cierre de objeto </OBJETO_20>
						lOpenOb=.f.
						STORE .f. TO lWrite,lTagInclu
						IF lOPenTag
							
							FOR tx=1 TO ng
								=FPUTS(xnfap,gaCont[tx])
							NEXT
							=FPUTS(xnfap,"</TAG>")
						ENDIF
						lOPentag=.f.
						ng=0
						DIMENSION gaCont(1)
		
				
					CASE LEFT(lcget,2)="</"	
						* Cierre de etiqueta abierta
						* </user_procedure>
						IF lcGEt==lcShat
		
							STORE .f. TO lTagInclu
							lWrite=.f.
							
							lCloseTAg=.T.
							ng=ng+1
							DIMENSION gaCont(ng)
							gaCont[ng]=lcGet
						ENDIF
						
					CASE RIGHT(lcGEt,2)="/>"
						* Etiqueta incluida
						* <name=|C|=pepe/>
		
						IF lOPenOb
							ng=ng+1
							DIMENSION gaCont(ng)
							gaCont[ng]=lcGet
						ENDIF
						lWrite=.f.
					*	STORE .t. TO lWrite,lTagInclu
					OTHERWISE
						IF lcGet==lcTag
						* apertura de etiqueta
							lOpenTag=.t.
							lnTags=lnTags+1
							ng=ng+1
							DIMENSION gaCont(ng)
							gacont[ng]=lcGet
							lWrite=.t.			
						ENDIF
				ENDCASE
			ELSE
				* valor de etiqueta abierta
				IF lWrite
					ng=ng+1
					DIMENSION gaCont(ng)
					gaCont[ng]=lcGet
				
				ENDIF
				
			ENDIF
			
		ENDDO
		RETURN lnTags
	ENDPROC

	PROCEDURE Init
		*Funciones de lenguaje marcado
		this.testmessage()
		with this
			STORE "" TO .garelea,.seltag,.tipout,.fileo,.filetext,.filew
			.Th_mensaje="Mensaje del Sistema"
		endwith
		
	ENDPROC

	PROCEDURE inone
		LPARAMETERS xcRoot
		RELEASE OMENS
		PUBLIC OMENS
		LOCAL lcRoot,lcFile,lcFoxBin,lcExten,objInf,lcDapli
		lcDapli=_screen.dapli
		objInf=NEWOBJECT("Empty")
		ADDPROPERTY(objInf,"Fileo","")
		ADDPROPERTY(objInf,"filew","")
		ADDPROPERTY(objInf,"fileText","")
		ADDPROPERTY(ObjInf,"FObjetori","")
		ADDPROPERTY(ObjInf,"FObjetnew","")
		ADDPROPERTY(ObjInf,"NameCur","")
		
		IF VARTYPE(xcRoot)#"C" OR EMPTY(xcroot) OR !DIRECTORY(xcRoot)
			xcRoot=FULLPATH("")
		ENDIF
		
		lcRoot=xcRoot
		
		
		CD &lcRoot
		lcFile=GETFILE("SCX;VCX;PJX;FRX;MNX")
		CD &lcDAPLI
		IF EMPTY(lcfile)
			RETURN
		ENDIF
		******
		oMens=This.mensajero("FoxBin All In One...")
		
		lcExten=JUSTEXT(lcFile)
		DO case
			CASE INLIST(lcExten,"SCX","VCX","PJX","MNX")
				? " Generando FoxBin2prg sobre archivo fuente..."
				lcFoxbin=This.getfoxbin1(lcFile)
				lcRoot=ADDBS(_Screen.Dapli)+"Entrada"
				lcRecup=ADDBS(lcRoot)+JUSTFNAME(lcFoxbin)
				IF !FILE(lcRecup)
					MESSAGEBOX("El archivo &lcRecup no existe",0,_screen.th_mensaje)
					RETURN
				ENDIF
		
				? " Generando FoxBin2prg sobre archivo nuevo..."
				LcNameREcup=This.Getfoxbin2(lcRecup)
		
				? "Abriendo parsers..."
				lcParser=ADDBS(lcRoot)+JUSTSTEM(lcfile)+".txt"
				lcFilew=ADDBS(JUSTPATH(lcParser))+JUSTSTEM(lcParser)+"_new."+JUSTEXT(lcParser)
		
				IF !FILE(lcFilew)
					MESSAGEBOX(lcFilew+" No Existe")
					CD &lcRoot
					lcFilew=GETFILE("TXT")
					CD &lcDAPLI
					IF EMPTY(lcFilew)
						RETURN
					ENDIF
				ENDIF
				IF LOWER(lcfile)==LOWER(lcfilew)
					MESSAGEBOX("Ha seleccionado el mismo Archivo",0,_screen.th_mensaje)
					RETURN
				ENDIF
				WITH objInf
					.Fileo=lcParser
					.Filew=lcfilew
					.FObjetOri=LOWER(lcFoxBin)
					.FObjetNew=LOWER(lcNameREcup)
				ENDWITH
				
				IF lcExten#"MNX"
					This.Galltags(ObjInf)
				ELSE
					*MESSAGEBOX("GALLTAGS SALTEADO")
					this.pdifmnu(ObjInf)
				ENDIF
		
			CASE lcExten=="FRX"
				*DO foxbin2prg WITH xcFile
				
				ojbInf.filetext=this.getfoxbinrep(lcfile)
				
			
			
			OTHERWISE
				MESSAGEBOX("Archivo seleccionado de tipo inválido para el análisis"+CHR(13);
					+lcfile,0,_screen.th_mensaje)
		ENDCASE
		oMens=null
		RELEASE oMens
		RETURN objInf
		
		
	ENDPROC

	PROCEDURE mensajero
		LPARAMETERS xcCaption
		xcCaption=EVL(xcCaption,"Mensajero")
		LOCAL oname
		oname=NEWOBJECT("form")
		WITH oname
			.Height = 250
			.Width = 521
			.BorderStyle = 0
			.Caption = xcCaption
			.ControlBox = .F.
			.Closable = .F.
			.FontSize = 8
			.MaxButton = .F.
			.MinButton = .F.
			.AlwaysOnTop = .T.
			.AutoCenter = .T.
			.BackColor =RGB(255,252,244)
			.Name = "MENSAJERO"
		ENDWITH
		oName.show()
		RETURN oName
		
		
	ENDPROC

	PROCEDURE parserform		&& Obtiene en un archivo de texto marcado el contenido de un Form scx
		lparameters xcWform,xlShowMethod,xlNoIncComm,xlGenXml,xlEmptyTag
		*****************************************************************
		* PROCEDURE gParserForm
		*****************************************************
		* Transporta a un archivo de lenguaje marcado 
		* el contenido de un formulario.scx de visual Fox
		*****************************************************
		* Convocatoria 
		* Thisform.Funmark1.gParseForm(cFormulario,;
		*				lMostrarMetodos_de_Usuario,;	
		*				lNoInclur *Comentarios,;
		*				lGenerar_Como_xml,;
		*               lMostrarTags_Vacías)
		******************************************************
		LOCAL i,j,lcFormu,xGenXml,cNaMetod,cNameProp,lHavProp,;
			lHavMetod,nfop,npuf,npif,lBandera,lUserProp,lUserMet,;
			lDataEnvi,lClosEnvi,nObj,nSpa,cQuit,dquit,;
			cCampo,lPut,lgPut,xcfile,fcr,;
			np,bi,no,ne,gu,gm,pa,NR,lWrite,NPICT,lcExact,lcPicture,;
			objFun
		
		
		LOCAL ARRAY gaPicture(1)
		**************************************
		* Definiciones
		Store 0 to np,no,nObj,ne,gu,gm,nPict
		pa=0
		nSpa=5
		cQuit=chr(10)+chr(13)
		dQuit=Chr(9)
		objFun=NEWOBJECT("Prsfun","clases\prssys.vcx")
		*****************************************
		
		if vartype(xcWform)#"C" OR empty(xcWform)
			RETURN
		ENDIF
		lWrite=.t.
		IF AT("<N>",xcwform)#0
			xcwform=ALLTRIM(STRTRAN(xcWForm,"<N>",""))
			lWrite=.F.
		ENDIF
		IF AT("<n>",xcwform)#0
			xcwform=ALLTRIM(STRTRAN(xcWForm,"<n>",""))
			lWrite=.F.
		ENDIF
		xcForm=Upper(alltrim(xcWform))
		if xcWform=="ZAPARSERFORM.SCX"
			Messagebox("No puede analizar este formulario")
			return
		endif
		
		* Propiedades, Métodos y Eventos de un Formulario en Blanco
		* gaMember permite determinar para el objeto Form
		* si un Procedure es Nativo ó de Usuario
		* Corresponde a <NATIVE_PROCEDURE> ó <USER_PROCEDURE>
		oForm = CREATEOBJECT("Form")
		nMemb=AMEMBERS(gaMember, oForm, 1 )
		release oform
		for i=1 to alen(gaMember,1)
			gaMember[i,1]=Upper(alltrim(gaMember[i,1]))+"/"
		next
		
		* Arrays de Listado
		local Array gatom(7,3),gaPut(1),gaObj(1),;
			gaEnc(1),gaUser(1),gaUsMet(1),gaParent(1,5),gadim(5),;
			gaReserved(1)
			
		STORE "" TO gaParent
			
		*	gaParent[pa,1]=" Parent"
		*	gaParent[pa,2]="Name"
		*	gaParent[pa,3]="Class"
		*	gaParent[pa,4]="BaseClass"
		*	gaParent[pa,5]="ClassLibrary"
		
		gatom[1,1]="ObjName"   && .Name del Objeto
		gatom[2,1]="Parent"    && Contenedor del Objeto	
		gatom[3,1]="Class"	   && Nombre de la Clase p.ej "CommandButton"
		gatom[4,1]="BaseClass" && Basado en p. ej. "CommandButton"
		gatom[5,1]="ClassLoc"  && Biblioteca p. ej. "\LIBS\MiClase"
		gatom[6,1]="Methods"   && Métodos de Usuario del Objeto	
		gatom[7,1]="Ole2"
		for i=1 to alen(gatom,1)
			gatom[i,2]=""
			gatom[i,3]=""
		next
		
		IF AT("\",xcwform)>0
			this.dirformu=JUSTPATH(xcwform)
			xcWForm=JUSTFNAME(xcwform)
		ENDIF
		
		lcFormu=iif(empty(this.DirFormu),lower(xcwform),addbs(this.DirFormu)+lower(xcWForm))
		
		IF USED("OFORMU")
			SELECT OFORMU
			USE
		ENDIF
		if !file(lcFormu)
			Messagebox("No se encuentra &lcFormu",0,_screen.th_mensaje)
			return .F.
		ENDIF
		
		lcRvf=this.rv_fdate(lcFormu,.t.)
		lxRvf=this.rv_fdate(lcformu,.f.)
		
		* Apertura del Formulario
		USE (lcFormu) IN 0 alias oformu
		SELECT oformu
		
		
		*	browse
		*	USE
		*	RETURN
		*********
		
		cNametod=iif(!empty(_Screen.dtemp),addbs(_Screen.dtemp),"")+"gMetod.txt"	&& Nombre archivo Metodos
		cNameProp=iif(!empty(_Screen.dtemp),addbs(_Screen.dtemp),"")+"gProper.txt" && Nombre archivo Properties
		cNameRes=iif(!empty(_Screen.dtemp),addbs(_Screen.dtemp),"")+"gReserv.txt" && Nombre archivo Properties
		
		if xlGenXml
			ne=this.Aadd(@gaEnc,ne,"<?xml version='1.0' encoding='ISO-8859-1'?>")
		ELSE
			ne=This.Aadd(@gaEnc,ne,"<? Not xml Form. Just Internal Market Language>")
		endif
		* Encabezado
		
		*	ne=This.Aadd(@gaEnc,ne,"<ANALIZE>")
		*	ne=This.Aadd(@gaEnc,ne,PmlTag(ttoc(dateTime()),"INFCREATED",.T.))
		*	ne=This.Aadd(@gaEnc,ne,PmlTag(lcFormu,"FORM",.T.))
		*	ne=This.Aadd(@gaEnc,ne,PmlTag(this.TRaduToc(lcRvf),"LASTMOD",.T.))
		*	ne=This.Aadd(@gaEnc,ne,PmlTag(Qualifer2(xlShowMethod),"SHOWMETHOD",.T.))
		*	ne=This.Aadd(@gaEnc,ne,PmlTag(Qualifer2(xlNoIncComm),"OMITCOMMENT",.T.))
		*
		
		ne=This.Aadd(@gaEnc,ne,"<ANALIZE>")
		ne=This.Aadd(@gaEnc,ne,objFun.PutTag("INFCREATED",ttoc(dateTime())))
		ne=This.Aadd(@gaEnc,ne,objFun.PutTag("FORM",lcFormu))
		ne=This.Aadd(@gaEnc,ne,objFun.PutTag("LASTMOD",this.TRaduToc(lcRvf)))
		ne=This.Aadd(@gaEnc,ne,objFun.PutTag("SHOWMETHOD",objfun.qualifer2(xlShowMethod)))
		ne=This.Aadd(@gaEnc,ne,objFun.PutTag("OMITCOMMENT",objfun.qualifer2(xlNoIncComm)))
		
		lcExact=SET("EXACT")
		SET EXACT ON
		select oformu
		SCAN FOR ALLTRIM(PLATFORM)=="WINDOWS"
			Store .f. to lHavMetod,lBandera,lHavProp,lUserProp
		
			lcClase=alltrim(chrtran(class,cQuit,""))
			if lDataEnvi AND  lcClase#"cursor"
				np=This.Aadd(@gaput,np,"</ENTORNO>")
				lClosEnvi=.t.
			endif	
			if !lClosEnvi
				if !lDataEnvi
					lDataenvi=iif(lcClase=="dataenvironment",.t.,.f.)
					if lDataEnvi
						np=This.Aadd(@gaput,np,"<ENTORNO>")
					ENDIF			
				endif
			else
				lDataEnvi=.f.
			endif
		
			for i=1 to alen(gatom,1)
				cCampo=gatom[i,1]
				lcEval=EVALUATE(cCampo)
				*IF Inlist(alltrim(lower(Evaluate(cCampo))),"cursor","form")
				IF !EMPTY(lcEval)
					if !empty(Properties)
						lHavProp=.t.
						Strtofile(Properties,cNameProp)
					endif
				endif
				if cCampo#"Methods"
					lcEval=Alltrim(Evaluate(cCampo))
					lcEval=ChrTRan(lcEval,cQuit,"")
					gatom[i,2]=lcEval
				else
					if !empty(Methods)
						lHavMetod=.t.
						Strtofile(Methods,cNametod)
					endif
				endif
			next
			if !lDataEnvi
				loClassLoc=Proper(alltrim(chrtran(oformu.ClassLoc,cQuit,"")))
				loParent=Proper(alltrim(chrtran(oformu.Parent,cQuit,"")))
			*	bas=ascan(gaParent,loParent)
		
		
				
				pa=pa+1
				dimension gaparent(pa,5)
				gaParent[pa,1]=loParent
				gaParent[pa,2]=Proper(alltrim(chrtran(oformu.ObjName,cQuit,"")))
				gaParent[pa,3]=Proper(alltrim(chrtran(oformu.Class,cQuit,"")))
				gaParent[pa,4]=Proper(alltrim(chrtran(oformu.BaseClass,cQuit,"")))
				gaParent[pa,5]=loClassLoc
		*		loString=Proper(alltrim(chrtran(oformu.ObjName,cQuit,"")))+" en ";
		*			+Proper(alltrim(chrtran(oformu.parent,cQuit,"")))+" [";
		*			+Proper(alltrim(chrtran(oformu.Class,cQuit,"")))+" (";
		*			+Proper(alltrim(chrtran(oformu.BaseClass,cQuit,"")));
		*			+iif(!empty(loClassLoc)," de "+loClassLoc,"");
		*			+")]"
		*		nObj=This.Aadd(@gaObj,nObj,loString)	
				nObj=nObj+1	
				cSTring="OBJETO_"+LTRIM(STR(nObj))
				np=This.Aadd(@gaput,np,"<&cString>")
			endif
			if lcClase=="form"
				for ix=8 to 1 step -1
					lcRvCampo="Reserved"+ltrim(str(ix))
					if !Empty(EVALUATE(LCRVCAMPO))
						Strtofile(&lcRvCampo,cNameRes)
						zpuf=-1
						if GetFopen(cNameRes,@zpuf,.t.)
							lUserProp=.t.
							gu=This.Aadd(@gaUser,gu,space(nspa*1)+"<USER_PROPERTIES>")
							do while !feof(zpuf)
								lcReserv=fgets(zpuf,2048)
								lcReserv=ChrTran(lcReserv,cQuit,"")
								lcReserv=Proper(Alltrim(lcReserv))
								*lower(Strtran(lcReserv,chr(32),""))
								lnAt=At(chr(32),lcReserv)
								if lnAt#0
									lcReserv=Substr(lcREserv,1,lnAt)+"[";
										+Substr(lcReserv,lnAt+1)+"]"
								endif	
								do case
									case left(lcReserv,1)="^"
										lcReserv="ARRAY Thisform."+Substr(lcReserv,2)
									case left(lcReserv,1)="*"
										*Procedure (M)
										lUserMet=.t.
										gm=this.Aadd(@gaUsMet,gm,Space(nspa*2);
											+"Thisform."+Substr(lcReserv,2)+"()")
										lcReserv=""
									other
										lcReserv="Thisform."+lcReserv
										*Propiedad de Usuario (P)
									
								endcase
								if !empty(lcReserv)
									gu=This.Aadd(@gaUser,gu,space(nspa*2)+lcReserv)
								endif
								
							enddo
							=fclose(zpuf)
							gu=This.Aadd(@gaUser,gu,space(nspa*1)+"</USER_PROPERTIES>")
						endif
					endif
				next
			endif
			
		
			for i=1 to alen(gatom,1)
				if gatom[i,1]#"Methods"
					lgdot=iif(!empty(gatom[i,2]) OR xlEmptyTag,.t.,.f.)
					if lgdot
						np=This.Aadd(@gaput,np,Space(nSpa)+objFun.PutTag(gatom[i,1],gatom[i,2]) )
					endif
					if lHavProp
						np=This.Aadd(@gaput,np,space(nspa*1)+"<PROPERTIES>")
						
						npuf=-1
						if GetFopen(cNameProp,@npuf,.t.)
							do while !Feof(npuf)
								cGetProp=fgets(npuf,2048)
								cGetProp=ChrTran(cGetProp,cQuit,"")
						
								IF AT("Picture =",cGetProp)#0
									lcPicture=ALLTRIM(SUBSTR(cGetProp,AT("=",cGetProp)+1))
									IF ASCAN(gaPicture,lcPicture)=0
										nPict=nPict+1
										DIMENSION gaPicture(npict)
										gaPicture[nPict]=lcPicture
									ENDIF
								ENDIF						
								nIgual=ALINES(gaLigual,cGetProp,1,"=")
								IF nIgual=2
									cGetProp=TRIM(gaLigual[1])+" = "+ALLTRIM(gaLIgual[2])
								endif
								
								cGetTry=lower(Strtran(cGetProp,chr(32),""))
								nat=at("=",cGetTry)
								lgput=.t.
								if nat#0
									cGEtTry=left(cGetTry,nat)
							*		lgPut=!inlist(cGetTry,"top","left","width","height")
								endif
								if lgPut		
									np=This.Aadd(@gaput,np,space(nspa*2)+cGetProp)
								endif
							enddo
							=fclose(npuf)
						endif
						np=This.Aadd(@gaput,np,space(nspa*1)+"</PROPERTIES>")
						lHavProp=.f.
					endif
					if lUserProp AND  gu#0
						for ix=1 to alen(gaUser)
							np=This.Aadd(@gaput,np,gaUser[ix])
						next
						lUserProp=.f.
					endif
					if lUserMet AND  gm#0
						np=this.Aadd(@gaput,np,space(nspa*1)+"<USER_METHODS>")
						FOR ix=1 to alen(gaUsMet)
							np=this.Aadd(@gaput,np,gaUsMet[ix])
						next
						np=this.Aadd(@gaput,np,space(nspa*1)+"</USER_METHODS>")
						lUserMet=.f.
					endif
				else
					if lHavMetod
						np=This.Aadd(@gaput,np,space(nSpa*1)+"<METHODS>")
						if xlShowMethod
							NPIF=-1
							if GetFopen(cNaMetod,@npif,.t.)
								cStrProc="PROCEDURE"
								do while !feof(npif)
									lPuts=.t.
									cGets=trim(fgets(npif,2048))
									cGets=ChrTran(cGets,cQuit,"")
									if Empty(cGets)
										lPuts=.f.
									endif
									if lPuts AND  xlNoIncComm
										lPuts=iif(At("*", Alltrim( chrTran(cGets,dquit,"")))=1,.F.,.T.)
									endif
									if lPuts
										if at("PROCEDURE",Alltrim( chrTran(cGets,dquit,"")))=1
											
											if lBandera
												np=This.Aadd(@gaput,np,Space(nspa*2)+"</&cStrProc>")
											endif									
											if lcClase=="form"
												meGets=Upper(alltrim(cGets))
												meGets=alltrim(Strtran(meGets,"PROCEDURE"))
												lNative=iif(ascan(gaMember,Upper(alltrim(MEGets))+"/")#0,.t.,.f.)
												cStrProc=iif(lNative,"NATIVE_PROCEDURE","USER_PROCEDURE")
											endif	
		
											np=This.Aadd(@gaput,np,Space(nSpa*2)+"<&cStrProc>")
		
											lBandera=.t.
										endif
		
										if xlGenXml
			*								np=This.Aadd(@gaput,np, Space(nSpa*3)+PmlTag(cGets,"LINE",.T.) )
											np=This.Aadd(@gaput,np, Space(nSpa*3)+objFun.PutTag("LINE",cGets) )
										else
											np=This.Aadd(@gaput,np, space(nSpa*3)+cGets )
										endif
									endif
								enddo
								=fclose(nPif)
								*
								np=This.Aadd(@gaput,np,Space(nspa*2)+"</&cStrProc>")
							endif
						ELSE
			*				np=This.Aadd(@gaput,np,Space(nspa*3)+PmlTag("Methods","OMITED",.T.))
							np=This.Aadd(@gaput,np,Space(nspa*3)+objFun.PutTag("OMITED","Methods"))
						endif
						np=This.Aadd(@gaput,np,space(nSpa*1)+"</METHODS>")
					endif
				
				endif
			
			next
			if !lDataEnvi	
				np=This.Aadd(@gaput,np,"</&cString>")
			endif
			
			
		ENDSCAN
		nr=this.aadd(@gaReserved,nr,"<COMMENT>")
		SCAN FOR ALLTRIM(PLATFORM)=="COMMENT"
			nr=this.aadd(@gaReserved,nr,CHR(9)+"<"+ALLTRIM(UNIQUEID)+">")
			FOR J=3 TO FCOUNT()
				lcField=field(j)
				lcVal=EVALUATE(lcField)
				lcChar=""
				IF VARTYPE(lcVal)="C"
					FOR xi=1 TO LEN(lcval)
						lcChar=lcChar+TRANSFORM(ASC(SUBSTR(lcval,xi,1)))+","
					NEXT
					lcChar=LEFT(lcChar,LEN(lcchar)-1)
					lcVal=CHRTRAN(lcval,CHR(10),CHR(28))
				ENDIF
				IF !EMPTY(lcVal)
					nr=This.aadd(@gaREserved,nr,objFun.PutTag(lcField,lcVal,2))
					IF !EMPTY(lcChar)
						nr=This.Aadd(@gaReserved,nr,objFun.PutTag(lcField+"_TrueChar",lcchar,2))
					ENDIF
					
				ENDIF
			NEXT
			nr=this.aadd(@gaReserved,nr,CHR(9)+"</"+ALLTRIM(UNIQUEID)+">")
		ENDSCAN
		nr=this.aadd(@gaReserved,nr,"</COMMENT>")
		select oformu
		use
		np=This.Aadd(@gaput,np,"</ANALIZE>")
		
		
		* Crear en bajo nivel archivo de listado.
		fcr=iif(!empty(_Screen.dtemp),addbs(_Screen.dtemp),"")+JustStem(lcFormu)+iif(xlGenXml,".xml",".txt")
		nfop=fcreate(fcr)
		* Escribe
		if ne#0
			for bi=1 to alen(gaEnc)
				=fputs(nfop,gaEnc[bi])
			next
		ENDIF
		if nObj#0
			=fputs(nfop,"<OBJETOS>")
		
			* Tamaño de las columnas del informe
			* Repara elementos vacíos.
			
			Store 0 to gadim
			for di=1 to alen(gaparent,1)
				for dj=1 to alen(gaParent,2)
					DO case
						CASE dj=1
							gaParent[di,dj]=objFun.PutTag("Parent",EVL(gaparent[di,dj],"_Screen"))
						CASE dj=2
							gaParent[di,dj]=objFun.PutTag("Name",gaparent[di,dj])
						CASE dj=3
							gaParent[di,dj]=objFun.PutTag("Class",gaparent[di,dj])
						CASE dj=4
							gaParent[di,dj]=objFun.PutTag("BaseClass",gaparent[di,dj])
						CASE dj=5
							gaParent[di,dj]=objFun.PutTag("ClassLibrary",EVL(gaparent[di,dj],"VFPBase"))
					ENDCASE
					
			
					gadim[dj]=MAX(gadim[dj],len(gaParent[di,dj]))		
		
				next
			next
			* ordena gaParent * AScendente
			this.arraytocursor(@gaParent,"PEPA")
			IF USED("PEPA")
				SELECT PEPA
				INDEX ON CAMPO1+CAMPO2+CAMPO3 TAG IPEPA
				SET ORDER TO ipepa
				this.cursortoarray("PEPA",@gaParent,.t.)		
			ELSE
				Asort(gaParent,1)
			ENDIF
		
			
			for di=1 to alen(gaparent,1)
				cInput=""
				FOR dj=1 TO ALEN(gaParent,2)
					cINput=cINput+PADR(gaParent[di,dj],gadim[dj]," ")+" "
				NEXT
				=FPUTS(nfop,CHR(9)+cInput)
			next
			=fputs(nfop,"</OBJETOS>")	
		ENDIF
		
		
		IF nPict#0
			*npath=ALINES(gaPath,xcWform,16,"\")
			npath=ALINES(gaPath,ADDBS(JUSTPATH(xcWform)),16,"\")	
			FOR bi=1 TO nPict
				IF LEFT(gaPicture[bi],3)=="..\"
					lcPath=""
					FOR xix=1 TO nPath-1
						lcPath=lcPath+gaPath[xix]
					NEXT
					
					gaPicture[bi]=lcPath+SUBSTR(gaPicture[bi],4)
				ENDIF
			NEXT
			
			=FPUTS(nfop,"<PICTURE>")
			FOR BI=1 TO nPict
				=FPUTS(nfop,REPLICATE(CHR(9),1)+gaPicture[bi])
			NEXT
			=FPUTS(NFOP,"</PICTURE>")
		ENDIF
		IF nr#0
			FOR bi=1 TO ALEN(gaReserved)
				=FPUTS(nfop,gaReserved[bi])
			NEXT
		ENDIF
		
		
		if np#0
			for bi=1 to alen(gaput)
				=fputs(nfop,gaput[bi])
			next
		endif
		
		=FCLOSE(NFOP)
		objfun=null
		SET EXACT &lcExact
		
		IF lwrite
			xcfile=this.suredir(FCR)
			o = CREATEOBJECT("Shell.Application")
			o.ShellExecute("write.exe", '&xcfile', "", "open", 1)
		ENDIF
		
	ENDPROC

	PROCEDURE parsermemo
		LPARAMETERS xcTabla,xcMemo1,xcMemo2,xcMemo3,xcCalif
		* .PaRserMemo(Tabla,"Original","FoxBin","Diferen")
		LOCAL ARRAY gaMebas(1),gaMeBin(1)
		LOCAL nBas,nbin,npHand,fcr,lcMemo1,lcMemo2,objFun
		objfun=NEWOBJECT("prsfun","clases\prssys.vcx")
		
		
		
		STORE 0 TO nBas,nBin
		SELECT (xcTabla)
		lcMemo1=EVALUATE(xcMemo1)
		lcmemo2=EVALUATE(xcMemo2)
		
		IF EMPTY(lcMemo1) AND EMPTY(lcMemo2)
			IF !EMPTY(xcCalif)
				replace (xcCalif) WITH .t.
			ENDIF
			RETURN 
		ENDIF
		
		fcr=ADDBS(_Screen.dtemp)+"prsmemo.txt"
		npHand=FCREATE(fcr)
		nBas=ALINES(gaMebas,lcMemo1)
		nBin=ALINES(gaMebin,lcMemo2)
		IF nBas>nBin
			DIMENSION gaMebin(nbas)
		ENDIF
		IF nBin>nBas
			DIMENSION gaMeBas(nbin)
		ENDIF
		
		
		=FPUTS(npHand,"<BIN_TO_ORI>")
		FOR i=1 TO nBin
			nas=ASCAN(gaMeBas,gamebin[i])
			IF nas=0
				=FPUTS(npHand,objFun.PutTag("NOTFOUND",gaMebin[i],1))
			ENDIF
		NEXT
		=FPUTS(npHand,"</BIN_TO_ORI>")				
		=FPUTS(npHand,"<ORI_TO_BIN>")
		FOR i=1 TO nBas
			nas=ASCAN(gaMeBin,gamebas[i])
			IF nas=0
				=FPUTS(npHand,objFun.PutTag("NOTFOUND",gaMebas[i],1))
			ENDIF
		NEXT
		=FPUTS(npHand,"</ORI_TO_BIN>")
		=FCLOSE(npHand)
		
		replace (xcMemo3) WITH FILETOSTR(fcr)
		IF !EMPTY(xcCalif)
			replace (xcCAlif) WITH IIF(lcMemo1==lcMemo2,.t.,.f.)
		ENDIF
		objfun=null
		RETURN 
		
		
		
	ENDPROC

	PROCEDURE parsermnu
		lparameters xcWform,xnTipo
		IF EMPTY(xnTipo) OR VARTYPE(xnTipo)#"N"
			xnTipo=1
		ENDIF
		
		* xnTipo=1 Original xnTipo=2 FoxBin2 (recuperado)
		* xlShowMethod,xlNoIncComm,xlGenXml,xlEmptyTag
		
		xlShowMethod=.t.
		xlNoIncComm=.f.
		xlGenXml=.f.
		xlEmptyTag=.f.
		
		LOCAL i,xi,lcFormu,xGenXml,cNaMetod,cNameProp,lHavProp,;
			lHavMetod,nfop,npuf,npif,lBandera,lUserProp,lUserMet,;
			lDataEnvi,lClosEnvi,nObj,nSpa,cQuit,dquit,;
			cCampo,lPut,lgPut,xcfile,fcr,;
			np,bi,no,ne,gu,gm,pa,lWrite,NPICT,lcExact,lcPicture,;
			lnLevel,lnBarra,ldoit,lcFormu,;
			nProp,nDos,nsub,nInt,LcTitMenu,lcSubMenu,lcNumBarra,;
			objFun
		objfun=NEWOBJECT("prsfun","clases\prssys.vcx")
		
		
		
		LOCAL ARRAY gaPicture(1)
		
		* Definiciones
		
		Store 0 to np,no,nObj,ne,gu,gm,nPict,;
			pa,lnLevel,lnBarra
		STORE "" TO lcTitMenu,lcSubMenu
		nSpa=5
		cQuit=chr(10)+chr(13)
		dQuit=Chr(9)
		
		
		*****************************************
		
		if vartype(xcWform)#"C" OR empty(xcWform)
			RETURN
		ENDIF
		lWrite=.t.
		IF AT("<N>",xcwform)#0
			xcwform=ALLTRIM(STRTRAN(xcWForm,"<N>",""))
			lWrite=.F.
		ENDIF
		IF AT("<n>",xcwform)#0
			xcwform=ALLTRIM(STRTRAN(xcWForm,"<n>",""))
			lWrite=.F.
		ENDIF
		xcForm=Upper(alltrim(xcWform))
		
		oForm = CREATEOBJECT("Form")
		nMemb=AMEMBERS(gaMember, oForm, 1 )
		release oform
		for i=1 to alen(gaMember,1)
			gaMember[i,1]=Upper(alltrim(gaMember[i,1]))+"/"
		next
		
		* Arrays de Listado
		local Array gatom(7,3),gaPut(1),gaObj(1),;
			gaEnc(1),gaUser(1),gaUsMet(1),gaParent(1,5),gadim(5)
		STORE "" TO gaParent
			
		lcFormu=xcwForm
		IF AT("\",xcwform)>0
			this.dirformu=JUSTPATH(xcwform)
			xcWForm=JUSTFNAME(xcwform)
		ENDIF
		
		lcFormu=iif(empty(this.DirFormu),lower(xcwform),addbs(this.DirFormu)+lower(xcWForm))
		
		IF USED("OFORMU")
			SELECT OFORMU
			USE
		ENDIF
		if !file(lcFormu)
			Messagebox("No se encuentra &lcFormu",0,_screen.th_mensaje)
			return .F.
		ENDIF
		
		lcRvf=this.rv_fdate(lcFormu,.t.)
		lxRvf=this.rv_fdate(lcformu,.f.)
		
		* Apertura del Formulario
		USE (lcFormu) IN 0 alias oformu
		SELECT oformu
		
			
		cNametod=iif(!empty(_Screen.dtemp),addbs(_Screen.dtemp),"")+"gMetod.txt"	&& Nombre archivo Metodos
		cNameProp=iif(!empty(_Screen.dtemp),addbs(_Screen.dtemp),"")+"gProper.txt" && Nombre archivo Properties
		cNameRes=iif(!empty(_Screen.dtemp),addbs(_Screen.dtemp),"")+"gReserv.txt" && Nombre archivo Properties
		*xgaMatriz,xnPos,xcString
		if xlGenXml
			ne=this.Aadd(@gaEnc,ne,"<?xml version='1.0' encoding='ISO-8859-1'?>")
		ELSE
			ne=This.Aadd(@gaEnc,ne,"<? Not xml Form. Just Internal Market Language>")
		ENDIF
		
		* Encabezado
		
		ne=This.Aadd(@gaEnc,ne,"<ANALIZE>")
		ne=This.Aadd(@gaEnc,ne,objFun.PutTag("INFCREATED",ttoc(dateTime())))
		ne=This.Aadd(@gaEnc,ne,objFun.PutTag("MENU",lcFormu))
		ne=This.Aadd(@gaEnc,ne,objFun.PutTag("LASTMOD",this.TRaduToc(lcRvf)))
		ne=This.Aadd(@gaEnc,ne,objFun.PutTag("SHOWMETHOD",objfun.qualifer2(xlShowMethod)))
		ne=This.Aadd(@gaEnc,ne,objFun.PutTag("OMITCOMMENT",objfun.qualifer2(xlNoIncComm)))
		
		IF XNTIPO<2
			IF USED("JMENU")
				SELECT JMENU
				USE
			ENDIF
			IF USED("GMENU")
				SELECT GMENU
				USE
			ENDIF
			LcTEmp=_Screen.dtemp
			CREATE TABLE &lctemp\JMENU FREE ;
			("PROMPT" C(40),;
			"NAME" C(12),;
			"LEVELNAME" C(12),;
			"SCHEME" I,;
			"ITEMNUM" I,;
			"USENAME" C(20),;
			"SNAME1" C(40),"SNAME2" C(40),"SNAME3" C(40),;
			"OBJCODE" I,"OBJTYPE" I,"NUMITEMS" I,"ORDEN" I,"SUBORDEN" I,"NBARRA" I,;
			"ORIGINAL" M,"FOXBIN" M)
			lcTEmp=_screen.dtemp
			CREATE TABLE &lcTEMP\GMENU FREE ;
			("RAIZ" C(12),"BARRA" C(12),"MENU" C(12),"SMENU1" C(12),"SMENU2" C(12),;
			"OBJCODE" I,"OBJTYPE" I,"PROMPT" C(30),"CHAN" L,"ITEMNUM" I,"LEVELNAME" C(12),;
			"ORIGINAL" M,"FOXBIN" M)
		ENDIF
		
		LOCAL ARRAY gados(1),ganame(1),gasuname(1),gaProp(1),gaJunta(1)
		STORE 0 TO nProp,nDos,nsub,nInt
		
		
		lcTopLevel=""
		lcExact=SET("EXACT")
		SET EXACT ON
		select oformu
		nFields=AFIELDS(gaFields)
		STORE "" TO lcRaiz,lcBarra,lcMenu,lcSMenu1,lcSMenu2
		lcRaiz="_msysmenu"
		SELECT oformu
		GO top
		IF objCode=22
			this.menutype=objtype
		ENDIF
		SCAN 
		*	objtype=2 AND objCode=0 AND !EMPTY(NUMITEMS)
		*IF TRIM(LEVELNAME)=="_msysmenu" AND OBJTYPE=3
		*	lcBuscar=ALLTRIM(raiz)+ALLTRIM(barra)+ALLTRIM(menu)+ALLTRIM(smenu)
			lgmenu=.f.
			DO CASE	
				CASE LOWER(TRIM(LEVELNAME))=="_msysmenu" AND OBJTYPE=3
					lcBarra=LEFT(objfun.validtext(prompt),10)
					STORE "" TO lcMenu,lcsMenu1,lcsMenu2
				*	IF namechange
						lgmenu=.t.
				*	ENDIF
					
				CASE objcode=0
					IF OBJTYPE=2
						IF namechange 
							STORE "" TO lcMenu,lcsMenu1,lcsMenu2
						ENDIF
						IF LOWER(lcBarra)==LOWER(allTRIM(LEVELNAME))
							STORE "" TO lcMenu,lcsMenu1,lcsMenu2
						ENDIF
					ENDIF
					
					
					lGmenu=.t.
					
				CASE OBJCODE=22
					lgmenu=.t.
				CASE OBJCODE=1
		
					lcMenu=TRIM(levelname)
					IF LOWER(lcMenu)=="_msysmenu"
						lcMenu="_msysmenu"
					ENDIF
					
					lcSMenu1=LEFT(objfun.validtext(oformu.prompt),10)
					lgmenu=.t.
				CASE OBJCODE=67
					* command
					lcMenu=TRIM(levelName)
					IF LcMenu==lcBarra
						lcMenu=LEFT(objfun.validtext(oformu.prompt),10)		
						lcSMenu1=""
					ELSE
						lcsMenu1=LEFT(objfun.validtext(oformu.prompt),10)			
					ENDIF
					
					lgmenu=.t.
		
				CASE OBJCODE=77
					* submenu
					lcMenu=TRIM(levelName)
					IF LcMenu==lcBarra
						lcMenu=LEFT(objfun.validtext(oformu.prompt),10)		
						lcSMenu1=""
					ELSE
						lcsMenu1=LEFT(objfun.validtext(oformu.prompt),10)			
					ENDIF		
					lgmenu=.t.
		
				CASE OBJCODE=80
					*procedure
					lcMenu=TRIM(levelName)
					IF EMPTY(lcMenu)
						lcMenu=CHRTRAN(prompt,"\<","")
					ENDIF
					
					IF LcMenu==lcBarra
						lcMenu=LEFT(objfun.validtext(oformu.prompt),10)		
						lcSMenu1=""
					ELSE
						lcsMenu1=LEFT(objfun.validtext(oformu.prompt),10)			
					ENDIF		
					lgmenu=.t.			
								
				OTHERWISE
					lgMenu=.t.
			ENDCASE
			IF lGmenu
				lcbrbus=ALLTRIM(lcRaiz)+ALLTRIM(lcBarra)+ALLTRIM(lcMenu)+ALLTRIM(lcsMenu1)
				SELECT gmenu
				LOCATE FOR ALLTRIM(raiz)+ALLTRIM(barra)+ALLTRIM(menu)+ALLTRIM(smenu1)==lcbrBus
				IF !FOUND()
					INSERT INTO gmenu (raiz,barra,menu,smenu1,smenu2,OBJCODE,OBJTYPE,PROMPT,CHAN,ITEMNUM,LEVELNAME);
						 VALUES (lcRaiz,lcBarra,lcMenu,lcSMenu1,lcSmenu2,oformu.objcode,oformu.objtype,oformu.prompt,oformu.namechange,VAL(OFORMU.ITEMNUM),OFORMU.LEVELNAME)			
				ENDIF
				
			
			ENDIF
			
			lInsert=.f.
			IF TRIM(LEVELNAME)=="_msysmenu" AND OBJTYPE=3
				lctitMenu=LEFT(CHRTRAN(TRIM(prompt),"\<",""),10)
				lcSubMenu=lcTitMenu
				NINT=0
				ndos=ndos+1
				IF xnTipo<2
					INSERT INTO JMENU (USENAME,SNAME1,SNAME2,SNAME3,;
						OBJCODE,OBJTYPE,NUMITEMS,ORDEN,SUBORDEN) ;
					VALUES (lcTitMenu,CHRTRAN(TRIM(oformu.prompt),"\<",""),"","TIPO1",;
						OFORMU.OBJCODE,OFORMU.OBJTYPE,OFORMU.NUMITEMS,NDOS,NINT)
				ENDIF
				
				DIMENSION gados(ndos),ganame(ndos)
				ganame[ndos]=lcTitMenu
				
				gados[ndos]=objFun.PutTag("USENAME",lcTitMenu);
					+objFun.PutTag("PROMPT",TRIM(oformu.PROMPT));
					+objFun.PutTag("Name",TRIM(oformu.name));
					+objFun.PutTag("OBJCODE",OBJCODE)
					
				lInsert=.t.
			ELSE
				*TIPO2
				lcLevelName=ALLTRIM(oformu.levelName)
				lcName1=ALLTRIM(oformu.name)
				lcName2=CHRTRAN(ALLTRIM(oformu.prompt),"\<","")
				lcSubMenu=LEFT(objfun.validtext(EVL(lcName2,lcName1)),10)
		
				IF ASCAN(gaName,lcLevelName)#0
					lcTopLevel=ALLTRIM(levelname)
					IF !EMPTY(lcName2)
						LcValid2=LEFT(objfun.validtext(lcName2),10)
						IF !EMPTY(lcValid2)
							nSub=nSub+1
							DIMENSION gasuname(nsub),gaJunta(nsub,3)
							gasuname[nSub]=lcValid2
							gaJunta[nSub,1]=lcTitMenu
							gaJunta[nSub,2]=lcSubMenu
							gaJunta[nSub,3]=lcValid2
						ENDIF
						
					ENDIF
					IF xnTipo<2	
						INSERT INTO JMENU (USENAME,SNAME1,SNAME2,SNAME3,;
							OBJCODE,OBJTYPE,NUMITEMS,ORDEN,SUBORDEN) ;
						VALUES (lcLevelName,EVL(lcName1,lcName2),"","TIPO2",;
							OFORMU.OBJCODE,OFORMU.OBJTYPE,OFORMU.NUMITEMS,NDOS,NINT)		
					ENDIF
					
					NINT=NINT+1
					lInsert=.t.
				ELSE
					*TIPO3
		
					IF ASCAN(gaSuname,lcLevelName)#0
						IF xnTipo<2
							INSERT INTO JMENU (USENAME,SNAME1,SNAME2,SNAME3,;
								OBJCODE,OBJTYPE,NUMITEMS,ORDEN,SUBORDEN) ;
							VALUES (lcTopLevel,lcLevelName,EVL(lcName1,lcName2),"TIPO3",;
								OFORMU.OBJCODE,OFORMU.OBJTYPE,OFORMU.NUMITEMS,NDOS,NINT)				
						ENDIF
						
						lInsert=.t.
						NINT=NINT+1
					ENDIF
					
				
				ENDIF
					
			ENDIF
		
			SELECT oformu
			lnBarra = lnBarra + 1
			lcNumBarra="BARRA_"+TRANSFORM(lnBarra)
			ne=this.aadd(@gaEnc,ne,"<"+lcNumBarra+">")
			LnInBarr=ne+1
			lnLevel=lnLevel+1
			FOR i=1 TO nfields
				lcCampo=gaFields[i,1]
				lcType=gaFields[i,2]
				DO case
					CASE lcCampo=="MARK"
					
						lcVal=ctobin(LEFT(mark,1))
						lcType="N"
						LDOIT=.T.
					CASE LcCampo=="RESNAME"
						lcVal=EVALUATE(lcCampo)
						LDOIT=!EMPTY(lcVal)	
						IF lDoit
							nPict=nPict+1
							DIMENSION gaPicture(nPict)
							gaPicture[nPict]=ALLTRIM(lcVal)
						ENDIF
						
						
									
					OTHERWISE
					
						lcVal=EVALUATE(lcCampo)
						*LDOIT=!EMPTY(lcVal)
						ldoit=.t.
				ENDCASE
				
				IF ldoit
					DO case
						CASE lctype$'NCL'
							ne=This.Aadd(@gaEnc,ne,objFun.PutTag(lcCampo,lcVal,lnLevel))
						CASE lcType=="M"
							*Strtofile(&lcCampo,cNameProp)
							nlines=ALINES(gaMemos,lcVal,5)
							DO case
								CASE nLines=1
									ne=This.Aadd(@gaEnc,ne,objFun.PutTag(lcCampo,gaMemos[1],LnLevel))
								CASE nLines>1
									ne=This.Aadd(@gaEnc,ne,REPLICATE(CHR(9),lnLevel)+"<"+lcCampo+">")
									FOR xi=1 TO nLines
										ne=this.aadd(@gaEnc,ne,REPLICATE(CHR(9),lnLevel+1)+gaMemos[xi])
									NEXT
									ne=This.Aadd(@gaEnc,ne,REPLICATE(CHR(9),lnLevel)+"</"+lcCampo+">")
								OTHERWISE
							ENDCASE
				
						OTHERWISE
					
					ENDCASE
				ENDIF
				
			NEXT
			lcBarr=""
			FOR i=lnInBarr TO ne
				lcBarr=lcBarr+gaEnc[i]+CHR(13)
			NEXT
			lcBarr=LEFT(lcBarr,LEN(lcBarr)-1)
			IF !lInsert
				lcPut=lcSubMenu
				lcName1=lcTitMenu
				lcName2=lcSubMenu
				IF EMPTY(lcPut)
					lcPut=EVL(lcTitMenu,"_msysmenu")
				ENDIF
				IF !EMPTY(OFORMU.NAME) AND !EMPTY(OFORMU.LEVELNAME)
					IF TRIM(OFORMU.NAME)==TRIM(OFORMU.LEVELNAME)
						LcPut=lcTitMenu
						lcName1=lcSubMenu
						lcName2="Internal Command"
					ENDIF
				ENDIF
				
				INSERT INTO JMENU (USENAME,SNAME1,SNAME2,SNAME3,;
					OBJCODE,OBJTYPE,NUMITEMS,ORDEN,SUBORDEN) ;
				VALUES (lcPut,lcName1,lcName2,"TIPO0",;
					OFORMU.OBJCODE,OFORMU.OBJTYPE,OFORMU.NUMITEMS,NDOS,NINT)	
			ENDIF
			
			lcCampo=IIF(xnTipo=2,"FOXBIN","ORIGINAL")
			IF LGMENU
				SELECT GMENU
				REPLACE (lcCampo) WITH lcBarr
				*, NBARRA WITH lnBarra
			ENDIF
			SELECT jmenu
			REPLACE (lcCampo) WITH lcBarr, NBARRA WITH lnBarra
			IF EMPTY(usename)
				replace usename WITH "Menudef"
			ENDIF
			replace PROMPT WITH oformu.prompt,;
				NAME WITH OFORMU.NAME,;
				LEVELNAME WITH OFORMU.LEVELNAME,;
				SCHEME WITH OFORMU.SCHEME,;
				ITEMNUM WITH VAL(OFORMU.ITEMNUM)
			
			ne=this.aadd(@gaEnc,ne,"</"+lcNumBarra+">")
			lnLevel=lnLevel-1
		ENDSCAN
		USE
			
		
		np=This.Aadd(@gaput,np,"</ANALIZE>")
		
		
		
		SELECT JMENU
		GO TOP
		*BROWSE
		
		
		SET EXACT &lcExact
		
		
		SELECT GMENU
		GO TOP
		*BROWSE
		
		LOCAL ARRAY gamenu(5,2)
		*STORE "" TO gamenu
		gamenu[1,2]="RAIZ"
		GAMENU[2,2]="BARRA"
		GAMENU[3,2]="MENU"
		GAMENU[4,2]="SMENU1"
		GAMENU[5,2]="SMENU2"
		
		*fcr=ADDBS(_Screen.dtemp)+JUSTSTEM(lcFormu)+TRANSFORM(xnTipo)+"_gm.txt"
		fcr=iif(!empty(_Screen.dtemp),addbs(_Screen.dtemp),"")+JustStem(lcFormu)+".txt"
		nfop=fcreate(fcr)
		
		=FPUTS(nfop,"<ANALIZE>")
		=FPUTS(nfop,objFun.PutTag("INFCREATED",ttoc(dateTime())))
		=FPUTS(nfop,objFun.PutTag("MENU",lcFormu))
		=FPUTS(nfop,objFun.PutTag("MENUTYPE",THIS.MENUtype))
		=FPUTS(nfop,objFun.PutTag("LASTMOD",this.TRaduToc(lcRvf)))
		
		lcval=IIF(xnTipo=2,"FOXBIN","ORIGINAL")
		
		SELECT gmenu
		SCAN
		
			gamenu[1,1]=TRIM(raiz)
			gamenu[2,1]=TRIM(barra)
			gamenu[3,1]=TRIM(menu)
			gamenu[4,1]=TRIM(smenu1)
			gamenu[5,1]=TRIM(smenu2)
			nlevel=0
			FOR i=1 TO ALEN(gamenu,1)
				IF EMPTY(gamenu[i,1])
					EXIT
				ENDIF
				=FPUTS(NFOP,REPLICATE(CHR(9),I-1)+"<"+GAMENU[I,1]+">")
				nLevel=nLevel+1
			NEXT
			nlines=ALINES(gaMemos,EVALUATE(lcVal),5)
		*	nLevel=nLevel-1	
			FOR I=1 TO NLINES
				=FPUTS(nfop,REPLICATE(CHR(9),nLevel-1)+gaMemos[i])
			NEXT
				
		
			*FOR I=ALEN(gamenu,1) TO 1 STEP -1
			FOR i=nLevel TO 1 STEP -1
				IF !EMPTY(gaMenu[i,1])
					=FPUTS(nfop,REPLICATE(CHR(9),i-1)+"</"+gamenu[i,1]+">")
				ENDIF
			NEXT
		ENDSCAN
		npp=ADDBS(_Screen.dtemp)+"pict.txt"
		nHand=FCREATE(npp)
		IF nPict#0
			*npath=ALINES(gaPath,xcWform,16,"\")
			npath=ALINES(gaPath,ADDBS(JUSTPATH(lcformu)),16,"\")	
			FOR bi=1 TO nPict
				=FPUTS(nhand,gaPicture[bi])
				DO case
					CASE LEFT(gaPicture[bi],6)=="..\..\"
						gaPicture[bi]=ADDBS(gapath[1])+SUBSTR(gapicture[bi],7)
					CASE LEFT(gaPicture[bi],3)=="..\"
						lcPath=""
						FOR xix=1 TO nPath-1
							lcPath=lcPath+gaPath[xix]
						NEXT
						gaPicture[bi]=lcPath+SUBSTR(gaPicture[bi],4)
				ENDCASE
				
		
				
			NEXT
			
			=FPUTS(nfop,"<PICTURE>")
			FOR BI=1 TO nPict
				=FPUTS(nfop,REPLICATE(CHR(9),1)+gaPicture[bi])
			NEXT
			=FPUTS(NFOP,"</PICTURE>")
		ENDIF
		=FCLOSE(nhand)
		
		
		
		=FPUTS(nfop,"</ANALIZE>")
		=FCLOSE(nfop)
		objFun=null
		IF lwrite
			xcfile=this.suredir(FCR)
			o = CREATEOBJECT("Shell.Application")
			o.ShellExecute("write.exe", '&fcr', "", "open", 1)
		ENDIF
	ENDPROC

	PROCEDURE parservcx
		lparameters xcWform,xlShowMethod,xlNoIncComm,xlGenXml,xlEmptyTag
		*****************************************************************
		* PROCEDURE gParserForm
		*****************************************************
		* Transporta a un archivo de lenguaje marcado 
		* el contenido de un formulario.scx de visual Fox
		*****************************************************
		* Convocatoria 
		* Thisform.Funmark1.gParseForm(cFormulario,;
		*				lMostrarMetodos_de_Usuario,;	
		*				lNoInclur *Comentarios,;
		*				lGenerar_Como_xml,;
		*               lMostrarTags_Vacías)
		******************************************************
		LOCAL i,lcFormu,xGenXml,cNaMetod,cNameProp,lHavProp,;
			lHavMetod,nfop,npuf,npif,lBandera,lUserProp,lUserMet,;
			lDataEnvi,lClosEnvi,nObj,nSpa,cQuit,dquit,;
			cCampo,lPut,lgPut,xcfile,fcr,;
			np,bi,no,ne,gu,gm,pa,lnCount,lWrite,nPict,lcExact,lcPicture,;
			nr,objFun
			
			
		objfun=NEWOBJECT("prsfun","clases\prssys.vcx")	
		lnCount=0
		lcExact=SET("EXACT")
		**************************************
		* Definiciones
		LOCAL ARRAY gaPicture(1)
		Store 0 to np,no,nObj,ne,gu,gm,nPict,nr
		pa=1
		nSpa=5
		cQuit=chr(10)+chr(13)
		dQuit=Chr(9)
		*****************************************
		
		if vartype(xcWform)#"C" OR empty(xcWform)
			RETURN
		ENDIF
		xcForm=Upper(alltrim(xcWform))
		if xcWform=="MARCADO.VCX"
			Messagebox("No puede analizar esta clase")
			return
		endif
		
		lWrite=.t.
		IF AT("<N>",xcwform)#0
			xcwform=ALLTRIM(STRTRAN(xcWForm,"<N>",""))
			lWrite=.F.
		ENDIF
		IF AT("<n>",xcwform)#0
			xcwform=ALLTRIM(STRTRAN(xcWForm,"<n>",""))
			lWrite=.F.
		ENDIF
		* Propiedades, Métodos y Eventos de un Formulario en Blanco
		* gaMember permite determinar para el objeto Form
		* si un Procedure es Nativo ó de Usuario
		* Corresponde a <NATIVE_PROCEDURE> ó <USER_PROCEDURE>
		oForm = CREATEOBJECT("Form")
		nMemb=AMEMBERS(gaMember, oForm, 1 )
		release oform
		for i=1 to alen(gaMember,1)
			gaMember[i,1]=Upper(alltrim(gaMember[i,1]))+"/"
		next
		
		* Arrays de Listado
		local Array gatom(7,3),gaPut(1),gaObj(1),;
			gaEnc(1),gaUser(1),gaUsMet(1),gaParnt(1,5),gadim(5),;
			gaREserved(1),gaParent(1,5)
			
		gaParent[pa,1]="Parent"
		gaParent[pa,2]="Name"
		gaParent[pa,3]="Class"
		gaParent[pa,4]="BaseClass"
		gaParent[pa,5]="ClassLibrary"
		
		*Tramoya
		STORE "" TO gaParent
		pa=0
			
		gatom[1,1]="Class"	   && Nombre de la Clase p.ej "CommandButton"
		gatom[2,1]="BaseClass" && Basado en p. ej. "CommandButton"
		gatom[3,1]="ClassLoc"  && Biblioteca p. ej. "\LIBS\MiClase"
		gatom[4,1]="ObjName"   && .Name del Objeto
		gatom[5,1]="Parent"    && Contenedor del Objeto
		gatom[6,1]="Methods"   && Métodos de Usuario del Objeto	
		gatom[7,1]="Ole2"
		*gatom[8,1]="Reserved3" && definiciones de propiedades, *métodos y ^Array
		for i=1 to alen(gatom,1)
			gatom[i,2]=""
			gatom[i,3]=""
		next
		lcPath=JUSTPATH(xcwform)
		lcExt=JUSTEXT(xcwform)
		lcName=JUSTSTEM(xcwform)
		IF EMPTY(lcExt)
			xcwform=xcwform+".vcx"
		ENDIF
		
		IF EMPTY(lcPath)
			lcFormu=iif(empty(this.DirFormu),lower(xcwform),addbs(this.DirFormu)+lower(xcWForm))
		ELSE
			lcFormu=xcwform
		ENDIF
		
		
		IF USED("OFORMU")
			SELECT OFORMU
			USE
		ENDIF
		if !file(lcFormu)
			Messagebox("No se encuentra &lcFormu",0,_screen.th_mensaje)
			return .F.
		ENDIF
		
		IF USED(lcName)
			Messagebox("Librería en uso")
			RETURN
		ENDIF
		
		
		lcRvf=this.rv_fdate(lcFormu,.t.)
		lxRvf=this.rv_fdate(lcformu,.f.)
		
		* Apertura del Formulario
		*USE (lcFormu) IN 0 alias oformu
		USE (lcFormu) IN 0 AGAIN ALIAS oformu
		
		SELECT oformu
		
		*	browse
		*	USE
		*	RETURN
		*********
		
		cNametod=iif(!empty(_Screen.dtemp),addbs(_Screen.dtemp),"")+"gMetod.txt"	&& Nombre archivo Metodos
		cNameProp=iif(!empty(_Screen.dtemp),addbs(_Screen.dtemp),"")+"gProper.txt" && Nombre archivo Properties
		cNameRes=iif(!empty(_Screen.dtemp),addbs(_Screen.dtemp),"")+"gReserv.txt" && Nombre archivo Properties
		
		if xlGenXml
			ne=this.Aadd(@gaEnc,ne,"<?xml version='1.0' encoding='ISO-8859-1'?>")
		ELSE
			ne=This.Aadd(@gaEnc,ne,"<? Not xml Form. Just Internal Market Language>")
		endif
		* Encabezado
		
		*	ne=This.Aadd(@gaEnc,ne,"<ANALIZE>")
		*	ne=This.Aadd(@gaEnc,ne,PmlTag(ttoc(dateTime()),"INFCREATED",.T.))
		*	ne=This.Aadd(@gaEnc,ne,PmlTag(lcFormu,"FORM",.T.))
		*	ne=This.Aadd(@gaEnc,ne,PmlTag(this.TRaduToc(lcRvf),"LASTMOD",.T.))
		*	ne=This.Aadd(@gaEnc,ne,PmlTag(objfun.qualifer2(xlShowMethod),"SHOWMETHOD",.T.))
		*	ne=This.Aadd(@gaEnc,ne,PmlTag(objfun.qualifer2(xlNoIncComm),"OMITCOMMENT",.T.))
		
		ne=This.Aadd(@gaEnc,ne,"<ANALIZE>")
		ne=This.Aadd(@gaEnc,ne,objFun.PutTag("INFCREATED",ttoc(dateTime())))
		ne=This.Aadd(@gaEnc,ne,objFun.PutTag("FORM",lcFormu))
		ne=This.Aadd(@gaEnc,ne,objFun.PutTag("LASTMOD",this.TRaduToc(lcRvf)))
		ne=This.Aadd(@gaEnc,ne,objFun.PutTag("SHOWMETHOD",objfun.qualifer2(xlShowMethod)))
		ne=This.Aadd(@gaEnc,ne,objFun.PutTag("OMITCOMMENT",objfun.qualifer2(xlNoIncComm)))
		
		SET EXACT ON
		select oformu
		SCAN FOR ALLTRIM(PLATFORM)=="WINDOWS"
			Store .f. to lHavMetod,lBandera,lHavProp,lUserProp
			DIMENSION gauser(1),gaUsMet(1)
			STORE 0 TO gu,gm
		
			lcClase=alltrim(chrtran(class,cQuit,""))
			if lDataEnvi AND  lcClase#"cursor"
				np=This.Aadd(@gaput,np,"</ENTORNO>")
				lClosEnvi=.t.
			endif	
			if !lClosEnvi
				if !lDataEnvi
					lDataenvi=iif(lcClase=="dataenvironment",.t.,.f.)
					if lDataEnvi
						np=This.Aadd(@gaput,np,"<ENTORNO>")
					ENDIF			
				endif
			else
				lDataEnvi=.f.
			endif
		
			for i=1 to alen(gatom,1)
				cCampo=gatom[i,1]
		
			*	IF Inlist(alltrim(lower(Evaluate(cCampo))),"cursor","form")
					if !empty(Properties)
						lHavProp=.t.
						Strtofile(Properties,cNameProp)
					endif
			*	endif
				if cCampo#"Methods"
					lcEval=Alltrim(Evaluate(cCampo))
					lcEval=ChrTRan(lcEval,cQuit,"")
					gatom[i,2]=lcEval
				else
					if !empty(Methods)
						lHavMetod=.t.
						Strtofile(Methods,cNametod)
					endif
				ENDIF
				
			next
			if !lDataEnvi
				loClassLoc=Proper(alltrim(chrtran(oformu.ClassLoc,cQuit,"")))
				loParent=Proper(alltrim(chrtran(oformu.Parent,cQuit,"")))
			*	bas=ascan(gaParent,loParent)
		
		
				
				pa=pa+1
				dimension gaparent(pa,5)
				gaParent[pa,1]=loParent
				gaParent[pa,2]=Proper(alltrim(chrtran(oformu.ObjName,cQuit,"")))
				gaParent[pa,3]=Proper(alltrim(chrtran(oformu.Class,cQuit,"")))
				gaParent[pa,4]=Proper(alltrim(chrtran(oformu.BaseClass,cQuit,"")))
				gaParent[pa,5]=loClassLoc
		*		loString=Proper(alltrim(chrtran(oformu.ObjName,cQuit,"")))+" en ";
		*			+Proper(alltrim(chrtran(oformu.parent,cQuit,"")))+" [";
		*			+Proper(alltrim(chrtran(oformu.Class,cQuit,"")))+" (";
		*			+Proper(alltrim(chrtran(oformu.BaseClass,cQuit,"")));
		*			+iif(!empty(loClassLoc)," de "+loClassLoc,"");
		*			+")]"
		*		nObj=This.Aadd(@gaObj,nObj,loString)	
				nObj=nObj+1	
				cSTring="OBJETO_"+LTRIM(STR(nObj))
				np=This.Aadd(@gaput,np,"<&cString>")
			endif
		*	if lcClase=="form"
				* antes ix=8 to 1
			*	for ix=3 to 1 step -1
					ix=3
					lcRvCampo="Reserved"+ltrim(str(ix))
					if !Empty(EVALUATE(LCRVCAMPO))
						Strtofile(&lcRvCampo,cNameRes)
						lnCount=lnCount+1
						lcOther=ADDBS(JUSTPATH(cNameRes))+JUSTSTEM(cNameres);
							+TRANSFORM(lnCount)+".txt"
						STRTOFILE(&lcRvCampo+CHR(13)+lcRvCampo,lcOther)
						zpuf=-1
						if GetFopen(cNameRes,@zpuf,.t.)
							lUserProp=.t.
							gu=This.Aadd(@gaUser,gu,space(nspa*1)+"<USER_PROPERTIES>")
							do while !feof(zpuf)
								lcReserv=fgets(zpuf,2048)
								lcReserv=ChrTran(lcReserv,cQuit,"")
								lcReserv=Proper(Alltrim(lcReserv))
								*lower(Strtran(lcReserv,chr(32),""))
								lnAt=At(chr(32),lcReserv)
								if lnAt#0
									lcReserv=Substr(lcREserv,1,lnAt)+"[";
										+Substr(lcReserv,lnAt+1)+"]"
								endif	
								do case
									case left(lcReserv,1)="^"
										lcReserv="ARRAY This."+Substr(lcReserv,2)
									case left(lcReserv,1)="*"
										*Procedure (M)
										lUserMet=.t.
										gm=this.Aadd(@gaUsMet,gm,Space(nspa*2);
											+"This."+Substr(lcReserv,2)+"()")
										lcReserv=""
									other
										lcReserv="This."+lcReserv
										*Propiedad de Usuario (P)
									
								endcase
								if !empty(lcReserv)
									gu=This.Aadd(@gaUser,gu,space(nspa*2)+lcReserv)
								endif
								
							enddo
							=fclose(zpuf)
							gu=This.Aadd(@gaUser,gu,space(nspa*1)+"</USER_PROPERTIES>")
						endif
					endif
		*		next
		*	endif
			
		
			for i=1 to alen(gatom,1)
				if gatom[i,1]#"Methods"
					lgdot=iif(!empty(gatom[i,2]) OR xlEmptyTag,.t.,.f.)
					if lgdot
		
						np=This.Aadd(@gaput,np,Space(nSpa)+objFun.PutTag(gatom[i,1],gatom[i,2]) )
					endif
					if lHavProp
						np=This.Aadd(@gaput,np,space(nspa*1)+"<PROPERTIES>")
						
						npuf=-1
						if GetFopen(cNameProp,@npuf,.t.)
							do while !Feof(npuf)
								cGetProp=fgets(npuf,2048)
								cGetProp=ChrTran(cGetProp,cQuit,"")
								IF AT("Picture =",cGetProp)#0
									lcPicture=ALLTRIM(SUBSTR(cGetProp,AT("=",cGetProp)+1))
									IF ASCAN(gaPicture,lcPicture)=0
										nPict=nPict+1
										DIMENSION gaPicture(npict)
										gaPicture[nPict]=lcPicture
									ENDIF
									
								ENDIF
								
								cGetTry=lower(Strtran(cGetProp,chr(32),""))
								nat=at("=",cGetTry)
								lgput=.t.
								if nat#0
									cGEtTry=left(cGetTry,nat)
									lgPut=!inlist(cGetTry,"top","left","width","height")
								endif
								if lgPut		
									np=This.Aadd(@gaput,np,space(nspa*2)+cGetProp)
								endif
							enddo
							=fclose(npuf)
						endif
						np=This.Aadd(@gaput,np,space(nspa*1)+"</PROPERTIES>")
						lHavProp=.f.
					endif
					if lUserProp AND  gu#0
						for ix=1 to alen(gaUser)
							np=This.Aadd(@gaput,np,gaUser[ix])
						next
						lUserProp=.f.
					endif
					if lUserMet AND  gm#0
						np=this.Aadd(@gaput,np,space(nspa*1)+"<USER_METHODS>")
						FOR ix=1 to alen(gaUsMet)
							np=this.Aadd(@gaput,np,gaUsMet[ix])
						next
						np=this.Aadd(@gaput,np,space(nspa*1)+"</USER_METHODS>")
						lUserMet=.f.
					endif
				else
					if lHavMetod
						np=This.Aadd(@gaput,np,space(nSpa*1)+"<METHODS>")
						if xlShowMethod
							NPIF=-1
							if GetFopen(cNaMetod,@npif,.t.)
								cStrProc="PROCEDURE"
								do while !feof(npif)
									lPuts=.t.
									cGets=trim(fgets(npif,2048))
									cGets=ChrTran(cGets,cQuit,"")
									if Empty(cGets)
										lPuts=.f.
									endif
									if lPuts AND  xlNoIncComm
										lPuts=iif(At("*", Alltrim( chrTran(cGets,dquit,"")))=1,.F.,.T.)
									endif
									if lPuts
										if at("PROCEDURE",Alltrim( chrTran(cGets,dquit,"")))=1
											
											if lBandera
												np=This.Aadd(@gaput,np,Space(nspa*2)+"</&cStrProc>")
											endif									
											if lcClase=="form"
												meGets=Upper(alltrim(cGets))
												meGets=alltrim(Strtran(meGets,"PROCEDURE"))
												lNative=iif(ascan(gaMember,Upper(alltrim(MEGets))+"/")#0,.t.,.f.)
												cStrProc=iif(lNative,"NATIVE_PROCEDURE","USER_PROCEDURE")
											endif	
		
											np=This.Aadd(@gaput,np,Space(nSpa*2)+"<&cStrProc>")
		
											lBandera=.t.
										endif
		
										if xlGenXml
											np=This.Aadd(@gaput,np, Space(nSpa*3)+objFun.PutTag("LINE",cGets) )
										else
											np=This.Aadd(@gaput,np, space(nSpa*3)+cGets )
										endif
									endif
								enddo
								=fclose(nPif)
								*
								np=This.Aadd(@gaput,np,Space(nspa*2)+"</&cStrProc>")
							endif
						else
							np=This.Aadd(@gaput,np,Space(nspa*3)+PmlTag("OMITED","Methods"))
						endif
						np=This.Aadd(@gaput,np,space(nSpa*1)+"</METHODS>")
					endif
				
				endif
			
			next
			if !lDataEnvi	
				np=This.Aadd(@gaput,np,"</&cString>")
			endif
			
			
		ENDSCAN
		nr=this.aadd(@gaReserved,nr,"<COMMENT>")
		SCAN FOR ALLTRIM(PLATFORM)=="COMMENT"
			nr=this.aadd(@gaReserved,nr,CHR(9)+"<"+ALLTRIM(UNIQUEID)+">")
			lcObjName=TRIM(objName)
			IF !EMPTY(lcObjName)
				nr=This.aadd(@gaREserved,nr,objFun.PutTag("OBJNAME",lcObjName,2))
			ENDIF
			
			FOR J=3 TO FCOUNT()
				lcField=field(j)
				IF lcField=="OBJNAME"
					LOOP
				ENDIF
				lcVal=EVALUATE(lcField)
				lcChar=""
				IF VARTYPE(lcVal)="C"
					FOR xi=1 TO LEN(lcval)
						lcChar=lcChar+TRANSFORM(ASC(SUBSTR(lcval,xi,1)))+","
					NEXT
					lcChar=LEFT(lcChar,LEN(lcchar)-1)
					lcVal=CHRTRAN(lcval,CHR(10),CHR(28))
				ENDIF
				IF !EMPTY(lcVal)
					nr=This.aadd(@gaREserved,nr,objFun.PutTag(lcField,lcVal,2))
					IF !EMPTY(lcChar)
						nr=This.Aadd(@gaReserved,nr,objFun.PutTag(lcField+"_TrueChar",lcchar,2))
					ENDIF
					
				ENDIF
			NEXT
			nr=this.aadd(@gaReserved,nr,CHR(9)+"</"+ALLTRIM(UNIQUEID)+">")
		ENDSCAN
		nr=this.aadd(@gaReserved,nr,"</COMMENT>")
		select oformu
		use
		np=This.Aadd(@gaput,np,"</ANALIZE>")
		
		* Crear en bajo nivel archivo de listado.
		fcr=iif(!empty(_Screen.dtemp),addbs(_Screen.dtemp),"")+JustStem(lcFormu)+iif(xlGenXml,".xml",".txt")
		nfop=fcreate(fcr)
		* Escribe
		if ne#0
			for bi=1 to alen(gaEnc)
				=fputs(nfop,gaEnc[bi])
			next
		endif
		if nObj#0
			=fputs(nfop,"<OBJETOS>")
		
			* Tamaño de las columnas del informe
			* Repara elementos vacíos.
			
			Store 0 to gadim
			for di=1 to alen(gaparent,1)
				for dj=1 to alen(gaParent,2)
					DO case
						CASE dj=1
							gaParent[di,dj]=objFun.PutTag("Parent",EVL(gaparent[di,dj],"_Root"))
						CASE dj=2
							gaParent[di,dj]=objFun.PutTag("Name",gaparent[di,dj])
						CASE dj=3
							gaParent[di,dj]=objFun.PutTag("Class",gaparent[di,dj])
						CASE dj=4
							gaParent[di,dj]=objFun.PutTag("BaseClass",gaparent[di,dj])
						CASE dj=5
							gaParent[di,dj]=objFun.PutTag("ClassLibrary",EVL(gaparent[di,dj],"VFPBase"))
					ENDCASE
					
			
					gadim[dj]=MAX(gadim[dj],len(gaParent[di,dj]))		
		
				next
			next
			* ordena gaParent * AScendente
			this.arraytocursor(@gaParent,"PEPA")
			IF USED("PEPA")
				SELECT PEPA
				INDEX ON CAMPO1+CAMPO2+CAMPO3 TAG IPEPA
				SET ORDER TO ipepa
				this.cursortoarray("PEPA",@gaParent,.t.)		
			ELSE
				Asort(gaParent,1)
			ENDIF
		
			
			for di=1 to alen(gaparent,1)
				cInput=""
				FOR dj=1 TO ALEN(gaParent,2)
					cINput=cINput+PADR(gaParent[di,dj],gadim[dj]," ")+" "
				NEXT
				=FPUTS(nfop,CHR(9)+cInput)
			next
			=fputs(nfop,"</OBJETOS>")	
		ENDIF
		IF nPict#0
			*npath=ALINES(gaPath,xcWform,16,"\")
			npath=ALINES(gaPath,ADDBS(JUSTPATH(xcWform)),16,"\")	
			FOR bi=1 TO nPict
				IF LEFT(gaPicture[bi],3)=="..\"
					lcPath=""
					FOR xix=1 TO nPath-1
						lcPath=lcPath+gaPath[xix]
					NEXT
					
					gaPicture[bi]=lcPath+SUBSTR(gaPicture[bi],4)
				ENDIF
			NEXT
			
			=FPUTS(nfop,"<PICTURE>")
			FOR BI=1 TO nPict
				=FPUTS(nfop,REPLICATE(CHR(9),1)+gaPicture[bi])
			NEXT
			=FPUTS(NFOP,"</PICTURE>")
		ENDIF
		IF nr#0
			FOR bi=1 TO ALEN(gaReserved)
				=FPUTS(nfop,gaReserved[bi])
			NEXT
		ENDIF
		
		if np#0
			for bi=1 to alen(gaput)
				=fputs(nfop,gaput[bi])
			next
		endif
		
		=FCLOSE(NFOP)
		objfun=null
		SET EXACT &lcExact
		IF lWrite
			xcfile=this.suredir(FCR)
			o = CREATEOBJECT("Shell.Application")
			o.ShellExecute("write.exe", '&xcfile', "", "open", 1)
		ENDIF
		
	ENDPROC

	PROCEDURE pdifmnu
		LPARAMETERS xobjInf
		LOCAL nd,nHandles,fcr,nNew,nOri,nas,ns,i,objfun
		objfun=NEWOBJECT("prsfun","clases\prssys.vcx")
		
		fcr=ADDBS(dserv)+JUSTSTEM(xobjInf.fileo)+"_comp.txt"
		*"mnucomp.txt"
		nHandles=FCREATE(fcr)
		=FPUTS(nHandles,objFun.PutTag("ORIGINAL",xobjInf.Fileo))
		=FPUTS(nHandles,objFun.PutTag("FOXBIN",xObjInf.Filew))
		=FPUTS(nHandles,objFun.PutTag("MENUTYPE",THIS.MENUtype))
		nd=0
		ns=0
		LOCAL ARRAY gadifmen(1,3),gasumDif(1),gaOriginal(1),gaFoxbin(1)
		LOCAL ARRAY gadMenu(5,2)
		*STORE "" TO gadMenu
		gadMenu[1,2]="RAIZ"
		gadMenu[2,2]="BARRA"
		gadMenu[3,2]="MENU"
		gadMenu[4,2]="SMENU1"
		gadMenu[5,2]="SMENU2"
		SELECT gmenu
		SCAN
			STORE 0 TO nd,ns
			DIMENSION gadifmen(1,3),gaSumdif(1)
			STORE .f. TO gasumdif
			nOri=ALINES(gaOriginal,CHRTRAN(Original,CHR(9),""))
			nNew=ALINES(gaFoxbin,CHRTRAN(Foxbin,CHR(9),""))
			DO CASE
				CASE nOri=nNew
					FOR i=1 TO nOri
						IF gaOriginal[i] # gaFoxbin[i]
							lcSuma=gaOriginal[i]+"#"+gaFoxbin[i]
							IF ASCAN(gaSumDif,lcsuma)=0
								ns=ns+1
								DIMENSION gaSumDif[ns]
								gaSumDif[ns]=lcsuma
								
								nd=nd+1
								DIMENSION gadifmen[nd,3]
								gadifmen[nd,1]=PADL("Ori=New",10)
								gadifmen[nd,2]=gaOriginal[i]
								gaDifmen[nd,3]=gaFoxbin[i]
							ENDIF
							
						ENDIF
					NEXT
					
				CASE nOri>nNew
					FOR i=1 TO nOri
						nas=ASCAN(gaFoxBin,gaOriginal[i])
						IF nas=0
							nd=nd+1
							DIMENSION gadifmen[nd,3]
							gadifmen[nd,1]=PADL("Ori>New",10)
							gadifmen[nd,2]=gaOriginal[i]
							gaDifmen[nd,3]=""				
						
						ENDIF
					NEXT
						
			
				OTHERWISE
					FOR i=1 TO nNew
						nas=ASCAN(gaOriginal,gaFoxBin[i])
						IF nas=0
							nd=nd+1
							DIMENSION gadifmen[nd,3]
							gadifmen[nd,1]=PADL("Ori<New",10)
							gadifmen[nd,2]=""
							gaDifmen[nd,3]=gaFoxBin[i]		
						
						ENDIF
					NEXT
			ENDCASE
				
			IF nd#0
			
		*		=FPUTS(nHandles,TRIM(raiz)+" "+TRIM(barra)+" "+TRIM(menu)+" "+TRIM(sMenu1))
				gadMenu[1,1]=TRIM(raiz)
				gadMenu[2,1]=TRIM(barra)
				gadMenu[3,1]=TRIM(menu)
				gadMenu[4,1]=TRIM(smenu1)
				gadMenu[5,1]=TRIM(smenu2)
				nlevel=0
				FOR i=1 TO ALEN(gadMenu,1)
					IF EMPTY(gadMenu[i,1])
						EXIT
					ENDIF
					=FPUTS(nHandles,REPLICATE(CHR(9),I-1)+"<"+gadMenu[I,1]+">")
					nLevel=nLevel+1
				NEXT
				FOR i=1 TO nd
					=FPUTS(nHandles,REPLICATE(CHR(9),nLevel-1)+gaDifmen[i,1];
					+","+EVL(gadifmen[i,2],"<empty/>");
					+","+EVL(gadifmen[i,3],"<empty/>"))
		
		*			+" , "+gaDifmen[i,2]+" , "+gadifmen[i,3])
		
				NEXT
		
		*		FOR I=ALEN(gadMenu,1) TO 1 STEP -1
				FOR i=nLevel TO 1 STEP -1
					IF !EMPTY(gadMenu[i,1])
						=FPUTS(nHandles,REPLICATE(CHR(9),i-1)+"</"+gadMenu[i,1]+">")
					ENDIF
				NEXT
		
				
			ENDIF
				
		ENDSCAN
		=FCLOSE(nHandles)
		objfun=null
		SELECT gmenu
		USE
		
	ENDPROC

	PROCEDURE readfoxbin		&& Leer un archivo base 2 de Foxbinprg (Fernando Bozzo)
		LPARAMETERS xcFile,xnProc,xdbfile
		* xcFile= Ruta\archivo.ext a analizar
		* xnProc= 0 (original) 1=Nuevo
		IF EMPTY(xnProc) OR VARTYPE(xnProc)#"N"
			xnProc=0
		ENDIF
		
		LOCAL lcRoot,lcFile,objFun,lcREsult,lcExact,i,;
			nfop,nHand,lcStore,lcRep,nFun,lcExact,;
			lInit,lAddObj,lDefineClass,lcGet,;
			dbFile,dbName,lcDefine,lcVal,;
			lcRempla
			
		lcRempla=IIF(xnProc=0,"ORIGINAL","FOXBIN")
		
		
		nfop=-1
		IF !getfopen(xcFile,@nfop,.f.,12)
			RETURN
		ENDIF
		*dbFile=ADDBS(dserv)+"cur"+JUSTSTEM(xcFile)+".dbf"
		dbName=JUSTSTEM(xdbfile)
		
		IF xnProc=0
			IF USED(dbName)
				SELECT (dbName)
				USE
			ENDIF
		ENDIF
		IF !USED(dbName)
			CREATE TABLE &xdbfile FREE ;
			("TRYDEF" C(100),"ADDPROC" C(60),"ORIGINAL" M,;
			"FOXBIN" M,"COMPARA" M ,"SUMDEF" C(160),;
			"CALIF" L)
			SELECT (DBNAME)
			DELETE TAG ALL
			INDEX ON SUMDEF TAG ISUMDEF
		ENDIF
		
		
		STORE "" TO lcGet
		
		STORE .F. TO lInit,lAddObj,lDefineClass
		STORE "" TO lcDefine
		
		
		
		nHand=-1
		lcStore=ADDBS(_Screen.dtemp)+"fistore.txt"
		Lcrep=ADDBS(dserv)+"repchar.txt"
		nfup=FCREATE(lcrep)
		LcExact=SET("exact")
		SET EXACT ON
		
		DO WHILE !FEOF(nfop)
			lcGet=FGETS(nfop,4096)
			lcChar=""
			FOR i=1 TO 5
				lcChar=lcChar+TRANSFORM(ASC(SUBSTR(lcGet,i,1)))+","
			NEXT
			=FPUTS(nfup,lcChar+CHR(9)+LEFT(lcGet,60))
			IF EMPTY(lcGEt)
				LOOP
			ENDIF
			
		
			
		
			* Determina los chr(9) en el inicio de lcGet
			NCHR9=0
			FOR I=1 TO LEN(lcGet)
				IF SUBSTR(lcGet,i,1)#CHR(9)
					EXIT
				ENDIF
				nchr9=nChr9+1
			NEXT	
			DO case
				CASE nchr9=0
					DO CASE
						CASE LEFT(lcget,2)=CHR(32)+CHR(9)
							nHand=This.addtoFile(nHand,lcStore,SUBSTR(lcget,3))
						
						CASE LEFT(LCGET,1)="*"
							IF !lInit
								lInit=.t.
								lcVal="HEADER"
								IF !INDEXSEEK(LCVAL,.F.,DBNAME,"ISUMDEF")
									INSERT INTO (dbName) (trydef,sumdef) VALUES ("HEADER","HEADER")
								ELSE
									INDEXSEEK(lcval,.T.,DBNAME,"ISUMDEF")							
								ENDIF
							ENDIF
							nHand=This.addtoFile(nHand,lcStore,lcget)
						CASE LEFT(LCGET,LEN("DEFINE"))=="DEFINE"
							lDefineClass=IIF(AT("CLASS",LCGET)#0,.T.,.F.)
							lcDefine=lcGet
							LCVAL=LCDEFINE
							IF nHand# -1
								FCLOSE(nHand)
								SELECT (dbName)	
								replace (LcRempla) WITH FILETOSTR(lcstore)
								nHand=-1
							ENDIF
							IF !INDEXSEEK(lcVal,.f.,dbname,"ISUMDEF")
								INSERT INTO (dbName) (trydef,SUMDEF) VALUES (lcDefine,lcDefine)
							ELSE
								INDEXSEEK(lcval,.T.,DBNAME,"ISUMDEF")						
							ENDIF
							nHand=This.addtoFile(nHand,lcStore,lcget)
							
						CASE LEFT(LCGET,LEN("ENDDEFINE"))=="ENDDEFINE"
							IF nHand# -1
								FCLOSE(nHand)
								SELECT (dbName)	
								replace (LcRempla) WITH FILETOSTR(lcstore)
								nHand=-1
							ENDIF
							lDefineClass=.f.
							LcVal="ENDDEFINE "+lcDefine
							IF !INDEXSEEK(lcVal,.f.,dbname,"ISUMDEF")			
								INSERT INTO (dbName) (trydef,sumdef) VALUES (LcVal,lcVal)
							ELSE
								INDEXSEEK(lcval,.T.,DBNAME,"ISUMDEF")						
							ENDIF
							
							lcDefine=""	
							
					ENDCASE
					
				CASE nchr9=1
					lcGet=SUBSTR(lcGet,2)
					DO case
						CASE LEFT(lcGet,LEN("ADD OBJECT"))=="ADD OBJECT"
							IF nHand# -1
								FCLOSE(nHand)
								SELECT (dbName)	
								replace (LcRempla) WITH FILETOSTR(lcstore)
								nHand=-1
							ENDIF
							lcval=ALLTRIM(lcDefine)+ALLTRIM(CHRTRAN(lcGet,CHR(9),""))
							IF !INDEXSEEK(lcval,.f.,DBNAME,"ISUMDEF")
								INSERT INTO (dbName) (trydef,addproc,SUMDEF) VALUES (lcDefine,lcGet,lcval)
							ELSE
								INDEXSEEK(lcval,.T.,DBNAME,"ISUMDEF")						
							ENDIF
							
							nHand=This.addtoFile(nHand,lcStore,lcget)
							lAddObj=.t.
						CASE LEFT(lcGet,LEN("PROCEDURE"))=="PROCEDURE"
							IF lAddObj OR lDefineClass
								IF nHand# -1
									FCLOSE(nHand)
									SELECT (dbName)	
									replace (LcRempla) WITH FILETOSTR(lcstore)
									nHand=-1
								ENDIF					
							
							ENDIF
							lAddObj=.f.
							nHand=This.addtoFile(nHand,lcStore,lcget)
							lcval=ALLTRIM(lcDefine)+ALLTRIM(CHRTRAN(lcGet,CHR(9),""))
							IF !INDEXSEEK(lcval,.f.,DBNAME,"ISUMDEF")					
								INSERT INTO (dbName) (trydef,addproc,sumdef) VALUES (lcDefine,lcGet,lcval)	
							ELSE
								INDEXSEEK(lcval,.T.,DBNAME,"ISUMDEF")	
							ENDIF
							
						CASE LEFT(lcGet,LEN("ENDPROC"))=="ENDPROC"
							nHand=This.addtoFile(nHand,lcStore,lcget)
							IF nHand# -1
								FCLOSE(nHand)
								SELECT (dbName)	
								replace (LcRempla) WITH FILETOSTR(lcstore)
								nHand=-1
							ENDIF
						OTHERWISE
							nHand=This.addtoFile(nHand,lcStore,lcget)				
					ENDCASE
					
				OTHERWISE
					nHand=This.addtoFile(nHand,lcStore,lcget)
			ENDCASE
			
		ENDDO
		IF nHand# -1
			FCLOSE(nHand)
			SELECT (dbName)	
			replace (LcRempla) WITH FILETOSTR(lcstore)
			nHand=-1
		ENDIF	
		=FCLOSE(nfop)
		=FCLOSE(nfup)
		
		SET EXACT &lcExact
		
		*!*	SELECT (dbname)
		*!*	SET ORDER TO
		*!*	GO top
		*!*	BROWSE
		
	ENDPROC

	PROCEDURE rescueproy
		
		*!*	<FOLDERS>
		*!*		<FOLDER|C|=c:\archivos de programa\microsoft visual foxpro 9\ffc/>
		*!*		<FOLDER|C|=c:\archivos de programa\microsoft visual foxpro 9\wizards/>
		*!*		<FOLDER|C|=c:\archivos de programa\microsoft visual foxpro 9\wizards\graphics/>
		*!*		<FOLDER|C|=c:\theodore/>
		*!*		<FOLDER|C|=c:\theodore\forms/>
		*!*		<FOLDER|C|=c:\theodore\graphics/>
		*!*		<FOLDER|C|=c:\theodore\libs/>
		*!*		<FOLDER|C|=c:\theodore\menus/>
		*!*		<FOLDER|C|=c:\theodore\progs/>
		*!*	</FOLDERS>
		*!*	<COUNT>
		*!*		<K_Form scx|N|=971/>
		*!*		<V_Library vcx|N|=44/>
		*!*		<P_Program prg|N|=12/>
		*!*		<M_Menú mnx|N|=8/>
		*!*		<x_Pictures|N|=1447/>
		*!*		<i_Icons|N|=1/>
		*!*		<H_Project pjx|N|=1/>
		*!*		<T_Include h|N|=8/>
		*!*		<D_App_dbf|N|=1/>
		*!*		<W_Wizards|N|=1/>
		*!*	</COUNT>
		*!*	<LET|C|=H,T,D,V,M,P,x,W,K,i/>
		
		*!*	<Proyecto|C|=c:\theodore\theodore.pjx/>
		*!*	<MainProg|C|=THEODORE_APP/>
		*!*	<Type|C|=D/><Name|C|=c:\theodore\theodore_app.dbf/><Key|C|=THEODORE_APP/><TrueName|C|=theodore_app.dbf/><Exclude|L|=.F./>
		
		*!*	<Type|C|=D/>
		*!*	<Name|C|=c:\theodore\theodore_app.dbf/>
		*!*	<Key|C|=THEODORE_APP/>
		*!*	<TrueName|C|=theodore_app.dbf/>
		*!*	<Exclude|L|=.F./>
		
		LPARAMETERS xcFolderBack
		LOCAL lcfile,lnHand,lnfop,lOPenREg,objFun,i,lcPath,;
			lCopiar,lExclude,lGenPrs,lcForce,lcSourcePath,;
			lcFullProy,lcpathProy,lcParte,i,j,ns,np
		
		STORE "" TO lcPathProy
			
		
			
		lcPath=FULLPATH("")
		CD &xcFolderBack
		lcFile=GETFILE("txt")
		CD &lcpath
		IF EMPTY(lcFile)
			RETURN
		ENDIF
		lcSourcePath=JUSTPATH(lcFile)
		lnHand=FOPEN(lcfile)
		IF lnHand<0
			MESSAGEBOX("No se pudo abrir el archivo &lcfile")
			
			RETURN
		ENDIF
		
		LOCAL loCnv AS c_foxbin2prg OF "FOXBIN2PRG.PRG"
		loCnv = NEWOBJECT("c_foxbin2prg",ADDBS(_Screen.dprog)+"FOXBIN2PRG.PRG")
		LOCAL ARRAY gapath(1),gaPart(1)
		
		
		objFun=NEWOBJECT("Prsfun","clases\prssys.vcx")
		*!*	fcr=ADDBS(dapli)+"genresc.txt"
		*!*	lnFop=FCREATE(fcr)
		lnPas=0
		DO WHILE !FEOF(lnHand)
			lcGet=CHRTRAN(FGETS(lnHand,4096),CHR(9),"")
			IF lcGet=="</REG>"
				lOpenREg=.f.
				LOOP
			ENDIF
			
			IF lcget=="<REG>"
				lOpenREg=.t.
				LOOP
				
			ENDIF
		*!*	<Proyecto|C|=c:\theodore\theodore.pjx/>
		*!*	<MainProg|C|=THEODORE_APP/>
			IF LEFT(lcGet,LEN("<Proyecto|C|="))=="<Proyecto|C|="
				lcFullProy=objFun.GetValtag(lcGet)
				lcPathProy=LOWER(JUSTPATH(lcFullProy))
			ENDIF
			
			IF lOpenREg
				lnLines=ALINES(gaLines,lcGet,16,">")
				FOR i=1 TO lnlines
					lcType=objFun.GetValtag(gaLines[1])
					lcname=LOWER(objFun.GetValtag(gaLines[2]))
					lcKey=objFun.getValTag(gaLines[3])
					lExclude=objFun.getValTag(gaLInes[4])
				NEXT
				IF AT("microsoft visual foxpro",lcName)#0
					LOOP
				ENDIF
				lcForce=""
				lCopiar=.f.
				lGenPrs=.f.
				lExclude=.f.
				*H,T,D,V,M,P,x,W,K,i
				DO case
					CASE lcType="H"	&& pjx
						lcForce="pj2"
					CASE lcType="T"	&& h (include file)
						* Copiar
						lCopiar=.t.
					CASE lcType="D"	&& tabla _app
						lGenPrs=.t.
						* Copiar o generar con prsfile
					CASE lcType="V" && vcx
						lcForce="vc2"
					CASE lcType="M"	&& mnx
						lcForce="mn2"
					CASE lcType="P"	&& prg
						* copiar
						lCopiar=.t.
					CASE lcType="x" && pictures
						* copiar
						lCopiar=.t.
					CASE lctype="W"	&& wizards (excluir)
						* Excluir
						lExclude=.t.
					CASE lcType="K"	&& form
						lcForce="sc2"
					CASE lcType="i"	&& icons
						* copiar
						lCopiar=.t.
					CASE lcType="R"	&& reports
						lcForce="fr2"
				
				ENDCASE
				IF lExclude
					LOOP
				ENDIF
				DO case
					CASE LEFT(lcName,LEN(lcPathProy))==lcPathProy
						lcParte=STRTRAN(lcName,lcpathProy)
						DO WHILE LEFT(lcparte,1)="\"
							lcParte=SUBSTR(lcParte,2)
						ENDDO
						lcSourcefile=ADDBS(lcSourcePath)+lcParte				
						
					OTHERWISE
						*<Name|C|=c:\theodore\asientalcan.bmp/>
						*xcFolderBack
						* lcSourcePath=c:\temp\proyectos\theoplus
						ns=ALINES(gaPath,LOWER(lcSourcePath),1,"\")
						np=ALINES(gaPart,lcName,1,"\")
						lcSourceFile=""
						lcParte=""
						FOR j=1 TO ns-1
							lcSourceFile=lcSourceFile+gaPath[j]+"\"
						NEXT
						FOR j=2 TO np
							lcParte=lcParte+gaPart[j]+"\"
						NEXT
						lcparte=LEFT(lcParte,LEN(lcParte)-1)
						lcSourceFile=lcSourceFile+lcParte
		*!*					MESSAGEBOX("lcSourcePath="+lcSourcePath+CHR(13);
		*!*						+"lcParte="+lcParte+CHR(13);
		*!*						+"LcSourceFile="+lcSourcefile)
		*!*					LOOP
						
						
				ENDCASE
				
		
		
				lcPath=JUSTPATH(lcName)
				IF !DIRECTORY(lcPath)
					MD &lcPath
				ENDIF
				
				IF !EMPTY(lcForce)
					WAIT WINDOW "Generando binarios: "+lcName AT 12,15 NOWAIT 
					lcSourceFile=FORCEEXT(lcSourceFile,lcForce)
					lcName=FORCEEXT(lcName,lcForce)
					COPY FILE &lcSourceFile TO &lcName
					IF FILE(lcName)
						loCnv.Ejecutar( lcName )
					
					ENDIF
					
				ENDIF
				IF lGenPrs
					*LPARAMETERS xcFile,xcClaveId,xcProceso,xlCopete,xlItSelf,xcRoot
					lcSourcefile=FORCEEXT(lcSourceFile,"prs")
					WAIT WINDOW "Generando prs..." AT 12,15 NOWAIT 
					objFun.GEnCursor(lcSourcefile,,,,.t.,JUSTPATH(lcName))
				
				ENDIF		
				
				IF lCopiar
					WAIT WINDOW "Copiando "+lcSourceFile+"..." AT 12,15 NOWAIT 
					COPY FILE &lcSourceFile TO &lcName
				ENDIF
		
				
					
		*!*	<Type|C|=D/>
		*!*	<Name|C|=c:\theodore\theodore_app.dbf/>
		*!*	<Key|C|=THEODORE_APP/>
		*!*	<TrueName|C|=theodore_app.dbf/>
		*!*	<Exclude|L|=.F./>		
				
				
			ENDIF
			
		ENDDO
		WAIT CLEAR 
		=FCLOSE(lnHand)
		*!*	=FCLOSE(lnFop)
		loCnv=null
		objFun=null
		
		
		
	ENDPROC

	PROCEDURE rv_fdate
		LPARAMETERS xcfile,xlCadena
		***********************************
		* Retorna la fecha y hora de mod del archivo xcfile
		* Ftime devuelve un formato HH:MM:SS AM/PM EN FORMATO CARACTER
		* Si la hora es 12:00:01 devuelve PM
		LOCAL cValRet,nAdd,ntime,kdate,ktime
		ktime=REPLICATE("0",6)
		kDate=REPLICATE("0",8)
		nAdd=0
		Store "0" to cValRet
		if file(xcFile)
			TRY
				LOCAL LOEX AS Exception
				kdate=dtos(fdate(xcfile,0))
				ktime=ftime(xcfile)
				nAdd=0
				IF VARTYPE(ktime)="C"
					if At("PM",ktime)#0
						if left(ktime,2)#"12"
							nadd=120000
						endif
					ENDIF
		
					if At("AM",ktime)#0
						if left(ktime,2)=="12"
							nadd=-120000
						endif
					endif	
		
					ktime=This.FonlyDigit(ktime)
					nTime=Val(kTime)+nAdd
					kTime=PADL(TRANSFORM(nTime),6,"0")
				endif	
				cValret=kdate+ktime	
			CATCH TO LOEX
				LOEX.UserValue=PROGRAM()
				this.ShowError(loex)
			FINALLY
			
			ENDTRY
			
		endif
		RETURN iif(xlCAdena,cValRet,Val(cValREt))
	ENDPROC

	PROCEDURE selbackup
		LPARAMETERS xcRoot,xcDapli,xcFolderBack,xlOnlyProy
		IF VARTYPE(xcRoot)#"C" OR EMPTY(xcRoot)
			xcRoot=FULLPATH("")
		ENDIF
		IF EMPTY(JUSTEXT(xcRoot)) AND !DIRECTORY(xcRoot)
			xcRoot=FULLPATH("")
		ENDIF
		
		
		IF VARTYPE(xcDapli)#"C" OR EMPTY(xcDapli) OR !DIRECTORY(xcDapli)
			xcDapli=FULLPATH("")
		ENDIF
		
		LOCAL lcRoot,lcFile,nt,ncol,i,j,lcPut,lcPreRoot,;
			lcInto,fcr,ndir,lcdir,lcMain,objFun
		LOCAL ARRAY gaRaconto(11,3),gaDirs(1)
		
		objFun=NEWOBJECT("prsfun","clases\prssys.vcx")
		STORE 0 TO nDir
		
		gaRaconto[1,1]=[K]
		gaRaconto[2,1]=[V]
		gaRaconto[3,1]=[P]
		gaRaconto[4,1]=[M]
		gaRaconto[5,1]=[x]
		gaRaconto[6,1]=[i]
		gaRaconto[7,1]=[H]
		gaRaconto[8,1]=[T]
		gaRaconto[9,1]=[D]
		gaRAconto[10,1]=[W]
		gaRaconto[11,1]=[R]
		
		gaRaconto[1,2]=[Form scx]
		gaRaconto[2,2]=[Library vcx]
		gaRaconto[3,2]=[Program prg]
		gaRaconto[4,2]=[Menú mnx]
		gaRaconto[5,2]=[Pictures]
		gaRaconto[6,2]=[Icons]
		gaRaconto[7,2]=[Project pjx]
		gaRaconto[8,2]=[Include h]
		gaRaconto[9,2]=[App_dbf]
		gaRaconto[10,2]=[Wizards]
		gaRaconto[11,2]=[Reports]
		
		FOR i=1 TO ALEN(gaRaconto,1)
			gaRaconto[i,3]=0
		NEXT
		
		lcRoot=xcRoot
		lcExten=JUSTEXT(lcRoot)
		
		IF EMPTY(lcExten) OR UPPER(lcExten)#"PJX"
			CD &lcRoot
			lcFile=GETFILE("PJX")
			CD &xcdapli
			IF EMPTY(lcfile)
				RETURN
			ENDIF
		ELSE
			lcFile=lcroot
		
		ENDIF
		
		lcproy=upper(sys(16))
		if upper(lcfile)==upper(sys(16))
			MESSAGEBOX("Puede elegir cualquier proyecto, excepto "+Lower(sys(16)),0,_screen.th_mensaje)
			RETURN
		ENDIF
		SET EXACT ON
		
		
		nCol=5
		LOCAL ARRAY gatem(1,nCol),gaLet(1)
		STORE 0 TO nt,nlet
		
		lcAlias=JUSTSTEM(lcFile)
		lcRoot=LOWER(JUSTPATH(lcfile))
		
		
		
		ndir=1
		gaDirs[1]=LOWER(lcRoot)
		IF RIGHT(lcRoot,1)="\"
			lcRoot=LEFT(lcRoot,LEN(lcroot)-1)
		ENDIF
		lcPreRoot=JUSTPATH(lcRoot)
		
		
		
		
		
		USE (lcfile) IN 0
		SELECT (lcAlias)
		
		lcMain=""
		LOCATE FOR mainprog
		IF FOUND()
			lcMain=ALLTRIM(key)
		ENDIF
		*BROWSE
		
		SCAN 
			IF ASCAN(galet,type)=0
				nLet=nLet+1
				DIMENSION gaLet(nlet)
				gaLet[nlet]=type
			ENDIF
			nrac=ASCAN(gaRaconto,type)
			IF nRac#0
				gaRaconto[nrac+2]=gaRaconto[nrac+2]+1
			ELSE
				ndim=ALEN(gaRaconto,1)+1
				DIMENSION gaRaconto(ndim,3)
				gaRaconto[ndim,1]=type
				gaRaconto[ndim,2]="Tipo Desconocido"
				gaRaconto[ndim,3]=1
			ENDIF
			nt=nt+1
			lcName=ALLTRIM(objFun.TextoPlano(name))
			lcInto=""
			DO case
				CASE LEFT(lcName,LEN("..\..\"))="..\..\"
					lcInto=JUSTPATH(lcPreRoot)+SUBSTR(lcName,LEN("..\..\")+1)
				CASE LEFT(lcName,3)="..\"
					lcInto=ADDBS(lcPreRoot)+SUBSTR(lcName,4)
				CASE SUBSTR(lcName,2,1)==":"
					lcInto=lcName
				CASE LEFT(lcName,2)=="\\"
					lcINto=lcName
				OTHERWISE
					lcInto=ADDBS(lcRoot)+lcName
			ENDCASE
			
			
			IF !EMPTY(lcInto)
				lcDir=LOWER(JUSTPATH(lcInto))
				IF ASCAN(gaDirs,lcDir)=0
					ndir=ndir+1
					DIMENSION gadirs(ndir)
					gadirs[ndir]=lcDir
				ENDIF
			ENDIF
			
			DIMENSION gatem(nt,nCol)
			gatem[nt,1]=objfun.PutTag("Type",Type)
			gatem[nt,2]=objfun.PutTag("Name",lcInto)
			gatem[nt,3]=objfun.PutTag("Key",ALLTRIM(key))
			GATEM[nt,4]=objfun.PutTag("TrueName",lcname)
			gatem[nt,5]=objfun.Puttag("Exclude",Exclude)
		ENDSCAN
		USE
		
		This.arraytocursor(@gaTem,"PEPA")
		IF USED("PEPA")
			SELECT PEPA
			INDEX ON CAMPO1+CAMPO2+CAMPO3 TAG IPEPA
			SET ORDER TO ipepa
			This.cursortoarray("PEPA",@gaTem,.t.)		
		ELSE
			Asort(gaTem,1)
		ENDIF
		
		
		fcr=ADDBS(xcdapli)+JUSTSTEM(lcfile)+"_proy.txt"
		nfop=FCREATE(fcr)
		=FPUTS(nfop,objFun.PutTag("Proyecto",lcFile))
		=FPUTS(nfop,objFun.PutTag("MainProg",lcMain))
		=FPUTS(nfop,"<REG>")
		FOR i=1 TO ALEN(gatem,1)
			lcPut=""
			FOR j=1 TO ALEN(gatem,2)
				lcPut=lcpUt+gatem[i,j]
			NEXT
			=FPUTS(nfop,CHR(9)+lcPut)
		NEXT
		=FPUTS(NFOP,"</REG>")
		lcLet=""
		FOR i=1 TO nLet
			lcLet=lcLet+galet[i]+","
		NEXT
		=FPUTS(nfop,objFun.PutTag("LET",LEFT(lcLet,LEN(lcLet)-1)))
		=FPUTS(nfop,"<FOLDERS>")
		IF ndir>1
			ASORT(gaDirs)
		ENDIF
		FOR I=1 TO NDIR
			=FPUTS(nfop,objFun.PutTag("FOLDER",gaDirs[i],1))
		NEXT
		=FPUTS(nfop,"</FOLDERS>")
		=FPUTS(nfop,"<COUNT>")
		FOR I=1 TO ALEN(gaRaconto,1)
			=FPUTS(nfop,objFun.PutTag(gaRaconto[i,1]+"_"+gaRaconto[i,2],gaRaconto[i,3],1))
		NEXT
		=FPUTS(nfop,"</COUNT>")
		
		
		=FCLOSE(nfop)
		
		SET EXACT OFF
		objfun=null
		IF !xlOnlyProy
			This.getbackup(fcr,xcFolderBack)
		ENDIF
		
		
		
	ENDPROC

	PROCEDURE showerror
		LOCAL lcMens
		lcMens="Fecha "+TRANSFORM(DATETIME());
			+CHR(13)+"Mensaje: "+objExcep.message;
			+CHR(13)+"ErrorNo: "+TRANSFORM(objExcep.Errorno);
			+CHR(13)+"Llamada: "+objExcep.Uservalue 
		
		STRTOFILE(lcMens+CHR(13),"ThError.log",1)
		lcMens="Se ha producido un error:"+chr(13)+lcMens
		IF !xlNotShow
			MESSAGEBOX(lcMens,0,"Error del Sistema")
		ENDIF
		
	ENDPROC

	PROCEDURE suredir
		LPARAMETERS cNameDir
		****************************
		* Evita la falla de ciertos comandos como CD
		* por rutas que contienen espacios
		*********************************************
		* Versión 11/01/2013
		*********************************************
		cNameDir=alltrim(cNameDir)
		cAdd=[']
		IF LEFT(cNameDir,1)$['"]
			cNamedir=SUBSTR(cnamedir,2)
		ENDIF
		IF RIGHT(cNameDir,1)$['"]
			cNameDir=SUBSTR(cNamedir,1,LEN(cNameDir)-1)
		ENDIF
		lHavSymbol=IIF(AT(['],cNameDir)#0,.t.,.f.)
		if At(Chr(32),cNameDir)#0
			cNameDir=IIF(lHavSymbol,"["+cNameDir+"]",cAdd+cNameDir+cAdd)
		ENDIF
		return cNameDir
	ENDPROC

	PROCEDURE teldecim
		LPARAMETERS xcnNUmero,xnPrecision
		*****************************************
		* Determina la cantidad de decimales de un número.
		* xnPrecision podría ser Entre 10 y 16
		* 16 daría una precisión mayor pero válida para
		* números con alta cantidad de decimales.
		*********************************************
		local i_,minumero,pnumero,cRest,nDecimales
		if vartype(xnprecision)#"N"
			xnPrecision=10
		endif
		kevar=Vartype(xcnNumero)
		do case
			case kevar="C"
				minumero=val(xcnNumero)
			case kevar$'NI'
				Minumero=xcnNumero
			other
				return 0
		endcase
		if minumero=0
			return 0
		endif
		nDecimales=16
		for i_=0 to 16
			pNumero=Round(MiNumero*10**i_,xnPrecision)
			cRest=pNumero-Int(pNumero)
			nDecimales=i_
			if Round(cRest,xnPrecision)=0
				exit
			endif
		next
		return nDecimales
		
	ENDPROC

	PROCEDURE testmessage
		IF !PEMSTATUS(_Screen,"th_mensaje",5)
			ADDPROPERTY(_screen,"th_mensaje","Mensaje del Sistema")
		ENDIF
	ENDPROC

	PROCEDURE tradutoc		&& Convierte String fecha AAAAMMDDHHMMSS en un formato legible
		lparameters xcString
		**************************************************
		* a partir de un string "AAAAMMDDhhmmss"
		* devuelve un formato legible: dd/mm/aaaa hh:mm:ss
		***************************************************
		local lcAno,lcMes,lcDia,lcHora,lcMin,lcSeg,nlen,lcRet
		if empty(xcString)
			return ""
		endif
		lcREt=""
		nlen=len(xcString)
		if nlen<8
			return ""
		endif
		lcAno=Left(xcString,4)
		lcMes=Substr(xcString,5,2)
		lcDia=Substr(xcString,7,2)
		Store "" to lcHora,lcMin,lcSeg
		
		do case
			case nlen=10
				lcHora=Substr(xcString,9,2)
			
			case nlen=12
				lcHora=Substr(xcString,9,2)	
				lcMin=Substr(xcString,11,2)
			case nlen=14
				lcHora=Substr(xcString,9,2)	
				lcMin=Substr(xcString,11,2)
				lcSeg=Right(xcString,2)		
		endcase
		with this
		lcREt=PADL(lcDia,2,"0")+"/";
			+PADL(lcMes,2,"0")+"/";
			+PADL(lcAno,4,"0")+" ";
			+PADL(lcHora,2,"0")+":";
			+PADL(lcMin,2,"0")+":";
			+PADL(lcSeg,2,"0")
		endwith
		RETURN lcRet
	ENDPROC

	PROCEDURE writeerror
		LPARAMETERS xcTexto
		lcFile=ADDBS(_Screen.Dapli)+"ThFoxbin_err.txt"
		STRTOFILE(xcTexto,lcfile,1)
	ENDPROC

ENDDEFINE

DEFINE CLASS gcheck AS checkbox 
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	Alignment = 0
	AutoSize = .T.
	BackStyle = 0
	Caption = ""
	FontSize = 8
	Height = 16
	Name = "gcheck"
	Value = .F.
	Width = 18

ENDDEFINE

DEFINE CLASS gedit AS editbox 
 	*< CLASSDATA: Baseclass="editbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	BorderColor = 114,136,141
	DisabledBackColor = 242,247,243
	DisabledForeColor = 0,0,0
	FontSize = 8
	Height = 53
	Name = "gedit"
	ScrollBars = 0
	SpecialEffect = 1
	Width = 100
	
	PROCEDURE Destroy
		IF PEMSTATUS(_screen,"ObjCopy",5)
			_screen.objcopy=null
			REMOVEPROPERTY(_screen,"ObjCopy")
		ENDIF
		IF PEMSTATUS(_screen,"ofrmCopy",5)
			_screen.oFrmCopy=null
			REMOVEPROPERTY(_screen,"oFrmCopy")
		ENDIF
		IF PEMSTATUS(thisform,"gmenu1",5)
			thisform.RemoveObject("gMenu1")
		ENDIF
	ENDPROC

	PROCEDURE Init
		IF !PEMSTATUS(thisform,"gmenu1",5)
			thisform.NewObject("gmenu1","gmenu","clases\thmenu.vcx","",.t.)
		ENDIF
		
		
	ENDPROC

	PROCEDURE RightClick
		thisform.gmenu1.gCopyPaste(thisform,this)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS glab AS label 
 	*< CLASSDATA: Baseclass="label" Timestamp="" Scale="Pixels" Uniqueid="" />

	AutoSize = .T.
	BackStyle = 0
	Caption = "gLabel1"
	FontSize = 8
	Height = 16
	Name = "glab"
	Width = 40

ENDDEFINE

DEFINE CLASS glist AS listbox 
 	*< CLASSDATA: Baseclass="listbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	AutoHideScrollbar = 1
	BorderColor = 114,136,141
	FontSize = 8
	Height = 170
	Name = "glist"
	SpecialEffect = 1
	Width = 100

ENDDEFINE

DEFINE CLASS gmarco AS shape 
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	BackColor = 231,237,234
	BorderColor = 114,136,141
	Height = 21
	Name = "gmarco"
	Width = 100

ENDDEFINE

DEFINE CLASS gtext AS textbox 
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	BorderColor = 114,136,141
	DisabledBackColor = 242,247,243
	DisabledForeColor = 0,0,0
	FontSize = 8
	Height = 21
	Name = "gtext"
	SpecialEffect = 1
	Width = 100
	
	PROCEDURE Click
		IF EMPTY(this.value)
			this.SelStart=0
		ENDIF
	ENDPROC

	PROCEDURE DblClick
		IF EMPTY(this.value)
			this.SelStart=0
		ENDIF
	ENDPROC

	PROCEDURE GotFocus
		IF EMPTY(this.value)
			this.SelStart=0
		ENDIF
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ntext AS textbox 
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	Alignment = 3
	BorderColor = 114,136,141
	DisabledBackColor = 220,228,224
	DisabledForeColor = 0,0,0
	FontSize = 8
	Format = "Z"
	Height = 21
	InputMask = "999,999,999.99"
	Name = "ntext"
	SpecialEffect = 1
	Value = 0
	Width = 85

ENDDEFINE

DEFINE CLASS prsfun AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addcntparam
		*m: addcntprop
		*m: addtable
		*m: addtagtofile
		*m: closetemp
		*m: detectempty
		*m: gencursor
		*m: genprs
		*m: genscript
		*m: genscriptdir
		*m: getfopen
		*m: getvaltag
		*m: gexcel
		*m: gscript
		*m: gscriptform
		*m: gstandalone
		*m: gtablastru
		*m: invertirnumero
		*m: keletra
		*m: managediff
		*m: model
		*m: netuse
		*m: opentemp
		*m: pmltag
		*m: printproof
		*m: puttag
		*m: qualifer
		*m: qualifer2
		*m: quitcntparam		&& Quitar una barra de parámetros
		*m: quitcntprop
		*m: redmemory
		*m: scrache
		*m: showerror
		*m: teldecim
		*m: testmessage
		*m: textoplano
		*m: toexcel
		*m: trycopy
		*m: unpackprs
		*m: validtext
		*m: wokupas
		*p: separdat
		*a: gashut[1,0]
	*</DefinedPropArrayMethod>

	Name = "prsfun"
	separdat = .F.
	Width = 30
	
	PROCEDURE addcntparam
		LPARAMETERS xoform,xlSetFocus,xlNotDim
		LOCAL ocontrol,lnCnt,lnTop,lcObj,lci,i,lnHeight
		lnCnt=0
		lnHeight=0
		lntop=4
		FOR EACH ocontrol IN xoform.controls
			IF oControl.baseclass="Container"
				lnCnt=lnCnt+1
				lntop=lnTop+oControl.Height-2
			ENDIF
		ENDFOR
		
		IF lnCnt+1>26
			MESSAGEBOX("Ha alcanzado el límite permitido de parámetros",0,"AddParam Message")
			RETURN lnCnt
		ENDIF
		lnCnt=lnCnt+1
		lci=TRANSFORM(lnCnt)
		lcObj="oCnt"+lci
		xoform.newObject(lcObj,"CntParam","clases\prssys.vcx")
		IF ALEN(objEmpty.gadob,1)<lnCnt
			DIMENSION objEmpty.gadob(lnCnt,3)
			FOR i=1 TO 3
				objEmpty.gadob[lnCnt,i]=""
			NEXT
		ENDIF
		objEmpty.CntCount=lnCnt
		WITH xoForm.&lcObj.
			.top=lntop
			.left=4
			.visible=.t.
			lnWid=.width
			lnHeight=.Height
			.gtext1.ControlSource='objEmpty.gadob[&lci,1]'
			.cmbdir1.ControlSource='objEmpty.gadob[&lci,2]'
			.gtext2.ControlSource='objEmpty.gadob[&lci,3]'	
			.cmbdir1.refresh
			.numbarra=lnCnt	
			.ntext1.value=lnCnt
			.glab3.enabled=IIF(xlNotDim,.f.,.t.)
			.glab3.mousepointer=IIF(xlNotDim,1,15)
			
		
		ENDWITH
		* Ajusta dimensiones del form
		IF !xlNotDim
			IF PEMSTATUS(xoform,"CmAceptar",5)
				WITH xoForm
					.Height=lntop+lnHeight+7+.CmAceptar.Height
					.Width=lnWid+8
					.Shapegen.Height=.Height-1
					.Shapegen.width=.width-1
					.CmAceptar.top=.Height-.cmAceptar.Height-3
					.CmAceptar.left=.Width-.CmAceptar.Width-3
					IF PEMSTATUS(xoform,"CmAgregar",5)	
						.cmAgregar.top=.CmAceptar.top
						.CmAgregar.left=.CmAceptar.left-.CmAgregar.width-1
					ENDIF
				ENDWITH
			ENDIF
			IF xlSetFocus
				xoForm.&lcObj..gText1.SetFocus
			ENDIF
		ENDIF
		
		
		RETURN lnCnt
		
		
	ENDPROC

	PROCEDURE addcntprop
		LPARAMETERS xoform,xlSetFocus,xlNotDim
		
		LOCAL ocontrol,lnCnt,lnTop,lcObj,lci,i,lnHeight,lnCols
		lnCnt=0
		lnHeight=0
		lntop=3
		FOR EACH ocontrol IN xoform.controls
			IF oControl.baseclass="Container" AND !INLIST(UPPER(oControl.name),"OCLOSE")
				lnCnt=lnCnt+1
				lntop=lnTop+oControl.Height-2
			ENDIF
		ENDFOR
		lnCols=ALEN(objEmpty.gadob,2)
		lnCnt=lnCnt+1
		lci=TRANSFORM(lnCnt)
		lcObj="oCnt"+lci
		xoform.newObject(lcObj,"CntEmpty","clases\prssys.vcx")
		
		IF ALEN(objEmpty.gadob,1)<lnCnt
			DIMENSION objEmpty.gadob(lnCnt,lnCols)
			FOR i=1 TO 2
				objEmpty.gadob[lnCnt,i]=""
			NEXT
			objEmpty.gadob[lnCnt,3]=0
		ENDIF
		
		objEmpty.CntCount=lnCnt
		
		TRY
			LOCAL loex as Exception
			
			WITH xoForm.&lcObj.
				.top=lntop
				.left=4
				lnWid=.width
				lnHeight=.Height
				.gtext1.ControlSource='objEmpty.gadob[&lci,1]'
				.gtext2.ControlSource='objEmpty.gadob[&lci,2]'	
				.gText1.enabled=EMPTY(objEmpty.gadob[lnCnt,1])
				.numbarra=lnCnt	
				.glab3.enabled=.t.
				.visible=.t.
		
				
			ENDWITH
		
		CATCH TO loex
			loex.UserValue=PROGRAM()
			this.showerror(loex)
		ENDTRY
		
			
		* Ajusta dimensiones del form
		
		IF xlnotDim
			xlSetFocus=.f.
		ENDIF
		
		WITH xoForm
			IF PEMSTATUS(xoForm,"oClose",5)
				.oClose.top=lnTop+LnHeight+1
				lnHeight=-20
				lntop=lntop+.oclose.Height
				.oclose.left=4
			ENDIF
			IF !xlNotDim
			
				.Height=lntop+lnHeight+7+.CmAceptar.Height
				.Width=lnWid+8
				IF PEMSTATUS(xoform,"CmAceptar",5)		
					.CmAceptar.top=.Height-.cmAceptar.Height-3
					.CmAceptar.left=.Width-.CmAceptar.Width-3
				ENDIF
			
				IF PEMSTATUS(xoform,"CmAgregar",5)	
					.cmAgregar.top=.CmAceptar.top
					.CmAgregar.left=.CmAceptar.left-.CmAgregar.width-1
				ENDIF
				.Shapegen.Width=.Width-1
				.Shapegen.Height=.Height-1
			ENDIF
			
		ENDWITH
			
		IF xlSetFocus
			xoForm.&lcObj..gText1.SetFocus
		ENDIF
		
		
		RETURN lnCnt
		
		
	ENDPROC

	PROCEDURE addtable
		LPARAMETERS xcTabla,xcRoot,xcAddInPrs
		IF EMPTY(xcTabla) 
			RETURN ""
		ENDIF
		IF EMPTY(xcAddInPrs) 
			RETURN ""
		ENDIF
		
		IF VARTYPE(xcRoot)#"C" OR EMPTY(xcRoot)
			xcRoot=_Screen.Dapli
		ENDIF
		
		
		LOCAL i,lnfields,lnTags,lnLevel,lni,lnHand,lcFile,;
			lcPath,lcAlias,lcMainTag,lcUser,lcTErm,;
			lcGet,ji,lnPas
		LOCAL ARRAY gaInfo(5,2),gaTable(1,2),gaStruc(4,2),;
			gaTagInfo(1,2),gaFields(1),	gaGen(1),gaPas(1)
		
		lcInfo=SYS(0)
		ALINES(gagInf,lcInfo,1,"#")
		lcTErm=gagInf[1]
		lcUser=gagInf[2]
		
		lcPath=JUSTPATH(xcTabla)
		IF EMPTY(lcPath)
			lcAlias=JUSTSTEM(xcTabla)
			IF !USED(lcAlias)
				MESSAGEBOX("Pasó un Alias pero no está abierta la tabla "+xcTabla)
				RETURN ""
			ENDIF
		ELSE
			lcAlias=JUSTSTEM(xcTabla)
			IF !USED(lcAlias)
				USE (xcTabla) IN 0 SHARED
			ENDIF
				
		ENDIF
		
		
		
		STORE "" TO gaTable
		lnLevel=1
		STORE 0 TO lni,lnPas,i,ji
		
		
		gaStruc[1,1]="FIELDS"
		gaStruc[2,1]="TYPES"
		gaStruc[3,1]="WIDTHS"
		gaStruc[4,1]="DECIMALS"
		FOR i=1 TO ALEN(gastruc,1)
			gastruc[i,2]=""
		NEXT
		
		
		SELECT (lcAlias)
		*<Estructura>
		lnFields=AFIELDS(gaFields,lcAlias)
		lnTags=ATAGINFO(gaTagInfo,lcAlias)
		FOR i=1 TO lnFields
			gaStruc[1,2]=gaStruc[1,2]+gaFields[i,1]+","
			gaStruc[2,2]=gaStruc[2,2]+gaFields[i,2]+","
			gaStruc[3,2]=gaStruc[3,2]+TRANSFORM(gaFields[i,3])+","
			gaStruc[4,2]=gaStruc[4,2]+TRANSFORM(gaFields[i,4])+","
		NEXT
		*</Estructura>
		
		*<InfoGen>
		gaInfo[1,1]="ROOT"
		gaInfo[1,2]=xcRoot
		gaInfo[2,1]="RECORDS"
		gaInfo[2,2]=RECCOUNT(lcAlias)
		gaInfo[3,1]="FIELDS"
		gaInfo[3,2]=lnfields
		gaInfo[4,1]="HEADER_SIZE"
		gaInfo[4,2]=HEADER(lcAlias)
		gaInfo[5,1]="TABLE_SIZE"
		gaInfo[5,2]=HEADER(lcAlias) + ( RECSIZE(lcAlias) * RECCOUNT(lcAlias) + 1)
		*</InfoGen>
		*LPARAMETERS xcClave,xcValor,xnLevel,xcForceType,xlNotype
		lni=lni+1
		DIMENSION gagen(lni)
		gagen[lni]=REPLICATE(CHR(9),lnLevel)+"<TABLE="+UPPER(lcAlias)+">"
		lnLevel=lnLevel+1
		FOR i=1 TO ALEN(gaInfo,1)
			lni=lni+1
			DIMENSION gaGen(lni)
			gaGen[lni]=this.puttag(gaINfo[i,1],gaInfo[i,2],lnLevel)
		NEXT
		lni=lni+1
		DIMENSION gagen(lni)
		gagen[lni]=REPLICATE(CHR(9),lnLevel)+"<STRUCTURE>"
		lnLevel=lnLevel+1
		FOR i=1 TO ALEN(gaStruc,1)
			lni=lni+1
			DIMENSION gagen(lni)	
			gaGen[lni]=this.puttag(gastruc[i,1],gaStruc[i,2],lnLevel)
		NEXT
		lnLevel=lnLevel-1
		lni=lni+1
		DIMENSION gagen(lni)
		gagen[lni]=REPLICATE(CHR(9),lnLevel)+"</STRUCTURE>"
		
		lni=lni+1
		DIMENSION gagen(lni)
		gagen[lni]=REPLICATE(CHR(9),lnLevel)+"<TAG_INFO>"
		IF lnTags>0
			lnLevel=lnLevel+1
			FOR i=1 TO lnTags
				lni=lni+1
				DIMENSION gagen(lni)
				gagen[lni]=REPLICATE(CHR(9),lnLevel);
					+This.PutTag("TAG_NAME",gaTagInfo[i,1]);
					+This.PutTag("TAG_TYPE",gaTagInfo[i,2]);
					+This.PutTag("TAG_KEY",gaTAgInfo[i,3]);
					+This.PutTag("TAG_FILTER",gaTagInfo[i,4]);
					+This.PutTag("TAG_ORDER",gaTagInfo[i,5]);
					+This.PutTag("TAG_COLLATE",gaTagInfo[i,6])		
			NEXT
			lnLevel=lnLevel-1
		ENDIF
		lni=lni+1
		DIMENSION gagen(lni)
		gagen[lni]=REPLICATE(CHR(9),lnLevel)+"</TAG_INFO>"
		lni=lni+1
		DIMENSION gagen(lni)
		gagen[lni]=REPLICATE(CHR(9),lnLevel)+"<REG>"
		lni=lni+1
		DIMENSION gagen(lni)
		gagen[lni]=REPLICATE(CHR(9),lnLevel)+"</REG>"
		
		lnLevel=lnLevel-1
		lni=lni+1
		DIMENSION gagen(lni)
		gagen[lni]=REPLICATE(CHR(9),lnLevel)+"</TABLE="+UPPER(lcAlias)+">"
		
		
		lcIniTag=CHRTRAN(gagen[1],CHR(9),"")
		lcEndTag=CHRTRAN(gagen[ALEN(gagen)],CHR(9),"")
		STORE .f. TO lOmit
		*xcAddInPrs
		IF FILE(xcAddInPrs)
			* guarda una copia
		*!*		lcStem=JUSTSTEM(xcAddInPrs)
		*!*		
		*!*		lcBack=JUSTPATH(xcAddInPrs)+lcStem+".bak"
		*!*		COPY FILE &xcAddinPrs TO &lcBack
			
			LOCAL ARRAY gaPas(1)
			LOCAL lnPas
			lnPas=0
			lnHand=-1
			IF this.getfopen(xcAddInPrs,@lnHand,.f.,0)
				DO WHILE !FEOF(lnHand)
					lcGet=FGETS(lnhand,8096)
		
					IF AT(lcIniTag,lcGEt)#0
						lOmit=.t.
					ENDIF
					IF !lOmit
						lnPas=lnPas+1
						DIMENSION gapas(lnPas)
						gapas[lnPas]=lcGet
					ENDIF
					IF AT(lcEndTag,lcGet)#0
						lOmit=.f.
					ENDIF			
				ENDDO
				=FCLOSE(lnHand)
			ENDIF
			IF lnPas#0
				*<Corrige Fecha y Hora>
				FOR i=1 TO ALEN(gapas)
					lcGet=CHRTRAN(gapas[i],CHR(9),"")
					IF LEFT(lcGet,LEN("</COPETE>"))=="</COPETE>"
						EXIT
					ENDIF
					IF LEFT(lcGet,LEN("<FECHA|D|="))="<FECHA|D|="
						gaPas[i]=This.PutTag("FECHA",DATE(),1)
					ENDIF
					IF LEFT(lcGet,LEN("<HORA|C|="))="<HORA|C|="
						gaPas[i]=This.PutTag("HORA",TIME(),1)
					ENDIF				
					IF LEFT(lcGet,LEN("<FILES|N|="))="<FILES|N|="
						gaPas[i]=This.PutTag("FILES",THIS.GETVAltag(LcGet)+1,1)
					ENDIF			
				NEXT
				
				lnHand=FCREATE(xcAddInPrs)
				FOR i=1 TO ALEN(gapas)
					=FPUTS(LnHand,gapas[i])
					IF LEFT(gapas[i],LEN("<TRANSDAT>"))=="<TRANSDAT>"
						
						FOR ji=1 TO ALEN(gaGen)
							=FPUTS(lnHand,gaGen[ji])
						NEXT
					ENDIF
				ENDFOR
				=FCLOSE(lnHand)						
			
			
			ENDIF
		ELSE
			lnHand=FCREATE(xcAddInPrs)
			=FPUTS(lnHand,"<COPETE>")
			lnLevel=1
			=FPUTS(lnHand,This.PutTag("PROCESO","TRANSDAT",lnLevel))
			=FPUTS(lnHand,This.PutTag("IDPROCESO","",lnLevel))
			=FPUTS(lnHand,This.PutTag("CLAVEID","",lnLevel))
			=FPUTS(lnHand,This.PutTag("NETUSER",LcTerm,lnLevel))
			=FPUTS(lnHand,This.PutTag("USER",LcUser,lnLevel))
			=FPUTS(lnHand,This.PutTag("FECHA",DATE(),lnLevel))
			=FPUTS(lnHand,This.PutTag("HORA",TIME(),lnLevel))
			=FPUTS(lnHand,This.PutTag("FILES",1,lnLevel) )
			=FPUTS(lnHand,This.PutTag("SEPARATOR",ASC(this.separdat),lnLevel))
			=FPUTS(lnHand,"</COPETE>")
		
			=FPUTS(lnHand,"<TRANSDAT>")	
				FOR ji=1 TO ALEN(gaGen)
					=FPUTS(lnHand,gaGen[ji])
				NEXT	
			=FPUTS(lnHand,"<PROCEDURE>")
		*!*	IF !EMPTY(xcProcedure) AND VARTYPE(xcProcedure)="C"
		*!*		np=ALINES(gaproc,xcProcedure)
		*!*		FOR i=1 TO np
		*!*			=FPUTS(lnHand,gaProc[i])
		*!*		NEXT
		*!*	endif
			=FPUTS(lnHand,"</PROCEDURE>")
			=FPUTS(lnHand,"<COMMENT>")
			=FPUTS(lnHand,"</COMMENT>")
			=FPUTS(lnHand,"</TRANSDAT>")		
			=FCLOSE(lnHand)		
		ENDIF
		
		
		*!*	LcFile=ADDBS(_Screen.dtemp)+"addtable.txt"
		*!*	lnHand=FCREATE(lcFile)
		*!*	FOR i=1 TO ALEN(gagen)
		*!*		=FPUTS(lnHand,gaGen[i])
		*!*	NEXT
		*!*	=FCLOSE(lnHand)
		RETURN xcAddInPrs
		
		
		
		*!*		<TABLE=VEHICULOS>
		*!*			<ROOT|C|=*ROOT_SERV*\DATOS/>
		*!*			<RECORDS|N|=0/>
		*!*			<FIELDS|N|=6/>
		*!*			<HEADER_SIZE|N|=488/>
		*!*			<TABLE_SIZE|N|=489/>
		*!*			<STRUCTURE>
		*!*				<FIELDS|C|=PATENTE,IDCLIEN,MARCA,MODELO,ANOFABRI,IMAGEN,/>
		*!*				<TYPES|C|=C,C,C,C,N,C,/>
		*!*				<WIDTHS|C|=7,4,30,40,4,80,/>
		*!*				<DECIMALS|C|=0,0,0,0,0,0,/>
		*!*			</STRUCTURE>
		*!*			<TAG_INFO>
		*!*				<TAG_NAME|C|=VMARCA/><TAG_TYPE|C|=REGULAR/><TAG_KEY|C|=MARCA/><TAG_FILTER|C|=/><TAG_ORDER|C|=ASCENDING/><TAG_COLLATE|C|=MACHINE/>
		*!*				<TAG_NAME|C|=VIDCLIEN/><TAG_TYPE|C|=REGULAR/><TAG_KEY|C|=IDCLIEN/><TAG_FILTER|C|=/><TAG_ORDER|C|=ASCENDING/><TAG_COLLATE|C|=MACHINE/>
		*!*				<TAG_NAME|C|=VPATENTE/><TAG_TYPE|C|=REGULAR/><TAG_KEY|C|=PATENTE/><TAG_FILTER|C|=/><TAG_ORDER|C|=ASCENDING/><TAG_COLLATE|C|=MACHINE/>
		*!*			</TAG_INFO>
		*!*			<REG>
		*!*			</REG>
		*!*		</TABLE=VEHICULOS>
		
		*!*		<TABLE=THFOXBIN_APP>
		*!*			<ROOT|C|=*ROOT_SERV*\DATOS/>
		*!*			<RECORDS|N|=8/>
		*!*			<FIELDS|N|=14/>
		*!*			<HEADER_SIZE|N|=776/>
		*!*			<TABLE_SIZE|N|=1497/>
		*!*			<STRUCTURE>
		*!*				<FIELDS|C|=DOC_TYPE,DOC_DESCR,DOC_EXEC,DOC_CLASS,DOC_NEW,DOC_OPEN,DOC_SINGLE,DOC_NOSHOW,DOC_WRAP,DOC_GO,DOC_NAV,ALT_EXEC,PROPERTIES,USER_NOTES,/>
		*!*				<TYPES|C|=C,C,M,M,L,L,L,L,L,L,L,M,M,M,/>
		*!*				<WIDTHS|C|=1,60,4,4,1,1,1,1,1,1,1,4,4,4,/>
		*!*				<DECIMALS|C|=0,0,0,0,0,0,0,0,0,0,0,0,0,0,/>
		*!*			</STRUCTURE>
		*!*			<TAG_INFO>
		*!*				<TAG_NAME|C|=DOC_OPEN/><TAG_TYPE|C|=REGULAR/><TAG_KEY|C|=DOC_OPEN/><TAG_FILTER|C|=/><TAG_ORDER|C|=ASCENDING/><TAG_COLLATE|C|=MACHINE/>
		*!*				<TAG_NAME|C|=DOC_NEW/><TAG_TYPE|C|=REGULAR/><TAG_KEY|C|=DOC_NEW/><TAG_FILTER|C|=/><TAG_ORDER|C|=ASCENDING/><TAG_COLLATE|C|=MACHINE/>
		*!*				<TAG_NAME|C|=DOC_DESCR/><TAG_TYPE|C|=REGULAR/><TAG_KEY|C|=DOC_DESCR/><TAG_FILTER|C|=/><TAG_ORDER|C|=ASCENDING/><TAG_COLLATE|C|=MACHINE/>
		*!*				<TAG_NAME|C|=DOC_TYPE/><TAG_TYPE|C|=REGULAR/><TAG_KEY|C|=DOC_TYPE/><TAG_FILTER|C|=/><TAG_ORDER|C|=ASCENDING/><TAG_COLLATE|C|=MACHINE/>
		*!*				<TAG_NAME|C|=ISDEL/><TAG_TYPE|C|=REGULAR/><TAG_KEY|C|=DELETED()/><TAG_FILTER|C|=/><TAG_ORDER|C|=ASCENDING/><TAG_COLLATE|C|=MACHINE/>
		*!*			</TAG_INFO>
		*!*			<REG>
		*!*			</REG>
		*!*		</TABLE=THFOXBIN_APP>
	ENDPROC

	PROCEDURE addtagtofile
		LPARAMETERS xcFile,xcTag,xlDelete
		*!*	Agregar o reemplazar una tag en un archivo plano
		*!* xlDelete permite eliminar la tag del archivo.
		*!*	-------------------------------------------------
		LOCAL lnTag,lcGet,lcTag,lnHand,lFound
		LOCAL ARRAY gatags(1)
		
		lnTag=0
		nAt=AT("|=",xctag)
		IF nat=0
			lcTag=LEFT(xcTag,AT("=",xcTag)-1)
		ELSE
			lcTag=LEFT(xcTag,nat+1)
		ENDIF
		
		IF !FILE(xcfile)
			* crear xcfile vacío
			lnHand=FCREATE(xcfile)
			=FCLOSE(lnHand)
		ENDIF
		
		*<Lectura y armado de Array>
		lnHand=FOPEN(xcfile,0)
		IF lnHand < 0
			MESSAGEBOX("No se pudo abrir &xcfile")
			RETURN
		ENDIF
		DO WHILE !FEOF(lnHand)
			lcGEt=FGETS(lnHand,2048)
			IF EMPTY(lcGet)
				LOOP
			ENDIF
			lntag=lnTag+1
			DIMENSION gaTAgs(lnTag)
			IF LEFT(lcGet,LEN(lcTag))==lcTag
				* reemplazo
				lFound=.t.
				gaTags[lnTag]=IIF(xlDelete,"",xcTag)
			ELSE
				gaTags[lnTag]=lcGet
			ENDIF
		ENDDO
		=FCLOSE(lnHand)
		*</Lectura y armado de Array>
		
		IF !xlDelete AND !lFound
			lnTag=lnTag + 1
			DIMENSION gaTAgs(lnTag)	
			gaTags[lnTag]=xcTag
		ENDIF
		
		
		*<Reemplazo>
		lnHand=FCREATE(xcFile)
		FOR i=1 TO ALEN(gaTAgs)
			IF !EMPTY(gaTags[i])
				=FPUTS(lnHand,gaTags[i])
			ENDIF
			
		NEXT
		=FCLOSE(lnhand)
		*</Reemplazo>
		RETURN 
		
	ENDPROC

	PROCEDURE closetemp
		RELEASE gashut
		ACOPY(this.gashut,gashut)
		local xfi
		for xfi=1 to alen(gashut)
			IF !EMPTY(gashut[xfi]) AND Used(gashut[xfi])
				select (gashut[xfi])
				USE
			ENDIF
		NEXT
		DIMENSION this.gashut(1)
		
	ENDPROC

	PROCEDURE detectempty
		LPARAMETERS xoEdit,xoProper
		LOCAL nl,i,nItem,ni,lcWords,np,j,lExit,lcString,;
			lcLastLine,lcEdit,LcExclude,npCount,lnlast
		npCount=PCOUNT()
		lcExclude=",CLOSE,EXECUTE,MSE_TITLE,MSE_EXPORT,MSE_COLUMNS,MSE_HEADERS,MSE_SUM,"
		
		LOCAL ARRAY gaString[2]
		gaString[1]=[NEWOBJECT("EMPTY")]
		gaString[2]=[NEWOBJECT('EMPTY')]
		
		STORE "" TO lcString,lcLastLine
		LOCAL ARRAY gaEdit(1),gaLin(1),gatem(1)
		
		nl=ALINES(gaEdit,UPPER(xoEdit.text))
		STORE 0 TO nItem,nw
		STORE "" TO lcWords
		FOR I=1 TO NL
			FOR j=1 TO ALEN(gaString)
				IF AT(gaString[j],gaEdit[i])#0
					lcSTring=gaString[j]
					nItem=i
					lExit=.t.
					EXIT
				ENDIF
			NEXT
			IF lExit
				EXIT
			ENDIF
		NEXT
		*!*	MESSAGEBOX("Buscado="+lcString+CHR(13);
		*!*		+"Lineas="+TRANSFORM(nl)+CHR(13);
		*!*		+"Founded="+TRANSFORM(nItem))
			
		IF EMPTY(nItem)
			RETURN ""
		ENDIF
		ni=ALINES(gaEmpty,gaEdit[nItem],1+4,"=")
		IF ni=2
			lcName=gaEmpty[1]
			lcLastLine="RETURN "+lcName
			lcTag="ADDPROPERTY("+LCNAME
			FOR I=1 TO nl
				lcGet=CHRTRAN(gaEdit[i],CHR(32),"")
				IF LEFT(lcGet,LEN(lcTag))==lctag
					*!*	Addproperty(loEmpty,"Gravado",ngra
					np=ALINES(gatem , CHRTRAN(lcGet,["()'],""),1,",")
					IF np>2 AND AT(","+gatem[2]+",",lcExclude)=0
						lcWords=lcWords + PROPER(gaTem[2]) + CHR(13)
					ENDIF
					
				ENDIF
			NEXT
			
		ENDIF
		IF npcount > 1
			xoProper.value=lcWords
		ENDIF
		lnLast=0
		FOR i=NL TO 1 STEP -1
			IF !EMPTY(gaEdit[i])
				lnLast=i
				EXIT
			ENDIF
		ENDFOR
		
		IF UPPER(gaEdit[lnLast]) # UPPER(lcLastLine)
			lcEdit=ALLTRIM(xoEdit.text)
			DO WHILE .t.
				IF INLIST(RIGHT(lcEdit,1),CHR(10),CHR(13))
					lcEdit=LEFT(lcEdit,LEN(lcEdit)-1)
				ELSE
					EXIT
				ENDIF
			ENDDO	
			DO WHILE RIGHT(lcEdit,1)=CHR(13)
				lcEdit=LEFT(lcEdit,LEN(lcEdit)-1)
			ENDDO
			xoEdit.Value = lcEdit + CHR(13) + lcLastLine + CHR(13)
			
		ENDIF
		
		RETURN lcName
		
		
		*!*	loEmpty=NewObject("Empty")
		*!*	Addproperty(loEmpty,"Gravado",ngra)
		*!*	Addproperty(loEmpty,"NoGravado",nNogra)
		*!*	addproperty(loEmpty,"Exento",nExe)
		*!*	addproperty(loEmpty,"Iva",nIva)
		*!*	addproperty(loEmpty,"Total",nTot)
		
		
		
	ENDPROC

	PROCEDURE gencursor
		LPARAMETERS xcFile,xcClaveId,xcProceso,xlCopete,xlItSelf,xcRoot
		* Construye un cursor a partir de un archivo *.prs
		* xcfile= "archivoTexto.prs"
		* -------------------------------------------------
		LOCAL nFap,nfop,fcr,ln,lnfiles,i,lnREcords,lReadStruc,;
			lcNameCur,lREadRec,lClosefap,lcGet,lcReturn,;
			lvClaveId,lvProceso,lCopete,lnCount,lnGen,;
			lcIdProceso,lcProceso,lcTagId,;
			LcHoraGen,ldFechaGen,lcterminal,;
			lctProceso,lctIdproc,lctFecha,lctHora,lctTermi,;
			lctSalon,lctIdCarga,lctBase,lctUser,lctNetUser,;
			lcUser,lcNetUser,lOkey,lTagINfo,lnti,lnEtiq,lnc,;
			lcSeparator,lcProcedure,lReadProc
		
		IF VARTYPE(xcRoot)#"C" OR EMPTY(xcRoot) OR !DIRECTORY(xcRoot)
			xcRoot=_Screen.dserv
		ENDIF
			
		lcSeparator=","
		STORE 0 TO lnFiles,ln,i,lnREcords,lnCount,lnGen,lnti,lnEtiq,lnc
		STORE "" TO lcNameCur,lcIdProceso,lcProceso,lcTagId,;
			LcHoraGen,lcterminal,;
			lctProceso,lctIdproc,lctFecha,lctHora,lctTermi,;
			lctSalon,lctIdCarga,lctBase,;
			lctNetUse,lctUser,lcNetUser,lcUser,lcProcedure
		
		STORE CTOD("") TO ldfechagen
		lOkey=.T.
			
		LOCAL ARRAY gaTablas(1,3),gaIndices(1),;
			gatypes(1),gaCampos(1),gaWids(1),gaDec(1),gaStruc(1)
			 
		STORE "" TO gaTablas
		fcr=ADDBS(_Screen.dtemp)+"transdat.txt"
		IF FILE(fcr)
			DELETE FILE &fcr
		ENDIF
		
		fcov=ADDBS(_Screen.Dapli)+"entrada\gencursor_cov.txt"
		*!*	nfup=FCREATE(fcov)
		
		lvClaveId=!EMPTY(xcClaveId)
		lvProceso=!EMPTY(xcProceso)
		nfop=-1
		IF !This.GetFopen(xcfile,@nfop,,12)
			RETURN
		ENDIF
		FSEEK(nfop,0,0)
		* lFlags: lCopete*copete, lReads, lTagInfo, lReadREc*Reg
		DO WHILE !FEOF(nFop)
			
			lcGet=FGETS(nfop,8192)
			lcGEt=ALLTRIM(CHRTRAN(lcGet,CHR(9),""))
		*!*		=FPUTS(nfup,lcGet)
			IF lcGet=="</TRANSDAT>"
		*!*			=FPUTS(nfup,"Salida por Transdat")
				EXIT
			ENDIF
			
			* Cancela estructura de tag
			IF LEFT(lcGet,2)="</"
		*!*			=FPUTS(nfup,"Cancela Tag "+lcGet)
				DO case
					CASE lcGet=="</REG>"
					* Cancela lectura de registros
						lREadRec=.f.
						IF lnRecords#lnCount
							MESSAGEBOX("Records en prsfile="+TRANSFORM(lnRecords)+CHR(13);
							+"Records procesados="+TRANSFORM(lnCount))
						ENDIF
						LOOP
						
		
					* CAncela lectura de tabla
					CASE LEFT(lcGEt,LEN("</TABLE="))=="</TABLE="
						IF USED(LcNameCur)
							SELECT (lcNameCur)
							DELETE TAG all
							FOR si=1 TO LnEtiq
								lcInd=gaIndices[si]
								&lcInd
							NEXT
						
							USE
							lnGen=lnGen+1
							gaTablas[lnGen,1]=lcNameCur
							gaTablas[lnGen,2]=lnRecords
							gaTablas[lnGen,3]=lnCount
						ENDIF
						* Limpieza
						STORE 0 TO lnRecords,lnCount,lnEtiq,lnc
						DIMENSION gaIndices(1),gastruc(1,4)
						STORE "" TO gaIndices									
						
						
						LOOP
					
					* Cancela lectura de etiquetas de indice					
					CASE lcGet=="</TAG_INFO>"
						lTagInfo=.F.
						LOOP
			
					* Cancela lectura de estructura y crea la tabla
					CASE lcGet=="</STRUCTURE>"
						lReadStruc=.f.
						dimension gastruc(lnc,4)
						FOR i=1 TO lnc
							gastruc[i,1]=gaCampos[i]
							gastruc[i,2]=gatypes[i]
							gastruc[i,3]=VAL(gaWids[i])
							gastruc[i,4]=VAL(gaDec[i])
						NEXT
						
						IF !EMPTY(lcNameCur)
							IF USED(lcNameCur)
								SELECT (lcNameCur)
								USE
							ENDIF
							lcCrea=ADDBS(xcRoot)+lcNameCur
							CREATE table &lcCrea FREE FROM ARRAY gastruc	
						ENDIF
						LOOP
						
					* Cancela lectura de copete
					CASE lcGet=="</COPETE>"
						lCopete=.f.
						IF xlCopete	&& cuando se pide solamente el copete (verificación)
							EXIT
						ELSE
							LOOP
						ENDIF
						
					* Cancela la lectura de Procedure
					CASE lcGet=="</PROCEDURE>"
						
						lcProcedure=LEFT(lcProcedure,LEN(lcProcedure)-1)
						IF !EMPTY(lcProcedure)
							EXECSCRIPT(lcProcedure,FORCEEXT(lcCREA,"dbf"))
						ENDIF
						lReadProc=.F.
						LOOP
				ENDCASE
			ENDIF
					
			DO case
				* Abre la lectura del copete	
				CASE lcGEt=="<COPETE>"
		*!*				=FPUTS(nfup,"Apertura de "+lcGet)
					lCopete=.t.		
					LOOP
				
				* inicia lectura de etiquetas de indices
				CASE lcGet=="<TAG_INFO>"
		*!*				=FPUTS(nfup,"Apertura de "+lcGet)
					lTAgInfo=.t.
					LOOP
				
				
				* inicia lectura de estrctura
				CASE lcGet=="<STRUCTURE>"
		*!*				=FPUTS(nfup,"Apertura de "+lcGet)		
					lReadStruc=.t.
					LOOP
		
				* inicia lectura de registros	
				CASE LCGET=="<REG>"
		*!*				=FPUTS(nfup,"Apertura de "+lcGet)
					lReadRec=.t.
					LOOP
				
				CASE lcGet=="<PROCEDURE>"
		*!*				=FPUTS(nfup,"Apertura de "+lcGet)
					lREadProc=.t.
					LOOP
			ENDCASE
			
			DO case
				CASE LEFT(lcGet,7)=="<TABLE="
		*!*				=FPUTS(nfup,"Detecta Nombre de tabla")
					lcFra=STREXTRACT(lcGet,"<",">")
					nl=ALINES(gaLines,lcFra,1,"=")
					IF nl=2
						lcNameCur=IIF(xlItSelf,"","cur")+gaLines[2]
					ENDIF
					WAIT WINDOW "Transdat "+gaLines[2]+"..." AT 12,20 nowait
					LOOP
				CASE LEFT(lcget,12)=="<RECORDS|N|="	
		*!*				=FPUTS(nfup,"Detecta cantidad de registros")
					lcFra=STREXTRACT(lcGet,"<","/>")
					nl=ALINES(gaLines,lcFra,1,"=")
					IF nl=2
						lnRecords=VAL(gaLines[2])
						WAIT WINDOW "Generando &lcNameCur con "+TRANSFORM(gaLines[2])+" registros..." AT 12,20 nowait
					ENDIF
					LOOP
			
			ENDCASE
			
			* LFLAGS
			
			DO CASE
				CASE lReadProc
					lcProcedure=lcProcedure+lcGet+CHR(13)
		*!*				=FPUTS(nfup,"lee una sentencia de procedure")	
				CASE lReadRec
					*habilitada la lectura de registros 
		*!*				=FPUTS(nfup,"lee un registro de la tabla")
				*gaTypes
					nf=ALINES(gaVals,lcGet,1,lcSeparator)
					FOR bix=1 TO nf
						lctom=gaVals[bix]
						lcty=gaTypes[bix]
						DO case
							CASE lcty$'CM'
								lcTom=SUBSTR(lcTom,2)
								gaVals[bix]=LEFT(lcTom,LEN(lctom)-1)
							CASE lcTy="D"
								gaVals[bix]=CTOD(lctom)
							CASE lcTy="L"
								gaVals[bix]=IIF(AT("T",LCtOM)#0,.T.,.F.)
							CASE LCTy$'IN'
								gaVals[bix]=VAL(lctom)
						ENDCASE
					NEXT
					INSERT INTO (lcNameCur) FROM ARRAY gaVals			
					lnCount=lnCount+1	
							
				* Lee estructura de índices
				CASE lTagInfo
		*!*				=FPUTS(nfup,"Lee estructura de índices")
					lnTi=ALINES(gaTagINf,lcGet,16,"/>")
					iTag=This.GetValTag(gaTAgInf[1])
					iTyp=This.GetValTag(gaTagInf[2])
					iKey=This.GetValTag(gaTAgInf[3])
					iFil=This.GetValTag(gaTagInf[4])
					iOrd=This.GetValTag(gaTAgInf[5])
					iCol=This.GetValTag(gaTAgInf[6])
					lnEtiq=lnEtiq + 1
					DIMENSION gaIndices(lnEtiq)
					gaindices[lnEtiq]="INDEX ON "+IKEY+" TAG "+ITAG
				
				* Lee estructura de tabla
				CASE lReadStruc	
		*!*				=FPUTS(nfup,"Lee estructura de tabla")
					lcFra=STREXTRACT(lcGet,"<","/>")
					nl=ALINES(gaLines,lcFra,1,"=")
					IF nl=2
						lcVal=gaLines[2]
						DO CASE
							CASE AT("<FIELDS|C|=",LCGET)#0
								lnc=ALINES(gaCampos,lcVal,5,",")
		*!*							=FPUTS(nfup,"lnc="+TRANSFORM(lnc))
							CASE AT("<TYPES|C|=",LCGET)#0
								lnt=ALINES(gaTypes,lcVal,5,",")
		*!*							=FPUTS(nfup,"lnt="+TRANSFORM(lnt))						
							CASE AT("<WIDTHS|C|=",LCGET)#0
								lnw=ALINES(gaWids,lcval,5,",")
		*!*							=FPUTS(nfup,"lnw="+TRANSFORM(lnw))						
							CASE AT("<DECIMALS|C|=",LCGET)#0
								lnd=ALINES(gaDec,lcVal,5,",")
		*!*							=FPUTS(nfup,"lnd="+TRANSFORM(lnd))			
						ENDCASE
					ELSE
		*!*					=FPUTS(nfup,"Falla de lReadStruc por nl="+TRANSFORM(nl))
					ENDIF
				
				* Lee copete de archivo
		*	<COPETE>
		*	<PROCESO|C|=TRANSDAT/>
		*	<IDPROCESO|C|=/>
		*	<CLAVEID|C|=/>
		*	<NETUSER|C|=DAVID/>
		*	<USER|C|=FIDEL/>
		*	<FECHA|D|=14/12/2013/>
		*	<HORA|C|=10:28/>
		*	<FILES|N|=1/>
		*	<SEPARATOR|N|=28/>
		*	</COPETE>		
				CASE lCopete	
		*!*				=FPUTS(nfup,"Lee registro de copete")
					DO CASE
						* Validación de Usuario
						CASE LEFT(lcGet,6)=="<CUIT|"
							lcFra=This.GetValTag(lcGet)
							lOkey=IIF(lcFra==MiCuitemp,.t.,.f.)
							IF !lOkey
								MESSAGEBOX("Cuit inválido",0,_screen.th_mensaje)
								EXIT
							ENDIF
		
						* Validación de Proceso		
						CASE LEFT(LCGET,9)=="<PROCESO|"
							lctProceso=lcGet
							lcProceso=This.GetValTag(lcGet)
							IF LVPROCESO
								IF lcProceso==xcProceso
									* Proceso Verificado
								ELSE
									lokey=.f.
									MESSAGEBOX("Descripción de proceso inválida",0,_screen.th_mensaje)
									EXIT
								ENDIF
							ENDIF
						
							
						CASE LEFT(LCGET,11)=="<IDPROCESO|"
							lctIdProc=lcGet
							LcIdproceso=This.GetValTag(lcGet)
							IF VARTYPE(lcIdproceso)="N"
								lcIdproceso=TRANSFORM(lcIdproceso)
							ENDIF
						
				
						CASE LEFT(LCGET,9)=="<CLAVEID|"
							lcClaveId=This.GetValTag(lcGet)
							IF LVCLAVEID
								IF lcClaveId==xcClaveId
									* OK
								ELSE
									MESSAGEBOX("No coincide la clave de identificación",0,_screen.th_mensaje)
									EXIT				
								ENDIF
							ENDIF
						
						
						* Cantidad de Files
						CASE LEFT(lcget,7)=="<FILES|"
						
							lnfiles=This.GetValTag(lcGet)
							IF lnFiles=0
								MESSAGEBOX("No hay tablas incluidas",0,_screen.th_mensaje)
								EXIT
							ENDIF
							DIMENSION gatablas(lnFiles,3)
							STORE "" TO gaTablas
				
						CASE LEFT(lcget,7)=="<FECHA|"
							lctFecha=lcGet
							ldFechagen=This.GetValTag(lcget)
						CASE LEFT(lcGet,6)=="<HORA|"
							lctHora=lcGet
							lcHoraGen=This.GetValTag(lcget)
							
						* Accesorias (válidas para Theodore)	
						CASE LEFT(Lcget,10)=="<TERMINAL|"
							lctTermi=lcGEt
							lcTerminal=This.GetValTag(lcGet)
						CASE LEFT(lcGet,7)=="<SALON|"
							lctSalon=lcGet
						CASE LEFT(lcget,9)=="<IDCARGA|"
							lctIdcarga=lcGet
						CASE LEFT(lcGet,6)=="<BASE|"
							lctBase=lcget
						CASE LEFT(LCGET,14)=="<SEPARATOR|N|="
							lcSeparator=CHR(This.GetValTag(lcGet))
						CASE LEFT(lcget,12)=="<NETUSER|C|="
							lctNetUser=lcGEt
							lcNetUser=This.GetValTag(lcGet)
						CASE LEFT(lcget,9)=="<USER|C|="
							lctUser=lcget
							lcUser=This.GetValTag(lcGet)
					ENDCASE
				
		
				
			ENDCASE
			
		ENDDO
		=FCLOSE(nfop)
		*!*	=FCLOSE(nfup)
		WAIT clear
		
		IF !lOkey
			RETURN ""
		ENDIF
		
		
		nfop=FCREATE(fcr)
		=FPUTS(nfop,This.PutTag("FILE",XCFILE))
		=FPUTS(nfop,lctProceso)
		=FPUTS(nfop,EVL(lctIdproc,"Empty"))
		=FPUTS(nfop,lctFecha)
		=FPUTS(nfop,lctUser)
		=FPUTS(nfop,lctNetUser)
		=FPUTS(NFOP,This.PutTag("FILES",lnFiles))
		IF !xlCopete AND lnFiles#0
			=FPUTS(nfop,"<TABLES>")
			FOR i=1 TO ALEN(gatablas,1)
				lcPut=CHR(9)+gaTablas[i,1]+",";
					+TRANSFORM(gaTAblas[i,2])+",";
					+TRANSFORM(gaTablas[i,3])
				=FPUTS(nfop,lcput)
			NEXT
			=FPUTS(NFOP,"</TABLES>")
		ENDIF
		=FCLOSE(nfop)
		
		RETURN fcr
		
		
	ENDPROC

	PROCEDURE genprs
		LPARAMETERS xcTextFile,xgapas,xcProceso,xcProcId,xcClaveId,xcProcedure
		EXTERNAL ARRAY XGAPAS
		* prsfun.genprs(cFileTexto,"MOVIM|*|.T.")
		* parametros
		* xcTextFile: Nombre archivo prs
		* Tabla madre|campos pass (o "*")|lcWhere"
		* GAPAS[1]="MOVIM|*|FECHA BETWEEN DIA1 AND DIA2"
		* xcProceso: Nombre del proceso, Default: Transdat
		* xcClaveId: Colocar una clave única de identificación. Defalut=""
		*******************************************************************
		LOCAL nHand,lcFile,lnfiles,LcCursor,lnLevel,lnTally,;
			xcWhere,lcAlias,xcListCampos,lcIdProceso,;
			xxhora,xxfegra,xxterm,lcDir,lcFileTab,lcRootTable,;
			lcInfo,lcTerm,lcUser,i
		lnLevel=0
		STORE "" TO lcRootTable,lcIdProceso
		LOCAL ARRAY gaproc(1)
		
		IF VARTYPE(xcProceso)#"C"
			xcProceso="TRANSDAT"
		ENDIF
		IF !VARTYPE(xcProcId)$"CN"
			xcProcId=""
		ENDIF
		
		
		IF VARTYPE(xcClaveId)#"C"
			xcClaveId=""
		ENDIF
		lcCursor="POPO"
		lnFiles=ALEN(xgaPas)
		
		LOCAL ARRAY gaterm(1)
		ALINES(gaTerm,SYS(0),5,"#")
		xxTerm=gaTerm[1]
		xxFegra=DATE()
		xxhora=LEFT(TIME(),5)
		
		LcDir=JUSTPATH(xcTextFile)
		xcTextFile=JUSTSTEM(xcTextFile)+".prs"
		LCFILE=ADDBS(lcDir)+xcTextfile
		
		lcInfo=SYS(0)
		ALINES(gagInf,lcInfo,1,"#")
		lcTErm=gagInf[1]
		lcUser=gagInf[2]
		
		
		vtexto=""
		nHand=FCREATE(lcfile)
		IF nHand < 0
			MESSAGEBOX("No se pudo crear "+lcFile+".",0,"Mensaje de GenPrs()")
			RETURN ""
		ENDIF
		
		=FPUTS(nHand,"<COPETE>")
		lnLevel=1
		=FPUTS(nHand,This.PutTag("PROCESO",xcProceso,lnLevel))
		=FPUTS(nHand,This.PutTag("IDPROCESO",xcProcId,lnLevel))
		=FPUTS(nHand,This.PutTag("CLAVEID",xcClaveId,lnLevel))
		=FPUTS(nHand,This.PutTag("NETUSER",LcTerm,lnLevel))
		=FPUTS(nHand,This.PutTag("USER",LcUser,lnLevel))
		=FPUTS(nHand,This.PutTag("FECHA",DATE(),lnLevel))
		=FPUTS(nHand,This.PutTag("HORA",TIME(),lnLevel))
		=FPUTS(nHand,This.PutTag("FILES",lnfiles,lnLevel) )
		=FPUTS(nHand,This.PutTag("SEPARATOR",ASC(this.separdat),lnLevel))
		=FPUTS(nHand,"</COPETE>")
		
		=FPUTS(nHand,"<TRANSDAT>")
		
		
		FOR bix=1 TO ALEN(xgaPas)
		
			lcSelect=""
			nTags=ALINES(gaTags,xgapas[bix],1,"|")
			IF nTags<3
				LOOP
			ENDIF
			
			*xcTabla=UPPER(gaTags[1])
			lcFileTab=UPPER(gatags[1])
			IF AT("\",lcFileTab)#0
				lcAlias=JUSTSTEM(lcFileTab)
				lcRootTable=JUSTPATH(lcFileTab)
			else	
				lcAlias=lcFiletab
			ENDIF
			
			xcListCampos=ALLTRIM(gatags[2])
			xcWhere=ALLTRIM(gatags[3])
			lcCursor=IIF(ALLTRIM(UPPER(xcWhere))==".T.",lcAlias,"POPO")
			
			
			IF !this.opentemp(lcFileTAb)
				LOOP
			ENDIF
			
			IF LcCursor=="POPO"
				IF USED("POPO")
					SELECT POPO
					USE
				ENDIF
		
				WAIT WINDOW "Generando un cursor » Tabla &lcAlias..." AT 12,20 nowait
		
				TEXT TO lcSelect NOSHOW TEXTMERGE PRETEXT 7
					SELECT <<xcListCampos>> FROM <<lcAlias>> WHERE <<xcWhere>> INTO CURSOR popo
				ENDTEXT
		
				&lcSelect
		
				lnTally=_Tally	
			ELSE
				lnTally=RECCOUNT(lcAlias)
			ENDIF
			
		
			* Derivar
			WAIT WINDOW "Escribiendo archivo TransDat con &lcAlias..." AT 12,20 nowait
			
			this.gTablastru(nHand,lcCursor,lcRootTable,lcAlias,lntally,lnLevel)
		NEXT
		WAIT clear
		=FPUTS(nHand,"<PROCEDURE>")
		IF !EMPTY(xcProcedure) AND VARTYPE(xcProcedure)="C"
			np=ALINES(gaproc,xcProcedure)
			FOR i=1 TO np
				=FPUTS(nHand,gaProc[i])
			NEXT
		endif
		=FPUTS(nHand,"</PROCEDURE>")
		=FPUTS(nHAND,"<COMMENT>")
		=FPUTS(nhand,"</COMMENT>")
		=FPUTS(nHand,"</TRANSDAT>")
		=FCLOSE(nHand)
		
		this.closetemp()
		THIS.REDmemory()
		
		RETURN lcFile
		
	ENDPROC

	PROCEDURE genscript
		LOCAL lCreate
		lCreate=.T.
		
		
		IF PEMSTATUS(_screen,"oFrmStand",5)
			IF VARTYPE(_screen.oFrmStand)="O"
				*_screen.oFrmStand.Release
				_Screen.oFrmStand.WindowState=2
				_Screen.oFrmStand.Show()
				lCreate=.F.
			ELSE
				_screen.oFrmStand=null	
			ENDIF
		
		ENDIF
		IF !lCreate
			RETURN
		ENDIF
		
		
		LOCAL fcr,nfop,LnTop,lnLeft,lnWindowState,;
			lnMinHei,lnMinWid,lnWidth,lnHeight,lcFolder
		
		TRY
			LOCAL loex as Exception
			lnTop=5
			lnLeft=20
			STORE 0 TO lnWindowState,lnHeight,lnWidth
			fcr=ADDBS(_Screen.Dapli)+"frmScript.txt"
			IF FILE(fcr)
				nfop= -1
				IF this.getFopen(fcr,@nfop,.f.,0)
					DO WHILE !FEOF(nfop)
						lcGet=UPPER(FGETS(nfop,2048))
						DO case
							CASE LEFT(lcget,LEN("<TOP|N|="))=="<TOP|N|="
								lntop=this.GetValTag(lcGet)	
							CASE LEFT(lcget,LEN("<LEFT|N|="))=="<LEFT|N|="
								lnLeft=this.GetValtag(lcGet)
							CASE LEFT(lcget,LEN("<WINDOWSTATE|N|="))=="<WINDOWSTATE|N|="
								lnWindowState=this.getvaltag(lcGet)	
								
							CASE LEFT(lcget,LEN("<WIDTH|N|="))=="<WIDTH|N|="
								lnWidth=this.GetValTag(lcGet)	
								
							CASE LEFT(lcget,LEN("<HEIGHT|N|="))=="<HEIGHT|N|="
								lnHeight=this.GetValTag(lcGet)	
							CASE LEFT(lcGet,LEN("<FOLDER|C|="))=="<FOLDER|C|="
								LcFolder=This.GetValTag(lcget)
						ENDCASE
					ENDDO
				ENDIF
			ENDIF
		
		CATCH TO loEx
			loEx.UserValue=PROGRAM()
			this.ShowError(loex)
		FINALLY 
			IF lnWindowState=1
				lnWindowState=0
			ENDIF
		
			=FCLOSE(nfop)
		ENDTRY
		IF VARTYPE(loeX)="O"
			RETURN
		ENDIF
			
		TRY
			LOCAL loex as Exception
			IF EMPTY(lcFolder)
				lcFolder=FULLPATH("")
			ENDIF		
			ADDPROPERTY(_Screen,"oFrmStand", NEWOBJECT("FrmScript","clases\prssys.vcx") )
			ADDPROPERTY(_screen.oFrmStand,"Folder",lcfolder)
			ADDPROPERTY(_screen.oFrmStand,"Selfile","")
		
			_Screen.oFrmStand.NewObject("CntScrip1","cntScrip","clases\prssys.vcx")
				
			WITH _Screen.oFrmStand.cntSCrip1
				.top=1
				.left=1
				.visible=.t.
				lnMinHei=.Height+1
				lnMinWid=MAX(.Width+1-40,580)
			ENDWITH
			this.genscriptdir(_screen.oFrmStand,_Screen.oFrmStand.CntScrip1,lcFolder)	
				
			WITH _Screen.oFrmStand
				.Top=lnTop
				.Left=lnLeft
				.WindowState=lnWindowState	
				IF lnWidth=0 OR lnHeight=0 OR lnWindowState=2	
					.Height=.CntScrip1.Height+1
					.Width=.CntScrip1.Width+1
				ELSE
					.Height=lnHeight
					.Width=lnWidth
				ENDIF
				
				
				.cntscrip1.lastheight=.Height
				.MinHeight=lnMinHei
				.MinWidth=lnMinWid
				.Show()
					
				.CntScrip1.GetMedida(.t.)
				.CntScrip1.noresize=.f.			
			ENDWITH	
		
		CATCH TO loEx
			loEx.UserValue=PROGRAM()
			_Screen.ofrmstand=null
			this.showerror(loEx)
		FINALLY
		
		ENDTRY
				
		RETURN .t.
				
		
	ENDPROC

	PROCEDURE genscriptdir
		LPARAMETERS xoForm,xoConte,xcFolder
		*LOCAL lcFolder
		LOCAL lnFiles,i,nfop,lcFile,lcPut,lcGet
		IF EMPTY(xcFolder) OR !DIRECTORY(xcFolder)
			RETURN
		ENDIF
		IF UPPER(xcFolder)==UPPER(FULLPATH(""))
			lnFiles=0
		ELSE
			lnfiles=ADIR(gaDir,ADDBS(xcFolder)+"*.txt")
		ENDIF
		
		FOR i=1 TO lnfiles
			nfop=-1
			lcPut=""
			lcFile=LOWER( ADDBS(xcFolder)+gadir[i,1])
			IF This.getfopen(ADDBS(xcFolder)+gadir[i,1],@nfop,.t.,0)
				lcGet=FGETS(nfop,2048)
				FCLOSE(nfop)
				IF LEFT(lcGet,LEN("<SCRIPT|C|="))=="<SCRIPT|C|="	
					lcPut=this.getvaltag(lcGet)
				ENDIF
			ENDIF
			gadir[i,1]=EVL(lcPut,PROPER(JUSTFNAME(lcFile)))
			gadir[i,2]=lcfile
		NEXT
		
		WITH xoConte.Cnt1.Cmbdir1
			.Clear
			.Boundcolumn=2
			.ColumnCount=2
			.ColumnWidths="300,200"
			.Controlsource='thisform.SelFile'
			.Addlistitem("(Seleccione Archivo Script)",1,1)
			.addlistitem("",1,2)
			FOR i=1 TO lnFiles
				.addlistitem(gadir[i,1],i+1,1)
				.addListitem(gadir[i,2],i+1,2)
			NEXT
			.requery
			.refresh
			.Enabled=IIF(lnfiles>0,.t.,.f.)
		ENDWITH
		
		
		
	ENDPROC

	PROCEDURE getfopen
		LPARAMETERS xcFile,xnHandler,xlNotVerb,xnPrivileg,xlOpenEmpty
		**************************************************************
		*!*	Objeto: abrir un archivo con FOPEN()
		*!*	xcFile:    	Ruta y Nombre de archivo completo que se intenta abrir
		*!*				Se puede pasar como xcfile+"<eof/>" 
		*!*				para que quede en EOF()
		*!*	xnHandler: @ Handler pasado por referencia
		*!*	xlNotVerb: suprime comentarios si es .t.
		*!*	xnPrivileg, may be:
		*!*		0 Read Only Buffer
		*!*	 	1 Write ONly Buffer
		*!*	 	2 Read Write Buffer
		*!*	 	10 Read Only No Buffer
		*!*	 	11 Write ONly No Buffer
		*!*	 	12 Read Write No Buffer
		*!*	xlOpenEmpty: Valida la apertura de un archivo vacío
		*!* --------------------------------------------------------------
		*!*	IF !This.GetFopen(addbs(lcRoot)+"archivo.txt",@nfop,.F.,12)
		*!*		RETURN
		*!*	ENDIF
		*!* --------------------------------------------------------------
		
		local lRet,gnEnd,gnTop,nat,lcTag
		lREt=.t.
		STORE "" TO lcTag
		IF EMPTY(xcfile)
			IF !xlNotVerb
				MESSAGEBOX("Nombre de archivo vacío",0,"GetFopen Message")
			ENDIF
			RETURN .F.
		ENDIF
		nat=AT("<",xcFile)
		IF nat > 0
			lcTag=LOWER(TRIM(SUBSTR(xcFile,nat)))
			xcFile=LEFT(xcfile,nat-1)
		ENDIF
		
		IF !file(xcFile)
			if !xlNotVerb
				MESSAGEBOX("El archivo &xcFile no existe",0,"GetFopen Message")
			endif
			RETURN .F.
		endif
		if vartype(xnPrivileg)#"N"
			xnPrivileg=0
		ENDIF
		IF !INLIST(xnPrivileg,0,1,2,10,11,12)
			xnPrivileg=12
		ENDIF
		
		xnHandler=fopen(xcFile,xnPrivileg)
		if xnHandler=-1
			if !xlNotVerb
				MESSAGEBOX("El archivo &xcFile no pudo abrirse",0,"GetFopen Message")
			ENDIF
			RETURN .F.
		ENDIF
		gnEnd=Fseek(xnHandler,0,2)
		IF EMPTY(lcTag) OR lcTag#"<eof/>"
			gntop=Fseek(xnHandler,0)	
		ENDIF
		
		IF !xlOpenEmpty AND gnEnd<=0
			if !xlnotVerb
				MESSAGEBOX("El archivo &xcFile no tiene contenido",0,"GetFopen Message")
			endif
			FCLOSE(xnHandler)
			lRet=.f.
		ENDIF
		
		RETURN lret
		
		
	ENDPROC

	PROCEDURE getvaltag
		LPARAMETERS xcTag,xlReturnObj
		**************************************
		* PROCEDURE getValTag(xcTag,xlReturnObj)
		**************************************
		* Etiquetas calificadas ( <NOMBRE|N|1250.12/>  )
		*-----------------------------------------------
		* Si xlREturnObj=.F. (Default)
		* 	Devuelve el valor de una etiqueta
		*	lcTag="<ESTADO|L|.T./>
		*	? GetValTag(lcTag)	&& muestra .T.
		*
		* Si xlReturnObj= .T.
		*	Devuelve la referencia a un objeto "empty"
		*	con tres propiedades: Tag, Value y Type
		*
		*	lcTag="<IMPORTE|N|12726.15/>
		*	obj=GetValTAg(LcTag,.t.)
		*	if !isnull(obj)
		*		? obj.value	&& devuelve 12726.15
		*		? obj.Tag	&& devuelve "IMPORTE"
		*		? Obj.type	&& devuelve "N"
		*		obj=null
		*	ENDIF
		*-----------------------------------------------------
		* Etiquetas cerradas simples
		*-----------------------------------------------------
		* lcTag="<ANIMAL=PERRO/>
		* ? GetvalTAg(lcTag)	&& muestra "PERRO"
		*
		* 	obj=GetValTag(lcTag,.t.)
		*	IF !isnull(obj)
		*		? Obj.TAg	&& muestra "ANIMAL"
		*		? obj.Value	&& muestra "PERRO"
		*		? obj.type	&& siempre muestra "C"
		*	ENDIF
		*-------------------------------------------------------
		* Rutina de exploración:
		*	LOCAL obj,fcr,nHand,lnResp
		*	FCR=ADDBS(FullPath(""))+"formula.txt"
		*	nhand=-1
		*	IF !This.GetFopen(fcr,@nhand,.f.,12)
		*		RETURN
		*	ENDIF
		*	DO WHILE !FEOF(nhand)
		*		lcTag=FGETS(nhand,2048)
		*		DO case
		*			CASE AT("|S|=",UPPER(lcTag))#0	&& ExecScrip()
		*				=GetValTAg(lcTag)
		
		*			CASE AT("#|=",lcTAg)#0			&& Define la tag como variable de paso y le asigna el valor
		*				obj=GetValTAg(lcTAg,.t.)
		*				IF !ISNULL(obj)
		*					lcEtiq=obj.Tag
		*					&lcEtiq=obj.Value
		*					obj=null
		*				ENDIF
		*
		*			OTHERWISE
		*		
		*				lnResp=GetValtag(lcTag)		&& Asigna a lnResp el valor contenido de la tag (puede ser |E|)
		*				
		*		ENDCASE
		*	
		*	ENDDO
		*	=FCLOSE(nhand)
		*	
		******************************************************
		
		LOCAL lcLast,lcREs,lnLines,nPart,lcVari,lctype,;
			lxReturn,objReturn,lcTryValor
		
		IF VARTYPE(xctag)#"C" OR EMPTY(xcTag)
			RETURN IIF(xlREturnObj,null,"")
		ENDIF
		LOCAL ARRAY gaTags(1),gaTypes(1)
		xcTAg=ALLTRIM(xcTag)
		xcTAg=ALLTRIM(xctag)
		* Tag inválida
		IF LEFT(xcTag,1)#"<" OR ;
				AT("=",xcTAg)=0 OR ;
				RIGHT(xcTag,1)#">"
			RETURN IIF(xlREturnObj,null,"")
		ENDIF
		lxREturn=""
		lcType="C"
		
		xcTag=ALLTRIM(xcTag)
		lcLast=IIF(RIGHT(xcTag,2)=="/>","/>",RIGHT(xcTag,1))
		lcRes=STREXTRACT(xcTag,"<",lcLast)
		
		IF AT("|=",lcRes)#0
			lnlines=ALINES(gaTags,lcRes,1+2,"|=")
			IF lnLines>0
				gaTAgs[1]=gaTags[1]+"|"
			ENDIF
		ELSE
			lnLines=ALINES(gatags,lcRes,1+2,"=")
		ENDIF
		*lcVari=gatags[1]
		IF lnLines>1
			lcTryValor=""
			FOR i=2 TO lnLines
				lcTryValor=lcTryValor+gaTags[i]
			NEXT
			IF AT("#|",gatags[1])#0
				xlREturnObj=.t.
				gaTAgs[1]=STRTRAN(gaTAgs[1],"#|","|")
			ENDIF
			lcVari=gatags[1]
			lcTryValor=gatags[2]
			nat=AT("|",gatags[1])
			IF nAt=LEN(gatags[1])-IIF(RIGHT(gatags[1],1)="|",2,1)
				nPart=ALINES(gatypes,gatags[1],5,"|")
				lcVari=gatypes[1]
				lcType=UPPER(gatypes[2])
				DO case
					CASE lcType$"NI"
						lxReturn=VAL(lcTryValor)
					CASE lcType="L"
						lxReturn=IIF(AT("T",lcTryValor)#0,.t.,.f.)
					
					CASE LCTYPE="D"
						lxReturn=CTOD(lcTryValor)
					
					CASE LCTYPE="T"
						lxReturn=CTOT(lcTryValor)
					CASE lctype="E"
						lxReturn=EVALUATE(lcTRyValor)
					CASE lcType="S"
						lcTryValor=CHRTRAN(lcTryValor,CHR(10),"")
						lcTryValor=CHRTRAN(lcTRyValor,CHR(28),CHR(13))
						lxReturn = EXECSCRIPT(lcTryValor)
					CASE lctype="X"
						lxREturn=null
					CASE lcType="O"
						lxReturn=null
					OTHERWISE
						lxReturn=lcTRyValor
				ENDCASE
			ELSE
				lxReturn = lcTryValor		
			ENDIF
		ENDIF
		IF xlREturnObj
			objReturn=CREATEOBJECT("empty")
			ADDPROPERTY(objReturn,"Tag",lcVari)
			ADDPROPERTY(objReturn,"Value",lxREturn)
			ADDPROPERTY(objReturn,"Type",lctype)
		ENDIF
		RETURN IIF(xlReturnObj,ObjReturn,lxREturn)
		
	ENDPROC

	PROCEDURE gexcel
		LPARAMETERS xcFile,ttcol,tthea,ttsum,gatitu,cFilfe,;
			TTDIM,XTTWID,xcPagSetup,xtGatitu,;
			gasubtit,xcTotalize,xcttWrap,xlProteger,ga_Pata,;
			xcGuardar,xnADdPag,xlIstitulo,xlOnePage
		
		
		*****************************************************************************************************************************************
		* xcFile: Nombre del cursor.
		*         Admite TagsParámetros. por ahora
		*         <BOLD=FieldNom>. El campo para Bold tiene que ser "L"
		*******************************************************************
		* ttcol es un TxTerate como tthea y ttsum
		* gatitu es una matriz que contiene el rotulo de hoja
		* xtGatitu: Puede ser [C/N/X]
		*	X: Gatitu es una matriz normal
		*	N: GAtitu es un TxTerate numerico (cada valor)
		*	C: Gatitu es un TxTerate alfabético (cada valor)
		* cFilfe, es una expresión que devuelve verdadero o Falso
		*			por ejemplo [Between(fecha,dia1,dia2)]
		* ttdim: "F10]SUMA1/SUMA2/SUMA3/" ó "10]suma1/suma2/suma3/
		*			ó "suma1/suma2/suma3/"
		* xcPagSetup= TxTerate [nTop/nLeft/]
		* xcTotalize= Es una expresión de 4 partes entre comas
		*			"nDesplaza,cColumnAlign,TxTerate_Col,TxTerate_Fun"
		*	Ej:     "1,RETIENE,GRAVADO/EXENTO/RETIENE/,+/+/-/"
		* xcTtwrap= Columnas en las que se efectua WrapTExt
		* xlProteger: Proteccion de contenido
		* ga_Pata: es un array que se ubica al final de la lista
		*---------------------------------------------------------------
		
		EXTERNAL ARRAY GATITU,gasubtit,ga_Pata
		
		LOCAL th_spTime,xcTAg,lcColBold,i,y,i_,xi,xi_,nat,cTag,nl,;
			minFeVal,ttcol,ttsum,tthea,lgapata,lScrache,;
			lFixDim,nFixDim,ntd,cFixDim,kntHea,kntCol,;
			gnRecActual,nReco,ctuti,opos,nOcur,nPos,cValor,;
			oExcel,xlSheet,HojaName,keLibro,;
			gnCuantos,kkampo,nas,R,lcampo,RFIRST,nAddCol,;
			nConta,ndiez,kTiSum,kTiCol,kTiPal,nut,;
			ngs,bValRep,cvalRep,cProsuma,nMaxFormu,lDoit,;
			loBold,bDezim,tValRep,cNumForm,LastRow,nCols,;
			cLetra,cFuncion,nalen,nRow,czColum,nColz,;
			czTxtcol,czTxtFun,czTexto,czColTExt,czCelText,nzColText,;
			lnzCol,lnzfun,cformula,pzColum,pzFun,npLet,clet,cRow,;
			cPuta,cPuta1,cPutRan,nCol,nColHeader,lcName,;
			cLetra1,cLetra2,cRan1,cRan2,cPutRange,nRow1,nRow2,;
			lFixDim,lVArDim,lnGaDim,cGadim,kk,lBold,;
			cwrCol,cpran,nwRap,nRowRep,kScrache,cRango,cProte
		
			
		
		
		STORE "" TO xctag,lcColBold,th_sptime
		
		
		* Ejem "cPasfile<BOLD=COLUM3>
		
		nAT=AT("<",xcFile)
		IF nat#0
			xcTag=SUBSTR(xcfile,nat)
			xcFile=LEFT(xcFile,nat-1)
			cTag=STREXTRACT(xcTAg,"<",">")
			nl=ALINES(gaTag,UPPER(ctag),4,"=")
			IF nl=2
				DO CASE
					CASE gaTAg[1]=="BOLD"
						lcColBold=gaTag[2]
						
				ENDCASE
			endif
		ENDIF
		
		
			
		minfeval=ctod("01/01/1900")
		ttcol=Upper(ttcol)
		ttsum=Upper(ttsum)+","
		if vartype(xtGatitu)#"C"
			xtGatitu="X"
		endif
		lGapata=.t.
		if vartype(ga_Pata)#"C"
			dimension ga_Pata(1)
			ga_Pata[1]=""
			lGapata=.f.
		endif
		if vartype(xnAddPag)#"N"
			xnAddPag=0
		endif
		
		
		cNoNum="NUMCHEK/ORDEN/PERIODO/RESUM/DIAS/DIASPAS/DIASMES/DIASTRA/";
					+"DIASVAC/DIASAUS/CUOTAS/IDTURNO/TH_TRANSMI/ANOFABRI/";
					+"ARRASTRE/HPA/TARA/SUMEJE/BLOQUE/QREDON/"
					
		*Diasmes	Diastra	Diasvac	Diasaus
		
		
		
		
		IF VARTYPE(xcFile)#'C' 
			=MESSAGEBOX("Parametros Archivo Inválido",16,'De VFP a Excel')
		   	RETURN .F.
		ENDIF
		lScrache=.t.
		xcfile=Upper(alltrim(xcfile))
		if at("<NOSCRA/>",XCFILE)#0
			xcfile=strtran(xcfile,"<NOSCRA/>")
			lScrache=.f.
		endif
		IF !USED(XCfILE)
			Messagebox("El archivo &xcFile no está en uso.")
			return
		endif
		if Vartype(cFilfe)#"C"
			cFilfe=""
		endif	
		if vartype(tthea)#"C"
			tthea=""
		endif
		IF VARTYPE(xttwid)#"C"
			xttwid=""
		endif
		if vartype(xcGuardar)#"C"
			xcguardar=""
		endif
		if vartype(xcPagsetup)#"C"
			xcPagSetup="36/48/"
		endif
		if Occurs("/",xcPagSEtup)#2
		*	Messagebox("Parámetro xcPagSEtup: &xcPagsetup erróneo.",0,_screen.th_mensaje)
			xcPagsetup="36/48/"
		endif
		if vartype(xnItem)#"N"
			xnItem=1
		endif
		if vartype(xcTtwrap)#"C"
			xcTtwrap=""
		endif
		if len(xcttwrap)<2
			xcttwrap=""
		endif
		LOCAL array apagSEtup(1)
		lnPagSetup=ALINES(aPagSetup,xcPagSetup,5,"/")
		FOR i_=1 TO lnPagSetup
			aPagSetup[i_]=VAL(aPagSEtup[i_])
		NEXT
		
		*!*	txterate(xcPagSetup,"/",@aPagSetup,.t.)
		IF VARTYPE(xcTotalize)#"C"
			xcTotalize=""
		endif
		* tiene que tener por lo menos 2 comas.
		if Occurs(",",xcTotalize)<2
			xcTotalize=""
		endif
		
		
		
		IF VARTYPE(TTDIM)#"C"
			TTDIM=""
		ENDIF
		TTDIM=UPPER(TTDIM)
		lFixDim=.f.
		nFixDim=3
		NTD=aT("]",TTDIM)
		IF NTD>0
			cfdim=Substr(ttdim,1,ntd-1)
			TTDIM=substr(ttdim,ntd+1)
			nfd=At("F",cfdim)
			lFixDim=iif(nfd>0,.t.,.f.)
			cFixdim=iif(nfd>0,Substr(cfdim,nfd+1),trim(cfdim))
			nFixDim=Val(cFixDim)
		
		endif
		
			
			
		knthea=Occurs(",",tthea)
		kntCol=Occurs(",",ttcol)
		if kntHea#kntCol
			tthea=ttcol
		endif
		
		LOCAL lpag AS INTEGER &&&&variable para determinar la página a ingresar los datos por si hay más de 60 mil registros
		lpag=1			
		LOCAL ARRAY gaHeader(1)
		lnHeader=ALINES(gaHeader,tthea,1,",")
		for i_=1 to lnHeader
			gaHeader[i_]=Proper(gaHeader[i_])
		next
		LOCAL ARRAY gaTikam(lnHeader)
		Store "C" to gatikam
		SELECT (xcfile)
		gnRecActual=Recno()
		Count to nreco
		go top
		
		
		
		cTuti="/"+ltrim(str(nreco))
		if at("/",ttcol)>0
			ttcol=StrTran(ttcol,"/",",")
		endif
		if right(ttcol,1)#","
			ttcol=alltrim(ttcol)+","
		endif
		nOcur=Occurs(",",ttcol)
		dimension amato(nOcur)
		opos=1
		for i_=1 to nOcur
			npos=At(",",ttcol,i_)
			cValor=Substr(ttcol,opos,npos-opos)
			aMato[i_]=cValor
			opos=npos+1
		next
		*** Creación del Objeto Excel
		*	release mensajero
		*	public mensajero
		*	do form &dformu\mensajero name mensajero linked with ;
		*		"Exportando a Microsoft Excel...",200,320	
		**********************************************************
		
		
		Lntop=100
		LnLeft=220
		
		WAIT WINDOW "Exportando a Microsoft Excel..." AT 12,20 NOWAIT 
		
		
		
		TRY
			LOCAL loex as Exception
			Oexcel = CREATEOBJECT("Excel.Application")
		CATCH TO loEx
			loex.UserValue=PROGRAM()
			this.showerror(loEx)
		ENDTRY
		IF VARTYPE(loex)="O"
			WAIT clear
			RETURN
		ENDIF
		
		
		
		WAIT WINDOW "Agregando una hoja al libro" AT 12,15 NOWAIT 
		
		kelibro=oExcel.workbooks.ADD()
		XLSheet = oExcel.ActiveSheet
		XLSheet.NAME=Proper(xcFile)+'_'+ALLTR(STR(lpag))
		HojaName=Proper(xcFile)+'_'+ALLTR(STR(lpag))
		SELECT(xcFile)
		if empty(ttcol)
			gnCuantos=AFIELDS(gaFile,xcFile)
			Dimension gaCampos(gnCuantos),GADEZIM(gnCuantos)
			for i_=1 to alen(gaFile,1)
				gaCampos[i_]=gaFile[i_,1]
				gaDezim[i_]=gafile[i_,4]
			next
		else
			gnCuantos=alen(amato)
		  	dimension gaCampos(gnCuantos),gaDezim(gnCuantos)
		  	for i_=1 to alen(amato)
				gaCampos[i_]=Upper(alltrim(amato[i_]))
				gadezim[i_]=0
		  	next
		  	aFields(gafile,xcfile)
		  	for i_=1 to alen(gaCampos)
		  		kkampo=gaCampos[i_]
		  		nas=Ascan(gafile,kkampo)
		  		if nas>0
		  			gadezim[i_]=gafile[nas+3]
		  		endif
		  	next
		  		
		endif
		
		
		
		SELECT (xcFile)
		GO TOP 
		
			
		naddcol=0
		
		IF XTGATITU#"X"
			nAddCol=alen(gaSubTit,1)
		endif
		R=alen(gatitu)+2+nAddCol
		RFIRST=R
		nconta=0
		ndiez=0
		* Determina qué campos tienen suma
		* Depende de ttsum
		ktisum=""
		kticol=""
		ktipal="Total"
		nat=at("[",ttsum)
		if nat>0
			ktisum=Substr(ttsum,nat+1)
			nut=At(":",ktisum)
			if nut>0
				kticol=Substr(ktisum,1,nut-1)
				ktipal=Substr(ktisum,nut+1)
			endif
			
		endif
		
			
		Dimension gasuma(1)
		ngs=0
		FOR i_=1 to alen(gacampos)
			bValrep=gaCampos[i_]
			cValrep=EVALUATE(bValrep)
			cProsuma=bValrep+","
			gatikam[i_]=Vartype(cValrep)
			if At(cProsuma,ttsum)>0
				if AScan(gasuma,i_)=0
					ngs=ngs+1
					dimension gasuma(ngs)
					gasuma[ngs]=i_
				endif 
			endif
		next
		nMaxFormu=18
		if vartype(mth_main)="C" AND mTH_MAIN=="THEOCONT"
			nMaxFormu=19
		endif
		WAIT WINDOW "Registros importados" AT 12,15 NOWAIT 
		SCAN
			ndiez=ndiez+1
		  	nconta=nconta+1
			if nDiez=50
			  	WAIT WINDOW "Registros importados "+ltrim(str(nConta))+cTuti AT 12,15 NOWAIT 
		  		nDiez=0
			endif
			if empty(cFilfe)
				ldoit=.t.
			else
				ldoit=&cFilfe
			endif
			if !ldoit
				loop
			endif  	
		
		
			
			FOR I_=1 TO gnCuantos
		  *    lcampo=ALLTRIM(xcFile)+'.'+gaCampos(I,1)
		  		loBold=IIF(EMPTY(lcColbold),.f.,EVALUATE(lcColBold))
		
				bValrep=gaCampos[i_]
				bDezim=gaDezim[i_]
				TVALREP=BVALREP+"/"
				cValrep=EVALUATE(bValRep)
				IF VARTYPE(cValrep)#'G'
					with xlSheet.Cells(r,i_)
		       			DO CASE
		        			CASE VARTYPE(cValrep)="C"
		        				if left(cValrep,1)="]"
		        					cValrep=Substr(cValrep,2)
		        					lobold=.t.
		        				endif        			
		        				do case
		        					case at(tValrep,th_Sptime)#0
		        						.Style.IncludeNumber =.T.
		        						.NumberFormat="[h]:mm"
		*        						Messagebox(tvalrep+" ; "+th_sptime)	        				
		        						.Value=cValRep
		        					CASE TVALREP=="CLAVEBAN/"
		        						*cValrep=iif(!empty(cValrep),"*"+cValrep+"*","")
		        						*.NUMBERFORMAT="Text"
		        						.NumberFormat = "@"
		        						.Value=cValrep
		        					case tvalrep=="REMITOS/"
		        					*	.Style.IncludeNumber =.T.
		        					*	.NumberFormat=" "      					
		        					*	.Value=cValrep
		        						.Value=iif(empty(cValrep),""," "+cValrep)	
		
		
		        					otherwise
				        				.VALUE=ALLTRIM(cValrep)
		
				        		endcase
				        		if xlIstitulo.and.istitu
				        			loBold=.t.
				        		endif
				  				if lobold
				       				.FONT.bold =.t.
				       			endif		        		
				        		
		    	    		CASE VARTYPE(cValrep)="N"
		    	    			DO CASE
		    	    				CASE At(bValrep,cNonum)#0
		    	    					.Value=cValrep
		    	    				other
		    	    					cNumform=iif(bdezim=0,"#,##0","#,##0.")+Repli("0",bDezim)
										.Style.IncludeNumber =.T.
		        						.NumberFormat=cNUmForm
		        						*"#,##0.00"
										.VALUE=cValrep
								endcase
				        		if xlIstitulo.and.istitu
				        			.Font.Bold = .t.
				        		endif						
			        		CASE VARTYPE(cValrep)="D"
			        			if cValrep<MinFeval
			        				cValrep=Ctod("")
			        			endif
		    	    			IF !EMPTY(cValrep)
									.VALUE=cValrep
								endif
			        		CASE VARTYPE(cValrep)="T"
		        			    .VALUE=TTOC(cValrep)
		        			OTHERWISE
		        				.VALUE=cValrep
		 	
		       			ENDCASE
		       			IF !EMPTY(lccolBold)
		       				.Font.Bold=loBold
		       			ENDIF
		       			
					endwith
				ENDIF
			NEXT
		
			R=R+1
		ENDSCAN
		
		
			
		*?? "Registro: "+ltrim(str(nConta))+cTuti at 1
		WAIT WINDOW "Registros importados "+ltrim(str(nConta))+cTuti AT 12,15 NOWAIT 
		*? " Escribiendo Títulos..."
		
		lastrow=r-1
		if ngs>0
			lastrow=r
			*Primer fila rFirst
			*Ultima fila (r-1)
			* Identificar nCols
			for kk=1 to alen(gasuma)
				nCols=gasuma[KK]
				* ? " KeLetra con nCols ",nCols
				cLetra=this.keletra(nCols)
				cFuncion="=Sum("+cLetra+ltrim(str(rFirst))+":";
					+cLetra+ltrim(str(r-1))+")"
				with XLSheet.Cells(R,nCols)
					.VALUE=cFuncion
			   		.FONT.NAME = "Arial"
					.FONT.SIZE = 8	
					.FONT.BOLD=.T.
				endwith
			next
			with xlSheet
				for kk=1 to alen(gacampos)
					.Cells(r,kk).Interior.ColorIndex=35
				next
			endwith
			ncols=1
			if !empty(kticol)
				kTicol=Upper(kticol)
				nCols=Ascan(gacampos,kticol)
			endif
			if !Between(nCols,1,alen(gacampos))
				nCols=1
			endif
			with xlsheet.Cells(r,nCols)
				.Value=kTipal
				.font.bold=.t.
			endwith
				
		
		
		endif
		if !empty(xcTotalize)
		*	Ej: "1,RETIENE,GRAVADO/EXENTO/RETIENE/,+/+/-/"
		*	? " Escribe el Totalizador..."
		
			xcTotalize=alltrim(xcTotalize)
			nLen=Len(xcTotalize)
			if Right(xcTotalize,1)#","
				xcTotalize=xcTotalize+","
			endif
			LOCAL ARRAY aTotalize(1)
			nAlen=ALINES(aTotalize,xcTotalize,1+4,",")
		
			if nalen<4
				nSep=oCcurs("/",aTotalize[3])
				Dimension aTotalize(4)
				aTotalize[4]=Repli("+/",nSep)
			endif
			nalen=alen(atotalize)
			if nalen<5
				dimension aTotalize(5)
				aTotalize[5]=""
			ENDIF
		
		
				
			nRow=val(aTotalize[1])+ R
			cRow=ltrim(str(R))
			czColum=Upper(alltrim(atotalize[2]))
			nColz=Ascan(gaCampos,czColum)
			czTxtcol=aTotalize[3]
			czTxtFun=atotalize[4]
			czTexto=aTotalize[5]
			if empty(czTexto)
				czColTExt=0
				czCelTExt="Total"	
			else
				nat=At(":",czTexto)
				if nat>0
					czColText=Upper(Substr(czTexto,1,nat-1))
					czCelTExt=Substr(czTexto,nat+1)
				else
					czColTExt=Upper(alltrim(czTexto))
					czCelTExt="Total"
				endif
			endif
			nzColText=Ascan(gaCampos,czColTExt)
			if nzColTExt=0 .or. nzColTExt>=ncolz
				nzColTExt=nColz-1
			endif
			LOCAL ARRAY aTxtCol(1),aTxtFun(1)
		
			lnzCol=ALINES(aTxtCol,czTxtCol,1,"/")
			lnzFun=ALINES(aTxtfun,czTxtFun,1,"/")
		
			
			cFormula="="
			For i=1 to lnzCol
				pzColum=aTxtCol[i]
				pzfun=aTxtFun[i]
				NPLET=Ascan(gaCampos,Pzcolum)
				* ? " KeLetra con npLet ",nplet
				cLet=this.keletra(npLet)
				cFormula=cFormula+pzfun+cLet+cRow
			next
			with XLSheet.Cells(nRow,nColz)
				.VALUE=cFormula
				.Style.IncludeNumber =.T.
				.NumberFormat="#,##0.00"
				.FONT.NAME = "Arial"
				.FONT.SIZE = 8	
				.FONT.BOLD=.T.
				.INTERIOR.COLORINDEX=34
			endwith
			with xlSheet.Cells(nRow,nzcolTExt)
				.Value=czCeltext
				.Font.Name="Arial"
				.Font.Size=8
				.Font.Bold=.t.
				.Interior.ColorIndex=34
			endwith
			* ? " KeLetra con nzColText ",nzcolText
			* ? " KeLetra con nColz ",nColz
			cPuta=this.keletra(nzColText)+ltrim(str(nrow))
			cPuta1=this.keletra(nColZ)+ltrim(str(nrow))
			cPutRan=cPuta+":"+cPuta1
			WITH XLSHEET.range(cPutRan).Borders
				.LineStyle =1
				.COLORINDEX=56
			endwith
		
		endif
		
		
		
		if lGapata
			r=r+1
			WITH xlSheet
				for gi_=1 to alen(ga_Pata)
					.Cells(r,1).value=ga_Pata[gi_]
					.Cells(r,1).Font.Name="Arial"
					.Cells(r,1).Font.Size=8
					.Cells(r,1).Font.Bold=.f.
					r=r+1		
				next
			ENDWITH
		endif
		
		
		nCol=alen(gatitu)+1+nAddCol
		nColHeader=nCol
		with xlsheet
			FOR I_ = 1 TO gnCuantos
				lcname=gaHeader[i_]
				.Cells(ncol,i_).VALUE=lcname
				.Cells(ncol,i_).FONT.NAME = "Arial"
				.Cells(ncol,i_).FONT.SIZE = 8
				.Cells(ncol,i_).FONT.bold = .T.
				.cells(ncol,i_).INTERIOR.COLORINDEX=35
				.CELLS(ncol,i_).HorizontalAlignment = iif(gatikam[i_]$'NDL',3,2)
			NEXT
		endwith
		cletra1=this.keletra(1)
		cLetra2=this.keletra(alen(gacampos))
		cRan1=Cletra1+ltrim(str(ncol))
		cRan2=cLetra2+Ltrim(str(lastrow))
		cPutRange=cRan1+":"+cRan2		
		nRow1=ncol
		nRow2=LastRow
		* Range("A1:H8")	
		* Rango Filas: (ncol:LastRow)		
		*	Messagebox(cPutRange)
		with xlsheet.range(cPutRange)
			.font.Name="Arial"
			.Font.Size=8
		endwith
		
		*? " Ajuste de presentación..."
		WAIT WINDOW "Ajustando la presentación" AT 12,15 NOWAIT 
		
		
		
		xLSheet.COLUMNS.AUTOFIT  
		IF !EMPTY(TTDIM)
			lVarDim=.f.
			if !empty(xttwid)
				lFixDim=.f.
				lVardim=.t.
				LOCAL ARRAY gawid(1)
				lnWids=ALINES(gawid,xttwid,1,"/")
				FOR i_=1 TO lnWids
					gawids[i_]=VAL(gaWids[i_])
				NEXT
			endif
		
			LOCAL ARRAY gadim(1)
			lngadim=ALINES(gadim,ttdim,1,"/")
		*!*		Txterate(ttdim,"/",@gadim)
			IF lnGadim>0
				LOCAL ARRAY gaCodim(lnGAdim)
				for i_=1 to alen(gadim)
					cGadim=gadim[i_]
					nas=Ascan(gaCampos,cGadim)
					if nas>0
						gaCodim[i_]=nas
					ELSE
					*	? " ¡¡¡No encuentro &cGadim en GaCampos !!!"
						WAIT WINDOW "¡¡¡No encuentro &cGadim en GaCampos !!!" AT 12,15 NOWAIT 
						gaCodim[i_]=0
					endif
				NEXT
			ENDIF
			
			with xlSheet
				for kk=1 to alen(gaCodim)
					* ? " KeLetra con gaCodim[kk] ",gaCodim[kk]
					if gaCodim[kk]>0
						cLetra=this.keletra(gaCodim[kk])
						if lFixdim
							.Columns(cLetra).ColumnWidth=nFixDim
						else
							if lVArdim
								.Columns(cLetra).columnwidth=gawid[kk]
							else
								.Columns(cLetra).Columnwidth=.Columns(cLetra).columnwidth+nFixDim
							endif
						endif
					endif
				next
			endwith
		
		ENDIF
		
		if empty(gatitu[1])
			gatitu[1]=PROPER(Miempresa)+SPACE(25)+"C.u.i.t.: "+micuitemp
		endif
		with xlSheet
			for i_=1 to alen(gatitu)
				kkGatitu=gatitu[i_]
				nat=At("]",kkGatitu)
				lBold=.f.
				if nat>0
					kkGatitu=Substr(kkgatitu,nat+1)
					lbold=.t.
				endif
				.Cells(i_,1).VALUE=kkGatitu
				.Cells(i_,1).FONT.NAME="Arial"
				.Cells(i_,1).FONT.SIZE=8      
				.Cells(i_,1).FONT.bold =lBold
			next
		endwith
		with xlsheet.Range("A1:B1")
			.RowHeight=18
			.VerticalAlignment=2
			.font.size=9
			.Font.Bold=.t.
		endwith
		ngatt=alen(gatitu)
		if xtGatitu#"X"
			lTer=iif(xtGatitu="N",.t.,.f.)
			with xlSheet
				for xi_=1 to alen(gaSubTit)
					kkGatitu=gaSubTit[xi_]
		
					LOCAL ARRAY satitu(1)
					lnGatitu=ALINES(satitu,kkgatitu,1,"/")
					IF lTer
						FOR i_=1 TO lnGatitu
							satitu[i_]=VAL(satitu[i_])
						NEXT
					ENDIF
					
					For y=1 to alen(satitu)
						if vartype(satitu[y])="N"
							.Cells(Xi_+nGatt,y).Style.IncludeNumber =.T.
		    	    		.Cells(Xi_+nGatt,y).NumberFormat="#,##0.00"
		    	    	endif
						.Cells(xi_+nGatt,y).VALUE=satitu[y]
						.Cells(xi_+nGatt,y).FONT.NAME="Arial"
						.Cells(xi_+nGatt,y).FONT.SIZE=8      
		*				.Cells(xi_+nGatt,y).FONT.bold =iif(i=1, .T.,.f.)
					next
				next
			endwith
			
			
		
		endif
		*? " Configurando Página..."	
		WAIT WINDOW "Configurando Página" AT 12,15 NOWAIT 
		* Dibuja rayado de cuadrícula en gris oscuro (56)
		WITH XLSHEET.range(cPutRange).Borders
			.LineStyle =1
			.COLORINDEX=56
		endwith
		if !empty(xcttwrap)
			LOCAL ARRAY  awrap(1)
			nwrap=ALINES(aWrap,xcttWrap,1,"/")
			FOR i_=1 TO nwrap
				awrap[i_]=VAL(awrap[i_])
			NEXT
		*!*		
		*!*		Txterate(xcttWrap,"/",@aWrap,.t.)
			for i_=1 to alen(aWrap)
				cwrCol=this.keletra(aWrap[1])
				cpran=cwrCol+ltrim(str(nrow1))+":"+cwrCol+ltrim(str(nrow2))
				xlsheet.Range(cpran).Wraptext=.t.
			next
		endif
			
		XLSHEET.RANGE(cPutRange).rows.Autofit
		
		*Supuestamente crea un Borde en el Encabezado.
		*Worksheets("Hoja1").Range("A1:D4").BorderAround _
		*		ColorIndex:=3, Weight:=xlThick
		*		
		cRango="A1:"+cLetra2+ltrim(str(alen(gatitu)))
		DIMENSION aItem(4)
			aItem[1]=7
			aItem[2]=8
			aItem[3]=9
			aItem[4]=10
		for xi=1 to alen(aitem)
			WITH xlSheet.Range(cRango).Borders.Item(aItem[xi])
				.LineStyle=1
				.ColorIndex=56
			endwith
		next
		if xtGatitu#"X"
			niRow=alen(gatitu)+1
			ngRows=alen(gaSubTit)+niRow
			cRango="A"+ltrim(str(niRow))+":"+cLetra2+ltrim(str(ngRows))
			DIMENSION aItem(2)
			aItem[1]=7
			aItem[2]=10
			for xi=1 to alen(aitem)
				WITH xlSheet.Range(cRango).Borders.Item(aItem[xi])
					.LineStyle=1
					.ColorIndex=56
				endwith
			next	
		ENDIF
		*.BorderAround(1,56)
		*expresión.BorderAround(LineStyle, Weight, ColorIndex, Color)
		
		*Worksheets("Hoja1").Range("a1:g1"). _
		 *   Borders.Item(xlEdgeBottom).LineStyle = xlDouble
		* Determina el ancho utilizado de la hoja
		nRAnge=xlsheet.range(cPutRange).Width
		*Messagebox(ltrim(str(nRange+aPagSetup[2])))
		oExcel.Windows(1).DisplayZeros=.f.
		nRowRep=alen(gatitu)+1+nAddCol
		cRango="$1:$"+ltrim(str(nRowREp))
		kScrache=this.Scrache(.T.)
		
		
		
		WITH XLSHEET.PageSetup
			.TopMargin = aPagSetup[1]
			.LeftMargin= aPagSetup[2]
			.RightMargin=12
			.BottomMargin=24
			.Orientation=iif(nRange+aPagSetup[2]>547,2,1)
		*	.PrintTitleRows=xlSheet.Rows(nRowRep).address()
			.PrintTitleRows =cRango
			if xnAddPag#0
				xcAddPag=ltrim(str(xnAddPag))
		*		kaddput=[&P+]
		*		.RightHeader="&08 Pag &P+xnAddPag"
			*	.RightHeader="&08 Hoja &P+"+XcADDPAG
			*	.RightHeader="&08 Hoja &P+"+XcADDPAG
				.RightHeader=Chr(38)+"08 Hoja "+Chr(38)+"P+"+xcAddPag
			else
				.RightHeader="&08 Pag &P de &N"
			endif	
			if lScrache
				.LeftFooter="&08 &kscrache"
			endif
			if xlOnePage
				.Zoom = .f.
				.FitToPagesTall = 1
				.FitToPagesWide = 1	
			endif	
		endwith
		*Worksheets("Hoja1").PageSetup.RightFooter = "&P"
		if xlProteger
		*	xlSheet.ProtectContents
			cProte=iif(empty(th_clavus),"",Th_clavus)
			XLsHEET.Protect(cProte)
		endif
		oexcel.Windows(1).DisplayGridlines=.f.
		if lastrow>24
		*	oexcel.Windows(1).SplitRow = nColHeader
			cRango="A"+LTRIM(STR(nColHeader+1))
			XLSHEET.Range(cRango).Select
			oexcel.Windows(1).FreezePanes=.t.
		endif
		if !empty(xcGuardar)
		*? "Guardando como &kelibro"
			WAIT WINDOW "Guardando como &keLibro" AT 12,15 NOWAIT 
			kelibro.SaveAs(xcGuardar)
		endif
		*release mensajero
		WAIT WINDOW "Procedimiento Terminado" AT 12,15 NOWAIT 
		WAIT clear
		
		
		Oexcel.VISIBLE=.T.
		
		STORE null TO oExcel,xlSheet
		
		RETURN .T.
		*ENDPROC
	ENDPROC

	PROCEDURE gscript
		LPARAMETERS xcfile
		* Se define objEmp (empty) como Public para emplear 
		* como ControlSource de los formularios de parámetros 
		* e informe de resultados (si el script devuelve un objeto)
		*----------------------------------------------------------
		* tags
		*----------------------------------------------------------
		* <EXECSCRIPT><PARAMETERS><PROPERTIES>
		*!*	<EXECSCRIPT>
		*!*	LPARAMETERS xdia1,xdia2
		*!*	... (Sentencias use, Select ,etc )
		*!*	sum all gravado,nogravado,exeiva,impiva,anoins,total to nGra,nNogra,nExe,nIva,nAno,nTot
		*!*	
		*!*	loEmpty=NewObject("Empty")
		*!*	Addproperty(loEmpty,"Gravado",ngra)
		*!*	Addproperty(loEmpty,"NoGravado",nNogra)
		*!*	addproperty(loEmpty,"Exento",nExe)
		*!*	addproperty(loEmpty,"Iva",nIva)
		*!*	addproperty(loEmpty,"Total",nTot)
		*!*	addproperty(loEmpty,"Close","Tabla1,Tabla2,Tabla3")	&& delega el cierre de tablas y cursores
		*!*	return loEmpty										&& devuelve una clase "empty"
		*!*	</EXECSCRIPT>
		
		*!*	<PARAMETERS>
		*!*	<XDIA1=D,Primer Dia/>	<Param = Tipo , Caption />
		*!*	<XDIA2=D,Ultimo Dia/>
		*!*	</PARAMETERS>
		
		*!*	<PROPERTIES>	&& INFORMA EL NOMBRE DE LAS PROPIEDADES DEL OBJETO "Empty Class"
		*!*	Gravado
		*!*	NoGravado
		*!*	Exento
		*!*	Iva
		*!*	Total
		*!*	</PROPERTIES>
		*!*	La propiedad "Close" no debe informarse en <Properties>. gScript detecta su existencia
		*!*	---------------------------------------------------------------------------------------
		
		RELEASE objEmp
		PUBLIC objEmp
		
		LOCAL lnHand,lcGet,lScript,lnfop,fcr,loResp,;
			lBad,i,lnPas,lPasParam,lnParam,ln,nt,oCnt,;
			oform,lnDevProp,lRetProp,lcCAr,lcVal,lcTypVar,;
			lnqTablas,lnUsed,lcStore,lcComp,lcSep,lcWork,;
			ngaTit,it,jt,nocOpen,nocShut,nPar,lcExtract
		
		STORE "" TO lcWork
		LOCAL ARRAY gaStick(2,2),galines(1),gatem(1),gaProp(1),;
			gaUsed(1),gaTitulo(1),gaPares(1)
		gaStick[1,1]="<EXECSCRIPT>"
		gaStick[2,1]="</EXECSCRIPT>"
		fcr=ADDBS(_Screen.dtemp)+"scrfile.txt"
		
		lnQtablas=AUSED(gaUsed)
		STORE 0 TO lnPas,lnParam,lnDevProp
		TRY
			LOCAL loex as Exception
			DELETE FILE &fcr
		CATCH TO loEx
			loex.UserValue=PROGRAM()
			this.showerror(loex)
		FINALLY
			STORE -1 TO lnHand,lnFop
		ENDTRY
		
		* Intenta apertura de archivo
		IF !this.getfopen(xcfile,@lnhand,.f.,0)
			RETURN
		ENDIF
		objEmp=NEWOBJECT("Empty")
		ADDPROPERTY(objEmp,"gaParam[1]","")
		
		* COMPROBACIon de etiquetas necesarias
		* Detección de parámetros (<PARAMETERS>)
		* Detección de propiedades devueltas en un objeto empty (<PROPERTIES>)
		
		lcStore=""
		TRY
			LOCAL loex as Exception
			SET EXACT ON
			DO WHILE !FEOF(lnHand)
				lcGet=UPPER(CHRTRAN(FGETS(lnHand,8096),CHR(9),""))
				lcComp=ALLTRIM(lcGet)
				DO case
					CASE LEFT(lcComp,LEN("<SCRIPT|C|="))=="<SCRIPT|C|="
						LcWork=This.getvaltag(lcGet)
						LOOP
						
					CASE LEFT(lcComp,LEN("<EXECSCRIPT>"))=="<EXECSCRIPT>"
						nas=ASCAN(gaStick,lcGet)
						IF nas#0
							gaStick[nas+1]=.t.
						ENDIF
						lSCript=.t.
						LOOP
					
					CASE LEFT(lcComp,LEN("</EXECSCRIPT>"))=="</EXECSCRIPT>"
						nas=ASCAN(gaStick,lcGet)
						IF nas#0
							gaStick[nas+1]=.t.
						ENDIF
						lScript=.f.
						STRTOFILE(lcStore,fcr,0)
						LOOP
					
					CASE LEFT(lcComp,LEN("<PARAMETERS>"))=="<PARAMETERS>"
						lPasParam=.t.
						LOOP
					
					CASE LEFT(lcComp,LEN("</PARAMETERS>"))=="</PARAMETERS>"		
		
						lPasParam=.f.
						LOOP
					
					CASE LEFT(lcComp,LEN("<PROPERTIES>"))=="<PROPERTIES>"		
						lRetProp=.t.
						LOOP
					
					CASE LEFT(lcComp,LEN("</PROPERTIES>"))=="</PROPERTIES>"			
						lRetProp=.F.
						LOOP
					
				
				ENDCASE	
		
				IF lPasParam
		*!*				lcGet=STREXTRACT(lcGet,"<","/>")
		*!*				nl=ALINES(gaLines,lcGet,1,"=")
		
					nl=ALINES(gaLines,STREXTRACT(lcGet,"<","/>"),1,"=")
					IF nl=2
						lcVar=gaLines[1]
						lcVal=null
						lcCar=""
						nt=ALINES(gatem,gaLines[2],1,",")
						lcTypVar=UPPER(gatem[1])
						IF nt>1
							lcCar=gatem[2]
						ENDIF
					
						DO case
							CASE lcTypVar$'IN'
								lcVal=0
							CASE lcTypVar="D"
								LCvAL=CTOD("")
							CASE lcTypVar="T"
								LCVAL=TTOD("")
							CASE lcTypVar="L"
								lcVal=.f.
							OTHERWISE
								lcVal=""
						ENDCASE
						*ADDPROPERTY(objEmp,lcVar,lcval)
						lnParam=lnParam+1
						DIMENSION objEmp.gaParam(lnParam,3)
						objEmp.gaParam[lnParam,1]=lcVal
						objEmp.gaParam[lnParam,2]=lcCar
						objEmp.gaParam[lnParam,3]=lcTypVar
					ENDIF
				
		
				ENDIF
				IF lRetProp
					lnDevProp=lnDevProp+1
					DIMENSION gaProp(lnDevProp)
					gaProp[lnDevProp]=lcGet
				ENDIF
				IF lScript
					lcGet=ALLTRIM(lcget)
					IF RIGHT(lcGEt,1)=";"
						lcSep=CHR(32)
						lcGet=LEFT(lcGet,LEN(lcGet)-1)
					ELSE
						lcSep=CHR(13)
					ENDIF
					
					lcStore=lcStore+lcGet+lcSep
				ENDIF
			ENDDO
			SET EXACT OFF
		
		CATCH TO loEx
			loex.UserValue=PROGRAM()+" Reading file "+xcfile
			
		FINALLY
			
			=FCLOSE(lnHand)
		ENDTRY
		* si hubo error
		IF VARTYPE(loEx)="O"
			RETURN
		ENDIF
		
		* Consulta etiquetas necesarias
		lBad=.f.
		FOR i=1 TO ALEN(gaStick,1)
			IF !gaStick[i,2]
				lBAd=.t.
				EXIT
			ENDIF
		ENDFOR
		IF lbad
			MESSAGEBOX("El archivo &xcFile no contiene las etiquetas necesarias.",0,"gScript Message")
			RETURN
		ENDIF
		
		
		* Test de archivo de script
		IF !FILE(fcr)
			MESSAGEBOX("No se creó el archivo Script",0,"gScript Message")
			RETURN
		ENDIF
		
		* Si tiene parámetros, presenta un formulario para relleno de parámetros
		IF lnParam#0
			ADDPROPERTY(_screen,"miform",null)
			ADDPROPERTY(_screen,"RespGo",.f.)
			
			this.gscriptform(_screen.MiForm,JUSTSTEM(xcFile)+" Parámetros",lnParam,objEmp,.f.)
			
			IF !_screen.respgo
				* Coloca una respuesta inexistente
				* Se abandonó el form de parámetros sin aceptar
				lnParam=999
			ENDIF
		ENDIF
		
		
		
		* Try de Script y respuesta de Script
		TRY
			LOCAL loex as Exception
			WAIT WINDOW "Procesando ExecScript..." AT 12,15 NOWAIT 
			DO case
				CASE lnParam=0
					loResp=EXECSCRIPT(FILETOSTR(fcr))
				CASE lnParam=1
					loResp=EXECSCRIPT(FILETOSTR(fcr),objEmp.gaParam[1,1])
				CASE lnParam=2
					loResp=EXECSCRIPT(FILETOSTR(fcr),objEmp.gaParam[1,1],;
						objEmp.gaparam[2,1])
				CASE lnParam=3
					loResp=EXECSCRIPT(FILETOSTR(fcr),objEmp.gaParam[1,1],;
						objEmp.gaparam[2,1],;
						objEmp.gaparam[3,1])
				CASE lnParam=4
					loResp=EXECSCRIPT(FILETOSTR(fcr),objEmp.gaParam[1,1],;
						objEmp.gaparam[2,1],;
						objEmp.gaparam[3,1],;
						objEmp.gaParam[4,1])
		
				CASE lnParam=5
					loResp=EXECSCRIPT(FILETOSTR(fcr),objEmp.gaParam[1,1],;
						objEmp.gaparam[2,1],;
						objEmp.gaparam[3,1],;
						objEmp.gaParam[4,1],;
						objEmp.gaParam[5,1])		
				CASE lnParam=6
					loResp=EXECSCRIPT(FILETOSTR(fcr),objEmp.gaParam[1,1],;
						objEmp.gaparam[2,1],;
						objEmp.gaparam[3,1],;
						objEmp.gaParam[4,1],;
						objEmp.gaParam[5,1],;
						objEmp.gaParam[6,1])	
				CASE lnParam=7
					loResp=EXECSCRIPT(FILETOSTR(fcr),objEmp.gaParam[1,1],;
						objEmp.gaparam[2,1],;
						objEmp.gaparam[3,1],;
						objEmp.gaParam[4,1],;
						objEmp.gaParam[5,1],;
						objEmp.gaParam[6,1],;				
						objEmp.gaParam[7,1])
						
				CASE lnParam=8
					loResp=EXECSCRIPT(FILETOSTR(fcr),objEmp.gaParam[1,1],;
						objEmp.gaparam[2,1],;
						objEmp.gaparam[3,1],;
						objEmp.gaParam[4,1],;
						objEmp.gaParam[5,1],;
						objEmp.gaParam[6,1],;
						objEmp.gaParam[7,1],;								
						objEmp.gaParam[8,1])
						
						
						
			ENDCASE
			WAIT clear
			
			* Tratamiento de la respuesta de Script (loResp Objeto Empty)
			IF VARTYPE(loResp)="O" 
			
				* El objeto puede tener una propiedad "Close" que delega
				* la responsabilidad del cierre de cursores y tablas
				* en gScript.
				lcExeCute=""
				IF PEMSTATUS(loResp,"Execute",5)
					lcExecute=UPPER(ALLTRIM(loresp.execute))
				ENDIF
				IF !EMPTY(lcExeCute)
					DO CASE 
						CASE lcExeCute=="<EXCEL>"
							STORE "" TO TTCOL,TTHEA,TTSUM,lcExport,lctitulo
							lctitulo=EVL(lcWork,"Listado")
				
							IF PEMSTATUS(loResp,"MSE_EXPORT",5)
								lcExport=loResp.MSE_export
							ENDIF
							IF PEMSTATUS(loResp,"MSE_TITLE",5)
								LcTitulo=loResp.MSE_title
							ENDIF
		
							* <Variables en el título>
							
							IF AT("<<",lctitulo)>0
		
							TRY
								LOCAL loError as Exception	
								
								ngaTit=ALINES(gaTitulo,lctitulo,5,",")
								lctitulo=""
								FOR it=1 TO ngaTit
									nocOpen=OCCURS("<<",gaTitulo[it])
									nocshut=OCCURS(">>",gaTitulo[it])
									IF nocOpen=nocShut AND !EMPTY(nocOpen)
										nPar=ALINES(gapares,gaTitulo[it],16,">>")
										FOR jt=1 TO nPar
		
											IF AT("<<",gaPares[jt])#0
												lcExtract=ALLTRIM(STREXTRACT(gaPares[jt],"<<",">>"))
												PutValor=""
												IF LOWER(LEFT(lcExtract,5))=="param"
													lnOrden=VAL(SUBSTR(lcExtract,6))
													PutValor=objEmp.gaParam[lnOrden,1]
												ENDIF
												IF EMPTY(PUtValor)
													IF PEMSTATUS(loResp,lcExtract,5)
														PutValor=loResp.&lcExtract
													ENDIF
												ENDIF
												
												gaPares[jt]=LEFT(gaPares[jt],MAX(0,AT("<<",gaPares[jt])-1));
												+" ";
												+this.Qualifer2(PutValor,,,.t.)
		
											ENDIF
											
										ENDFOR
										gaTitulo[it]=""
										FOR jt=1 TO nPar
											gaTitulo[it]=gaTitulo[it]+gaPares[jt]
										NEXT
										
									ENDIF
									lcTitulo=lcTitulo+gaTitulo[it]+","
								NEXT
								CATCH TO loError
									loError.UserValue=PROGRAM()
									This.Showerror(loError)
								FINALLY
								ENDTRY
							ENDIF
							
							* </Variables en el titulo>			
		
					
										
							IF PEMSTATUS(loResp,"MSE_columns",5)
								ttcol=loresp.MSE_columns
							ENDIF
							IF PEMSTATUS(loResp,"MSE_Headers",5)
								tthea=loresp.MSE_headers
							ENDIF
							IF PEMSTATUS(loresp,"MSE_sum",5)
								ttsum=loresp.MSE_Sum
							ENDIF
		
							ALINES(gatitulo,lctitulo,5,",")
							IF !EMPTY(lcExport)
								this.gexcel(lcExport,ttcol,tthea,ttsum,@gaTitulo)
							ENDIF
							
							
					ENDCASE
				ENDIF
				
				
				IF PEMSTATUS(loResp,"close",5)
					lnClose=ALINES(gaClose,loResp.close,1+4,",")
					FOR i=1 TO lnClose
						IF USED(gaClose[i])
							SELECT (gaClose[i])
							USE
						ENDIF
					ENDFOR
				ENDIF
				
				IF lnDevProp > 0
					FOR i=1 TO lnDevProp
						lcCar=PROPER(gaprop[i])
						lcVal=loresp.&lcCar
						lcTypVar=VARTYPE(lcVal)
						lnParam=lnParam+1
						DIMENSION objEmp.gaParam(lnParam,3)
						objEmp.gaParam[lnParam,1]=lcVal
						objEmp.gaParam[lnParam,2]=lcCar
						objEmp.gaParam[lnParam,3]=lcTypVar		
					NEXT
				ENDIF
					
				* Crea un formulario con la respuesta
				ADDPROPERTY(_screen,"FrmResp",null)
				this.gscriptform(_screen.frmREsp,JUSTSTEM(xcFile)+" Respuesta",lnParam,objEmp,.t.)
			
			ENDIF
			
		CATCH TO loex
			loex.UserValue=PROGRAM()+" ExecScript: "+fcr
			this.showerror(loex)
		FINALLY
			WAIT clear
			
			objEmp=null
			loResp=null
			RELEASE objEmp,loResp
			IF PEMSTATUS(_screen,"Miform",5)
				REMOVEPROPERTY(_screen,"MiForm")
			ENDIF
			IF PEMSTATUS(_screen,"RespGo",5)
				REMOVEPROPERTY(_screen,"RespGo")
			ENDIF
			IF PEMSTATUS(_screen,"frmResp",5)
				REMOVEPROPERTY(_screen,"FrmREsp")
			ENDIF
			
		ENDTRY
		* Comprobación de Tablas abiertas al inicio y al cierre
		lnUsed=AUSED(gaUsed)
		IF lnqTablas # lnUsed
			MESSAGEBOX(TRANSFORM(lnqTablas)+" Tablas abiertas al inicio";
				+CHR(13)+TRANSFORM(lnUsed)+" Tablas abiertas al cierre",0,"Caution")
		ENDIF
		
		
			
	ENDPROC

	PROCEDURE gscriptform
		LPARAMETERS xoForm,xcCaption,xnItems,xobjEmpty,xlReadonly
		LOCAL lnTop,lnMax,i,lcName,lci,lcTypValor,lcCartel
		lnTop=3
		lnMax=0
		xcCaption=EVL(xcCaption,"Parameters")
		
		*xoForm=CREATEOBJECT("form")
		xoForm=NEWOBJECT("FrmBas","clases\prssys.vcx")
		WITH xoForm
			.Windowtype=1
			.MaxButton=.f.
			.MinButton=.f.
			.backcolor=RGB(184,201,197)
			.Caption=xcCaption
		ENDWITH
		xoForm.NEWOBJECT("Cnt0","CntBas","clases\prssys.vcx")
		xoForm.cnt0.top=1
		xoForm.cnt0.left=1
			
		FOR i=1 TO xnItems
			lci=Transform[i]
			lcTypValor=xobjEmpty.gaParam[i,3]
			lcCartel=xobjEmpty.gaparam[i,2]
			lcName="Cnt"+TRANSFORM(i)
			xoForm.cnt0.newobject(lcname,"CntLab","clases\prssys.vcx")
			WITH xoForm.Cnt0
				.&lcName..left=3
				.&lcName..top=lntop
				.&lcName..gLab1.Caption=PROPER(lcCartel)
				.&lcName..Visible=.t.
			ENDWITH
				
			lntop=lnTop+xoForm.Cnt0.&lcName..Height-2
		
			DO case
				CASE lcTypValor="D"
					xoForm.Cnt0.&lcName..NewObject("text1","dtext","clases\prssys.vcx")
						
				CASE lcTypValor$"NI"
					xoForm.Cnt0.&lcName..NewObject("text1","ntext","clases\prssys.vcx")
				CASE lcTypValor="C"
					xoForm.Cnt0.&lcName..NewObject("text1","gtext","clases\prssys.vcx")
				CASE lcTypValor="L"
					xoForm.Cnt0.&lcName..NewObject("text1","gCheck","clases\prssys.vcx")
			ENDCASE
			WITH xoForm.Cnt0.&lcName.
				.Text1.top=.gmarco1.top+IIF(lcTypValor="L",2,0)
				.Text1.Left=IIF(lcTypValor="L",5,70)
				IF lcTypValor="L"
					.Text1.Caption=PROPER(lcCartel)
					.gLab1.visible=.f.
					.gmarco1.width=this.wokupas(PROPER(lcCartel))+.text1.width+10
					*.text1.width+.gmarco1.left
					.width=.gmarco1.left+.gmarco1.width + 3
				ELSE
					.width=.Text1.left+.Text1.Width + 3
				ENDIF
				.text1.readonly=xlREadonly
				.TExt1.Visible=.t.
				.Text1.ControlSource='xobjEmpty.gaParam[&lci,1]'
				
			ENDWITH	
		
			lnMax=MAX(lnMax,xoForm.Cnt0.&lcName..Width)	
		NEXT
		WITH xoForm.Cnt0
			.Height=lnTop+5
			.Width=lnMax+4
			.visible=.t.
		ENDWITH
		WITH xoForm
			.height=.Cnt0.Height+29
			.Width=.Cnt0.Width+1
			.AutoCenter=.t.
			.Minbutton=.f.
			.MaxButton=.f.
		ENDWITH
		xoForm.newObject("CmGo1","CmGo","clases\prssys.vcx")
		xoform.newObject("Cntcopy1","CntCopy","clases\prssys.vcx")
		WITH xoForm
			.CmGo1.top=.Height-.Cmgo1.Height-3
			.Cmgo1.left=.Width-.Cmgo1.Width-3
			.Cmgo1.Visible=.t.
			.CntCopy1.top=.Height-.Cntcopy1.Height-3
			.Cntcopy1.left=3
			.Cntcopy1.visible=.t.
		ENDWITH
		xoForm.show()
		
	ENDPROC

	PROCEDURE gstandalone
		LOCAL lCreate
		lCreate=.T.
		
		IF PEMSTATUS(_screen,"oFrmPrsSys",5)
			IF VARTYPE(_screen.oFrmPrsSys)="O"
				*_screen.oFrmPrsSys.Release
				_Screen.oFrmPrsSys.WindowState=0
				_Screen.oFrmPrsSys.Show()
				lCreate=.F.
			ELSE
				_screen.oFrmPrsSys=null	
			ENDIF
		
		ENDIF
		IF lCreate
			ADDPROPERTY(_Screen,"oFrmPrsSys", NEWOBJECT("Main",LOCFILE("Recursive.vcx"))) 
			_Screen.oFrmPrsSys.NewObject("oCnt1","cntGen",LOCFILE("prssys.vcx"))
			*,"",FULLPATH(""),lcDirSale)
		ENDIF
		WITH _Screen.oFrmPrsSys
			* Dimensiona el form
			.Height=.oCnt1.Height+2						
			.Width=.oCnt1.Width+2
			.ocnt1.top=1
			.ocnt1.left=1
			* Establece la propiedad visible del Container
			.oCnt1.Visible=.t.
			.Show()
		ENDWITH
		
		
		
	ENDPROC

	PROCEDURE gtablastru
		LPARAMETERS xnHand,xcCursor,xcRootTable,xcTabla,xnTally,xnLevel
		LOCAL lcSeparDat,i,gnTableHead,gnREgistros,gnFileSize
		LOCAL ARRAY gaFields(1)
		lcSeparDat=EVL(this.separdat,CHR(28))
		=FPUTS(xnHand,REPLICATE(CHR(9),xnLevel)+"<TABLE="+xcTabla+">")
		SELECT (xcCursor)
		gnTableHead = HEADER( )
		gnREgistros = Reccount()
		*** Calcula el tamaño de la tabla. ***
		gnFileSize =  gnTableHead + ( RECSIZE() * gnRegistros + 1)
		
		xnLevel=xnLevel+1
		=FPUTS(xnHand,This.PutTag("ROOT",xcRootTable,xnLevel))
		=FPUTS(xnHand,This.PutTag("RECORDS",xnTally,xnLevel))
		=FPUTS(xnHand,This.PutTag("FIELDS",FCOUNT(),xnLevel))
		=FPUTS(xnHand,This.PutTag("HEADER_SIZE",gnTableHead,xnLevel))
		=FPUTS(xnHand,This.PutTag("TABLE_SIZE",gnFileSize,xnLevel))
		=FPUTS(xnHand,REPLICATE(CHR(9),xnLevel)+"<STRUCTURE>")
		
		
		
		lnFields=AFIELDS(gaFields,xcCursor)
		STORE "" TO lcField,lcType,lcWidth,lcDecimal
		FOR i=1 TO lnFields
			lcField=lcField+gaFields[i,1]+","
			lcType=lcType+gaFields[i,2]+","
			lcWidth=lcWidth+TRANSFORM(gaFields[i,3])+","
			lcDecimal=lcDecimal+transform(gaFields[i,4])+","
		NEXT
		xnLevel=xnLevel+1
		=FPUTS(xnHand,This.PutTag("FIELDS",LCFIELD,xnLevel))
		=FPUTS(xnHand,This.PutTag("TYPES",LCTYPE,xnLevel))
		=FPUTS(xnHand,This.PutTag("WIDTHS",LCWIDTH,xnLevel))
		=FPUTS(xnHand,This.PutTag("DECIMALS",LcDecimal,xnLevel))
		xnLevel=xnLevel-1
		=FPUTS(xnHand,REPLICATE(CHR(9),xnLevel)+"</STRUCTURE>")
		
		
		
		SELECT (xcTabla)
		lnTagInd=ATAGINFO(gaTagInfo,xctabla)
		=FPUTS(xnHand,REPLICATE(CHR(9),xnLevel)+"<TAG_INFO>")
		IF lnTagINd#0
			
			FOR i=1 TO ALEN(gaTagInfo,1)
				LcPut=This.PutTag("TAG_NAME",gaTagInfo[i,1]);
					+This.PutTag("TAG_TYPE",gaTagInfo[i,2]);
					+This.PutTag("TAG_KEY",gaTAgInfo[i,3]);
					+This.PutTag("TAG_FILTER",gaTagInfo[i,4]);
					+This.PutTag("TAG_ORDER",gaTagInfo[i,5]);
					+This.PutTag("TAG_COLLATE",gaTagInfo[i,6])
				
				=FPUTS(xnHand,REPLICATE(CHR(9),xnLevel+1)+lcPut)
			NEXT
		ENDIF
		=FPUTS(xnHand,REPLICATE(CHR(9),xnLevel)+"</TAG_INFO>")
		
		=FPUTS(xnHand,REPLICATE(CHR(9),xnLevel)+"<REG>")
		xnLevel=xnLevel+1
		SELECT (xcCursor)
		SCAN
			lcPut=""
			FOR i=1 TO LnFields
				kVar=EVALUATE(FIELD(i))
				IF gafields[i,2]$'CM'
					kvar=CHRTRAN(kvar,["],['])
					kvar=CHRTRAN(kvar,lcSeparDat,"")
				ENDIF
				lcPut=lcPut+This.Qualifer(kvar,gaFields[i,2],lcSeparDat)
			NEXT
			=FPUTS(xnHand,REPLICATE(CHR(9),xnLevel)+lcPut)
		ENDSCAN
		xnLevel=xnLevel-1
		=FPUTS(xnHand,REPLICATE(CHR(9),xnLevel)+"</REG>")
		xnLevel=xnLevel-1
		=FPUTS(xnHand,REPLICATE(CHR(9),xnLevel)+"</TABLE="+xctabla+">")
		SELECT (xcCursor)
		USE
		
		
	ENDPROC

	PROCEDURE Init
		DIMENSION THIS.GAshut(1)
		this.separdat=CHR(28)
		this.testmessage()
		*	lcTabla="MOVIM"
		*	lcList=""
		*	lcText="gMovim"
		*	dia1=DATE(2012,1,1)		PRIVATE
		*	dia2=DATE(2012,12,31)	PRIVATE
		*	lcWhere=[FECHA BETWEEN DIA1 AND DIA2]
		*	OBJ=NEWOBJECT("prsfun","clases\prssys.vcx")
		*	obj.genPrs(lcText,lcTabla,lcList,lcwhere)
		*	RELEASE obj
		
		
		******************************************************
		*	OBJ=NEWOBJECT("prsfun","clases\prssys.vcx")
		*	lcResp=obj.GenCursor(xcTextFile)
		*	release obj
		*	if Isnull(lcResp)
		*		return
		*	endif
		*	select (lcResp)
		*	browse
		*	use
		*******************************************************		
		
	ENDPROC

	PROCEDURE invertirnumero
		LPARAMETERS xnInterger,xnFlag
		* --------------------------------------
		* xnInterger es un número entero
		* xnInterger puede ser String o Numeric
		* Si xnFlag=0, devuelve un numeric
		* Si xnFlag=1, devuelve un String
		* --------------------------------------
		IF VARTYPE(xnFlag)#"N"
			xnFlag=0
		ENDIF
		IF !BETWEEN(xnFlag,0,1)
			xnFlag=0
		ENDIF
		
		LOCAL lcInterger, lcRespuesta,i
		STORE "" TO lcRespuesta
		
		DO CASE 
			CASE VARTYPE(xnInterger)$'NI'
				lcInterger=TRANSFORM(xnInterger)
			CASE VARTYPE(xnInterger)="C"
				lcInterger=ALLTRIM(xnInterger)
			OTHERWISE
				RETURN IIF(EMPTY(xnFlag),0,"")
		ENDCASE
		
		FOR i=LEN(lcInterger) TO 1 STEP -1
			lcRespuesta=lcRespuesta+SUBSTR(lcInterger,i,1)
		ENDFOR
		
		RETURN IIF(xnFlag=0,VAL(lcRespuesta),lcRespuesta)
		
	ENDPROC

	PROCEDURE keletra
		lparameters xnPos
		*Function keletra(xnPos)
		***********************
		local array aLetra(26)
		aLetra[1]=[A]
		aLetra[2]=[B]
		aLetra[3]=[C]
		aLetra[4]=[D]
		aLetra[5]=[E]
		aLetra[6]=[F]
		aLetra[7]=[G]
		aLetra[8]=[H]
		aLetra[9]=[I]
		aLetra[10]=[J]
		aLetra[11]=[K]
		aLetra[12]=[L]
		aLetra[13]=[M]
		aLetra[14]=[N]
		aLetra[15]=[O]
		aLetra[16]=[P]
		aLetra[17]=[Q]
		aLetra[18]=[R]
		aLetra[19]=[S]
		aLetra[20]=[T]
		aLetra[21]=[U]
		aLetra[22]=[V]
		aLetra[23]=[W]
		aLetra[24]=[X]
		aLetra[25]=[Y]
		aLetra[26]=[Z]
		if xnPos<=26
			cREturn=aletra[xnPos]
		else
			nqpos=xnpos/26
			iqpos=Int(xnpos/26)
			rqpos=Int((xnPos/26-iqpos)*26+0.00009)
			* En los múltiplos de 26, rqpos dará 0,
			* por lo que:
			*
			if rqpos=0
				iqpos=iqpos-1
				rqpos=26
			endif
			
			let1=aletra[iqpos]
			let2=aletra[rqpos]
			cReturn=let1+let2
		endif
		REturn cReturn
		
	ENDPROC

	PROCEDURE managediff
		TRY
			LOCAL loex as Exception
			ADDPROPERTY(_screen,"mndiff",NEWOBJECT("FrmBas","clases\prssys.vcx"))
			_Screen.mndiff.NewObject("CntDiff1","CntDiff","clases\prssys.vcx")
			WITH _Screen.mndiff
				.CntDiff1.top=1
				.CntDiff1.left=1
				.CntDiff1.visible=.t.
				.Height=.CntDiff1.Height+1
				.Width=.CntDiff1.Width+1
				.Caption="FoxBin2prg » Analizar Aplicación"
				.MaxButton=.f.
				.MinButton=.f.
			ENDWITH
			_Screen.mndiff.AutoCenter=.t.
			_Screen.mnDiff.Show()
		CATCH TO loex
			loex.UserValue=PROGRAM()
			LOCAL objFun
			objFun=NEWOBJECT("prsfun","clases\prssys.vcx")
			objFun.ShowError(loEx)
		FINALLY
			objFun=null
		ENDTRY
		
		
		
	ENDPROC

	PROCEDURE model
				DO case
					CASE LEFT(lcComp,LEN("<EXECSCRIPT>"))=="<EXECSCRIPT>"
						lScript=.t.
						LOOP
					
					CASE LEFT(lcComp,LEN("</EXECSCRIPT>"))=="</EXECSCRIPT>"
		
						lScript=.f.
						LOOP
					
					CASE LEFT(lcComp,LEN("<PARAMETERS>"))=="<PARAMETERS>"
						ldefParam=.t.
						LOOP
					
					CASE LEFT(lcComp,LEN("</PARAMETERS>"))=="</PARAMETERS>"		
		
						ldefParam=.f.
						LOOP
					
					CASE LEFT(lcComp,LEN("<PROPERTIES>"))=="<PROPERTIES>"		
						lProper=.t.
						LOOP
					
					CASE LEFT(lcComp,LEN("</PROPERTIES>"))=="</PROPERTIES>"			
		
						lProper=.f.
						LOOP
					
				
				ENDCASE
	ENDPROC

	PROCEDURE netuse
		**********************************************************
		LPARAMETERS xcTabla, xlExclusive, nSeconds ,ptAlias
		**********************************************************
		* Procedimiento de apertura de tablas
		* xlExclusive .f. (shared) // xlExclusive (.t.) Exclusive
		
		LOCAL lForever,lRetop,NCASOP,aproof,ktway,lcAlias
		ptAlias=iif(Vartype(ptalias)#"C","",ptalias)
		nSeconds=iif(Vartype(nSeconds)#"N",3,nSeconds)
		nCasop=0
		xcTabla=upper(alltrim(xcTabla))
		xcAlias=JustStem(xcTabla)
		ktway=JustPath(xcTabla)
		aproof=iif(empty(ptalias),xcAlias,ptAlias)
		if used(aproof)
			* El archivo ya está abierto - no hace nada
			return .t.
		endif
		*FullFile=Alltrim(xcTabla)+".dbf"
		Fullfile=addbs(ktway)+xcAlias+".dbf"
		if !file(FullFile)
			messageBox("El archivo "+Fullfile+" No Existe!"+CHR(13);
		   		+"Prog: "+Program(2)+" Línea: "+ltrim(str(lineno())),0,_screen.th_mensaje)
			Return .f.
		ENDIF
		DO WHILE .t.
			IF EMPTY(ptAlias)
				lcAlias=JUSTSTEM(xcTAbla)
				IF xlExclusive 
					USE (xcTabla) IN 0 EXCLUSIVE
				ELSE
					USE (xcTabla) IN 0 SHARED
		 		ENDIF
			ELSE
				lcAlias=ptAlias
				IF xlExclusive       
					USE (xcTabla) IN 0 AGAIN alias (ptAlias) EXCLUSIVE
				ELSE
					USE (xcTabla) IN 0 AGAIN ALIAS (ptAlias) SHARED
			 	ENDIF	
			
			ENDIF
			IF USED(lcAlias)
				lRetop=.t.
				EXIT
			ENDIF
			
			nCasop=nCasop+1
			if nCasop<=nSeconds
				loop
			endif
			lRetop=.f.
			nMess=Messagebox("&xcTabla no pudo abrirse tras "+ltrim(str(nCasop))+" intentos.",5,_screen.th_mensaje)
			if nmess=4
				loop
			else
				exit
			endif
			
		ENDDO
		
		return lretop
		
	ENDPROC

	PROCEDURE opentemp
		LPARAMETERS xcFile
		LOCAL lcRoot,lcTabla
		lcTAbla=IIF(AT("\",xcfile)#0,JUSTSTEM(xcfile),xcfile)
		IF USED(lcTabla)
			RETURN .t.
		ENDIF
		IF !This.Netuse(xcFile,.f.,3)
			RETURN .f.
		ENDIF
		SELECT (lcTabla)
		lnItem=ALEN(this.gashut)+1
		DIMENSION this.gashut(lnItem)
		this.gashut[lnItem]=lcTabla
		RETURN .t.
		
		
	ENDPROC

	PROCEDURE pmltag
		LPARAMETERS xcTAg,xnLevel,xlClose,xnFlag
		*!*	Genera un tag abierta con xnLevel desplazamiento
		*!*	0 - Nada
		*!*	1 - Upper
		*!*	2 - Proper
		*!*	3 - Lower
		*!*	------------------------------------------------------
		IF VARTYPE(xnLevel)#"N"
			xnLevel=0
		ENDIF
		
		DO case
			CASE VARTYPE(xnFlag)="L"
				xnFlag=""
			CASE VARTYPE(xnFlag)="N"
				xnFlag=TRANSFORM(xnFlag)
		ENDCASE
		
		DO case
			CASE EMPTY(xnFlag)
		
			CASE xnFlag$'uU1'
				xcTag=UPPER(xctag)
				
			CASE xnLfag$'pP2'
				xcTag=PROPER(xctag)		
				
			CASE xnFlag$'lL3'
				xcTag=LOWER(xcTag)
		
		ENDCASE
		RETURN REPLICATE(CHR(9),xnLevel)+IIF(xlClose,"</","<")+ALLTRIM(xctag)+">"
		
	ENDPROC

	PROCEDURE printproof
		LOCAL lcPrinter,I,LnCopias,j,LnMaxLines,lnCount,lnPag
		lnMaxLines=62
		lnCopias=2
		lnCount=0
		LOCAL ARRAY gaPrint(100)
		#DEFINE PR_MARGEN 5
		#DEFINE PR_FONT "Lucida Console"
		#DEFINE PR_SIZE 8
		#DEFINE PR_STYLE "N"
		
		* Prepara el trabajo a imprimir en un ARray (gaprint)
		FOR i=1 TO ALEN(gaprint)
			gaprint[i]=PADR("Texto enviado "+TRANSFORM(i),40);
				+TRANSFORM(ROUND(1260*i/93,2),"999,999.99")+" ";
				+TRANSFORM(ROUND(18*36/i,2),"999,999.99")
		NEXT
		
		* Selección de la impresora
		lcPrinter=GETPRINTER()
		
		IF EMPTY(lcPrinter)
			RETURN
		ENDIF
		
		* Activa la impresora seleccionada
		SET CONSOLE OFF
		SET PRINTER TO NAME (lcPrinter)
		
		* Preguntar estado de la impresora (Vertical u Horizontal)
		do while PrtInfo(1)#0	&& si no está en vertical
			Messagebox("&lcPrinter"+chr(13)+"Seleccione Orientación Vertical.",0,_screen.th_mensaje)
			sys(1037)	
		ENDDO
		SET PRINTER ON
		
		* Comienza la impresión
		FOR j=1 TO lnCopias
			lnCount=0
			lnPag=0
			FOR i=1 TO ALEN(gaPrint)
				IF PROW()=0
					lnPag=lnPag+1
					? "Empresa Impresiones" at 1 FONT "Arial",12 STYLE "B"
					? "Domicilio Empresa Impresiones" at 1 FONT "Arial",10 STYLE "N"
					?? "Copia "+TRANSFORM(j)+" » Pag "+TRANSFORM(lnPag) ;
						at 100 FONT "Arial",8 STYLE "N"
					? REPLICATE(CHR(151),70) AT 1 FONT "Arial",8 STYLE "N"
					? PADR("Descripción",40)+" ";
						+PADC("Columna1",10)+" ";
						+PADC("Columna2",10) at PR_MARGEN FONT PR_FONT,PR_SIZE STYLE PR_STYLE
					? REPLICATE(CHR(151),70) AT 1 FONT "Arial",8 STYLE "N"		
					lnCount=5
				ENDIF
		
				? gaPrint[i] at PR_MARGEN font PR_FONT,PR_SIZE STYLE PR_STYLE
				lnCount=lnCount + 1
				IF lnCount>lnMaxLines
					EJECT
				ENDIF
				
			NEXT
			IF j<lnCopias
				EJECT
			ENDIF
		NEXT
		* Cierra la impresora seleccionada
		SET CONSOLE ON
		Set Printer Off
		SEt printer to
		
	ENDPROC

	PROCEDURE puttag
		LPARAMETERS xcClave,xcValor,xnLevel,xcForceType,xlNotype,xcSep1,xcSep2
		****************************************************************************
		* PROCEDURE This.This.PutTag(xcClave,xcValor,xnLevel,xcForceType,xlNotype,xcSep1,xcSep2)
		****************************************************************************
		* Genera una Tag Cerrada
		*!*		xcClave:		Clave de etiqueta
		*!*		xcValor:		Valor de la etiqueta
		*!*		xnLevel:		Desplazamiento de escritura (REPLICATE(CHR(9),xnLevel)
		*!*		xcForceType:	Tipo Forzado (I,E,S) cuando se necesita un comportamiento especial
		*!*		xlNoType:		Etiqueta no calificada (cerrada normal)
		*!*		xcSep1:			Separador de apertura	("<" default)
		*!*		xcSep2:			Separador de cierre		("/>" default)
		*-----------------------------------------------------------------------------------------
		* xlNotype=.F. (Default)
		* <NOMBRE|N|1250.12/> (tipo numérico)
		* <DIA|D|25/12/2013/> (Tipo date)
		* <RESOLVE|E|SQRT( lnCateto1**2 + lnCateto2**2 )/>
		* <PROCEDE|S|MESSAGEBOX("Resultado="+LTRIM(STR(lnResp,14,4)))/>
		*---------------------------------------------------------------
		* Los tipos "CNLDT" se autocalifican
		* This.This.PutTag("VALOR",2012) genera: "<VALOR|N|=2012/>"
		* This.This.PutTag("ESTADO",.T.) genera: "<ESTADO|L|.T./>"
		* This.This.PutTag("CUIT","20120482980") genera "<CUIT|C|=2012048298/>"
		* This.This.PutTag("FECHA",17/12/2013")  genera "FECHA|D|=17/12/2013/>"
		*
		*-------------------------------------------------------------------------
		* Definición forzada
		*
		*	Escritura
		*	LOCAL lcform,lcPut
		*	LCFORM=""
		*	TEXT TO LCFORM TEXTMERGE NOSHOW PRETEXT 7
		*	<<This.This.PutTag("LNRESP",0,0,"*N")>>
		*	<<This.This.PutTag("LNCATETO1",12,0,"*N")>>
		*	<<This.This.PutTag("LNCATETO2",20,0,"*N")>>
		*	<<This.This.PutTag("LNRESP","SQRT( lnCateto1**2 + lnCateto2**2 )",0,"*E")>>
		*	<<This.This.PutTag("LNRESP","(lnResp+LnResp**2)/2",0,"*E")>>
		*	<<This.This.PutTag("MESSAGE",[MESSAGEBOX("Resultado="+LTRIM(STR(lnResp,14,4)))],0,"S")>>
		*	ENDTEXT
		*
		*	LcFile=ADDBS(fULLPATH(""))+"Formula.txt"
		*	STRTOFILE(lcForm,lcFile)
		*
		*	Nota: En xcForceType se utiliza "*", pero también se puede utilizar
		*	      cualiquier otro símbolo que no sea una letra
		*	      También se podría escribir a la inversa, "E*" en lugar de "*E"   	
		*
		*-------------------------------------------------------------------------------------
		*	REsultado (Archvivo Formula.txt)
		*	<LNRESP|N#|=0/>						&& define lnREsp=0
		*	<LNCATETO1|N#|=12/>					&& define LnCateto1=12
		*	<LNCATETO2|N#|=20/>					&& define LnCateto2=20
		*	<LNRESP|E#|=SQRT( lnCateto1**2 + lnCateto2**2 )/> 	&& lnResp=Sqrt(ln..."
		*	<LNRESP|E#|=(lnResp+LnResp**2)/2/>			&& lnResp=(lnResp+lnResp**2)/2
		*	<MESSAGE|S|=MESSAGEBOX("Resultado="+LTRIM(STR(lnResp,14,4)))/>
		*
		*	Nota: Al ejecutar, el Messagebox mostrará "Resultado=283.6619"
		*
		*---------------------------------------------------------------
		* Ejemplo para type "S" [ ExecScript() ]
		*	*Generación de la etiquta
		*
		*	LOCAL lcform,lcPut
		*	LCFORM=""
		*	TEXT TO LCFORM NOSHOW PRETEXT 7
		*	USE C:\THEODORE\ALOJA IN 0 EXCLUSIVE
		*	SELECT ALOJA
		*	IF RECCOUNT()>10
		*		GO 10
		*		replace valchar WITH "RGB() FUNCTION"
		*	ENDIF
		*	BROWSE
		*	USE
		*	ENDTEXT
		*
		*	LCPUT="SCRIPT"
		*	LcFile=ADDBS(Fullpath(""))+"ScripTag.txt"
		*	STRTOFILE(This.This.PutTag(lcPut,lcForm,,"S"),lcFile)
		*
		*	*Ejecuta procedimiento
		*	LcFile=ADDBS(FullPath(""))+"ScripTag.txt"
		*	=This.GetValTag(FILETOSTR(lcFile))
		*-----------------------------------------------------
		
		LOCAL lcType,lcPutVal,lcAddComm
		STORE "" TO lcAddComm
		lcType=VARTYPE(xcValor)
		IF VARTYPE(xcForceType)="C" AND !EMPTY(xcForceType) 
			xcForceType=UPPER(ALLTRIM(xcForceType))
			IF LEN(xcForceType)>1
				xcForceType=This.ValidTExt(xcForceType,2)
				lcAddComm="#"
			ENDIF
			IF xcForceType$'CNDTLES'
				lcType=xcForceType
				xlNotype=.F.
				IF lcType="S"
					xcValor=CHRTRAN(xcValor,CHR(10),"")
					xcValor=CHRTRAN(xcValor,CHR(13),CHR(28))
				ENDIF
				
			ENDIF
		ENDIF
		
		
		DO case
			CASE lcType="N"
		
				LcPutVal=ltrim(str(xcValor,20,this.TelDecim(xcValor)))
			CASE LCTYPE="L"
				lcPutVal=IIF(xcValor,".T.",".F.")
			CASE lcType="D"
				lcPutVal=DTOC(xcValor)	
			CASE lcType="T"
				lcPutVal=TTOC(xcValor)
			CASE lcType="X"
				LcPutVal=".null."
			CASE lcType="O"
				lcPutVal="Object Reference"
			OTHERWISE
				LcPutVal=xcValor
		ENDCASE
		
		IF VARTYPE(xcSep1)#"C" OR EMPTY(xcSep1)
			xcSep1="<"
		ENDIF
		IF VARTYPE(xcSep2)#"C" OR EMPTY(xcSep2)
			xcSep2="/>"
		ENDIF
		IF VARTYPE(xnLevel)#"N"
			xnLevel=0
		ENDIF
		lcType=lcType+lcAddComm
		RETURN REPLICATE(CHR(9),xnLevel);
			+xcSep1;
			+ALLTRIM(xcClave);
			+IIF(xlNoType,"","|"+lcType+"|");
			+"=";
			+ALLTRIM(lcPutVal);
			+xcSep2
		
	ENDPROC

	PROCEDURE qualifer
		LPARAMETERS xDato,xcTipo,xcSymbol,xlNotQuotes
		***************************************
		* Calificador de datos simil Delimited
		
		LOCAL lcQuot,lcClin,lcRemp
		lcQuot=IIF(xlNotQuotes,[],["])
		if vartype(xcSymbol)#"C" OR empty(xcSymbol)
			xcSymbol=","
		endif
		LOCAL kvt,vret,qdezim
		*lparameters xdato
		* n,i,c,d,l
		*kvt=vartype(xDato)
		kvt=EVL(xcTipo,VARTYPE(xDato))
		vret=""
		lcClin=CHR(9)+CHR(10)+CHR(13)
		lcRemp=REPLICATE("",3)
		do case
			CASE kvt="C"
				vret=lcQuot+alltrim(strtran(xdato,xcSymbol))+lcQuot	
			case kvt="M"
				xDato=CHRTRAN(xDato,lcClin,lcRemp)
				vret=lcQuot+alltrim(strtran(xdato,xcSymbol))+lcQuot
			case kvt="N"
				qDezim=TelDecim(xDato)
				vret=ltrim(str(xDato,20,qDezim))
			case kvt="L"
				vret=iif(xdato,".T.",".F.")	
			case kvt="D"
				vret=dtoc(xdato)
			case kvt="T"
				vret=ttoc(xdato)
			case kvt="I"
				vret=transform(xdato)
			OTHERWISE
			
			
		endcase
		
		return vret+xcSymbol
		
		
	ENDPROC

	PROCEDURE qualifer2
		LPARAMETERS xDato,xcTipo,xcSymbol,xlNotQuotes
		***************************************
		* Calificador de datos simil Delimited
		* Retorna el dato sin agregado de calificador.
		
		LOCAL lcQuot,lcClin,lcRemp
		lcQuot=IIF(xlNotQuotes,[],["])
		if vartype(xcSymbol)#"C" OR empty(xcSymbol)
			xcSymbol=","
		endif
		LOCAL kvt,vret,qdezim
		*lparameters xdato
		* n,i,c,d,l
		*kvt=vartype(xDato)
		kvt=EVL(xcTipo,VARTYPE(xDato))
		vret=""
		lcClin=CHR(9)+CHR(10)+CHR(13)
		lcRemp=REPLICATE("",3)
		do case
			CASE kvt="C"
				vret=lcQuot+alltrim(strtran(xdato,xcSymbol))+lcQuot	
			case kvt="M"
				xDato=CHRTRAN(xDato,lcClin,lcRemp)
				vret=lcQuot+alltrim(strtran(xdato,xcSymbol))+lcQuot
			case kvt="N"
				qDezim=TelDecim(xDato)
				vret=ltrim(str(xDato,20,qDezim))
			case kvt="L"
				vret=iif(xdato,".T.",".F.")	
			case kvt="D"
				vret=dtoc(xdato)
			case kvt="T"
				vret=ttoc(xdato)
			case kvt="I"
				vret=transform(xdato)
			OTHERWISE
			
			
		endcase
		
		return vret
		
	ENDPROC

	PROCEDURE quitcntparam		&& Quitar una barra de parámetros
		LPARAMETERS oCnt
		LOCAL lnBarra,lnCount,objform,i,oControl,lnobj
		LOCAL ARRAY gaObjetos(1)
		lnObj=0
		lnBarra=ocnt.numbarra
		objForm=oCnt.parent
		*!*	MESSAGEBOX("objForm="+VARTYPE(objForm):
		*!*		+" Clase "+IIF(VARTYPE(objForm)="O",objForm.baseClass,"Nada");
		*!*		+" objEmpty.CntCount="+TRANSFORM(objEmpty.CntCount))
		
		lnCount=objEmpty.cntCount
		IF lnCount=1
			* Cuando queda un solo container, solo limpia los valores
			FOR i=1 TO 3
				objEmpty.gadob[1,i]=""
			NEXT
			FOR EACH ocontrol IN oCnt.Controls
				IF INLIST(oControl.baseClass,"Textbox","Combobox","Editbox")
					oControl.refresh
				ENDIF
			NEXT
		ELSE
			* Cuando quedan más de 1 Container
			* Borra todos los containers
			* Ajusta el array objEmpty.gadob
			* Vuelve a crear los containers
			TRY
				LOCAL loExcep as Exception
				FOR EACH oControl IN objForm.Controls
					IF oControl.baseclass="Container"
						*objForm.removeObject(oControl.name)
						lnObj=lnObj+1
						DIMENSION gaObjetos(lnObj)
						gaObjetos[lnObj]=oControl.Name
						* trata de eliminar los controlSource
						FOR EACH obINc IN ocontrol.Controls
							IF INLIST(obInc.baseclass,"Textbox","Editbox","Combobox")
								obInc.ControlSource=""
							ENDIF
						ENDFOR
					ENDIF
				ENDFOR
				objForm.Shapegen.Visible=.f.
				objForm.LockScreen=.t.
				FOR i=1 TO lnObj
					
					objForm.RemoveObject(gaObjetos[i])
				NEXT
			
				ADEL(objEmpty.gadob,lnBarra)
				DIMENSION objEmpty.gadob(lnCount-1,3)
		
				FOR i=1 TO lncount - 1
					this.addcntparam(objForm,.f.,IIF(i=lnCount-1,.f.,.t.))
				NEXT
		
			CATCH TO loExcep
				loexcep.UserValue=PROGRAM()
				this.showerror(loExcep)
			FINALLY
				objForm.Shapegen.Visible=.t.	
				objForm.LockScreen=.F.
				FOR EACH oControl IN objForm.Controls
					IF oControl.baseclass="Container"
						oControl.glab3.MousePointer=15
						oControl.glab3.enabled=.t.
					ENDIF
				ENDFOR
				
			ENDTRY
			
		ENDIF
		
	ENDPROC

	PROCEDURE quitcntprop
		LPARAMETERS oCnt
		LOCAL lnBarra,lnCount,objform,i,oControl,lnobj,lncols
		LOCAL ARRAY gaObjetos(1)
		lnObj=0
		lnBarra=ocnt.numbarra
		objForm=oCnt.parent
		
		
		
		lnCount=objEmpty.cntCount
		lnCols=ALEN(objEmpty.gadob,2)
		
		IF lnCount=1
			* Cuando queda un solo container, solo limpia los valores
			FOR i=1 TO ALEN(objEmpty.gadob)
				objEmpty.gadob[1,i]=""
			NEXT
			FOR EACH ocontrol IN oCnt.Controls
				IF INLIST(oControl.baseClass,"Textbox","Combobox","Editbox")
					oControl.refresh
				ENDIF
			NEXT
		ELSE
			* Cuando quedan más de 1 Container
			* Borra todos los containers
			* Ajusta el array objEmpty.gadob
			* Vuelve a crear los containers
		
			TRY
				LOCAL loExcep as Exception
				objForm.Shapegen.Visible=.f.		
				objForm.lockScreen=.t.
		
				FOR EACH oControl IN objForm.Controls
					IF oControl.baseclass="Container" AND !INLIST(UPPER(ocontrol.name),"OCLOSE")
						lnObj=lnObj+1
						DIMENSION gaObjetos(lnObj)
						gaObjetos[lnObj]=oControl.Name
						* trata de eliminar los controlSource
						FOR EACH obINc IN ocontrol.Controls
							IF INLIST(obInc.baseclass,"Textbox","Editbox","Combobox")
								obInc.ControlSource=""
							ENDIF
						ENDFOR
					ENDIF
				ENDFOR
				FOR i=1 TO lnObj
					
					objForm.RemoveObject(gaObjetos[i])
				NEXT
				IF objEmpty.gadob[lnBarra,3]#0
					objEmpty.nDelete=objEmpty.Ndelete+1
					DIMENSION objEmpty.gadel[objEmpty.nDelete]
					objEmpty.gadel[objEmpty.nDelete]=objEmpty.gadob[lnBarra,3]
				ENDIF
				
				
				ADEL(objEmpty.gadob,lnBarra)
				DIMENSION objEmpty.gadob(lnCount-1,lnCols)
		
				FOR i=1 TO lncount - 1
					this.addcntprop(objForm,.F.,IIF(i=lnCount-1,.f.,.t.))
				NEXT
			CATCH TO loExcep
				loexcep.UserValue=PROGRAM()
				this.showerror(loExcep)
			FINALLY
				objForm.Shapegen.visible=.t.
				objForm.lockScreen=.F.
				
			ENDTRY
			
		ENDIF
		
	ENDPROC

	PROCEDURE redmemory
		*****************************************************************************************
		* PROCEDURE....:     ReduceMemory()
		* Author......:  Bernard Bout
		* Date........:  05/12/2007 3:03:15 PM
		* Returns.....:
		* Parameters..:
		* Notes.......:  reduces memory usage for vfp
		*****************************************************************************************
		*PROCEDURE ReduceMemory()
		
		Declare Integer SetProcessWorkingSetSize In kernel32 As SetProcessWorkingSetSize  ;
		    Integer hProcess , ;
		    Integer dwMinimumWorkingSetSize , ;
		    Integer dwMaximumWorkingSetSize
		Declare Integer GetCurrentProcess In kernel32 As GetCurrentProcess
		nProc = GetCurrentProcess()
		bb = SetProcessWorkingSetSize(nProc,-1,-1)
		
	ENDPROC

	PROCEDURE scrache
		LPARAMETERS xlVerbose
		LOCAL dFecha,dHora,lcTerm
		LOCAL ARRAY gaSys(1)
		ln=ALINES(gaSys,SYS(0),1,"#")
		lcFecha=DTOC(DATE())
		lctime=TIME()
		RETURN IIF(xlVerbose,;
			"Emitido por "+gasys[1]+" el "+lcFecha+" a las "+lcTime,;
			"Emitido por "+gasys[1]+", "+lcFecha+", "+lcTime)
			
		
		
	ENDPROC

	PROCEDURE showerror
		LPARAMETERS objExcep
		LOCAL lcMens
		lcMens="Fecha "+TRANSFORM(DATETIME());
			+CHR(13)+"Mensaje: "+objExcep.message;
			+CHR(13)+"ErrorNo: "+TRANSFORM(objExcep.Errorno);
			+CHR(13)+"Llamada: "+objExcep.Uservalue 
		IF VERSION(2)#0
			lcMens=lcMens+CHR(13)+"Línea: "+TRANSFORM(objExcep.lineNo)
		ENDIF
		
		STRTOFILE(lcMens+CHR(13),"ThError.log",1)
		lcMens="Se ha producido un error:"+chr(13)+lcMens
		MESSAGEBOX(lcMens,0,_screen.th_mensaje)
		
		
		
	ENDPROC

	PROCEDURE teldecim
		LPARAMETERS xcnNUmero,xnPrecision
		*****************************************
		* Determina la cantidad de decimales de un número.
		* xnPrecision podría ser Entre 10 y 16
		* 16 daría una precisión mayor pero válida para
		* números con alta cantidad de decimales.
		*********************************************
		local i_,LnNumero,lnpNum,cRest,;
			nDecimales,lcTipVar
		if vartype(xnprecision)#"N"
			xnPrecision=10
		endif
		lcTipVar=Vartype(xcnNumero)
		do case
			case lcTipVar="C"
				LnNumero=val(xcnNumero)
			case lcTipVar$'NI'
				LnNumero=xcnNumero
			other
				return 0
		endcase
		if LnNumero=0
			return 0
		endif
		nDecimales=16
		for i_=0 to 16
			lnpNum=Round(LnNumero*10**i_,xnPrecision)
			cRest=lnpNum-Int(lnpNum)
			nDecimales=i_
			if Round(cRest,xnPrecision)=0
				exit
			endif
		next
		return nDecimales
		
	ENDPROC

	PROCEDURE testmessage
		IF !PEMSTATUS(_Screen,"th_mensaje",5)
			ADDPROPERTY(_screen,"th_mensaje","Mensaje del Sistema")
		ENDIF
		
	ENDPROC

	PROCEDURE textoplano
		LPARAMETERS xcTexto
		LOCAL lcREturn,i,j,lcchar,lnChar,lnGo
		lcReturn=""
		LOCAL ARRAY agachar[140]
		agaChar[1]=153
		agaChar[2]=161
		agaChar[3]=166
		agaChar[4]=169
		agaChar[5]=171
		agaChar[6]=174
		agaChar[7]=187
		agaChar[8]=188
		agaChar[9]=189
		agaChar[10]=190
		agaChar[11]=191
		agaChar[12]=193
		agaChar[13]=196
		agaChar[14]=201
		agaChar[15]=203
		agaChar[16]=205
		agaChar[17]=207
		agaChar[18]=209
		agaChar[19]=211
		agaChar[20]=214
		agaChar[21]=218
		agaChar[22]=220
		agaChar[23]=225
		agaChar[24]=228
		agaChar[25]=233
		agaChar[26]=235
		agaChar[27]=237
		agaChar[28]=239
		agaChar[29]=241
		agaChar[30]=243
		agaChar[31]=246
		agaChar[32]=250
		agaChar[33]=252
		agaChar[34]=224
		agaChar[35]=232
		agaChar[36]=236
		agaChar[37]=242
		agaChar[38]=249
		agaChar[39]=192
		agaChar[40]=200
		agaChar[41]=204
		agaChar[42]=210
		agaChar[43]=217
		agaChar[44]=9
		agaChar[45]=10
		agaChar[46]=13
		lnChar=31
		lnGo=46
		FOR j=1 TO 94
			lnChar=lnChar+1
			lngo=lngo+1
			agachar[lnGo]=lnchar
		NEXT
		FOR i=1 TO LEN(xcTexto)
			lcchar=SUBSTR(xcTexto,i,1)
			IF ASCAN(agachar,ASC(lcChar))#0
				lcReturn=lcReturn+lcChar
			ENDIF
		NEXT
		RETURN lcReturn
		
	ENDPROC

	PROCEDURE toexcel
		*!*	Addproperty(loempty,"ExeCute","<EXCEL>")
		*!*	ADDPROPERTY(loempty,"Export","MSCAMION")
		*!*	addproperty(loEmpty,"Title","Transporte Los Primos,Camiones")
		*!*	ADDPROPERTY(loEmpty,"columns","chofer,dni,patente,acoplado,fletero")
		*!*	ADDPROPERTY(loEmpty,"headers","chofer,dni,patente,acoplado,fletero")
		*!*	addproperty(loEmpty,"sumcolumns","")
	ENDPROC

	PROCEDURE trycopy
		LPARAMETERS xoObject,xlOmitDef
		
		LOCAL nlen,oparent,I,ocontrol,xcValor
		IF !xlOmitDef
			RELEASE objCopy
			PUBLIC objCopy
			objCopy=NEWOBJECT("Empty")
			ADDPROPERTY(objCopy,"gatom[1,2]","")
			ADDPROPERTY(objCopy,"level",1)	
			ADDPROPERTY(objCopy,"cString","")
			
		ENDIF
		DO case
			CASE xoObject.baseClass="Form"
				FOR EACH oControl IN xoObject.Controls
					this.trycopy(oControl,.t.)
				ENDFOR	
			CASE xoObject.baseClass="Container"
				
				STORE "" TO objCopy.gatom	
				FOR EACH oControl IN xoObject.Controls
					this.trycopy(oControl,.t.)
				ENDFOR	
					
				IF !EMPTY(objCopy.gatom[1]) AND !EMPTY(objCopy.gatom[2])
					objCopy.cString=objCopy.cString ;
						+ objCopy.gatom[1] + CHR(9) + objCopy.gatom[2] + CHR(13)
					STORE "" TO objCopy.gatom							
				ENDIF
		
				
			CASE xoObject.baseclass="Label"
				objCopy.gatom[1]=xoObject.caption
			CASE xoObject.baseclass="Textbox"
				xcValor=xoObject.value
				DO CASE
					CASE VARTYPE(xcValor)="D"
						objCopy.gatom[2]=DTOC(xcValor)
					CASE VARTYPE(xcValor)="N"
						objCopy.gatom[2]=CHRTRAN(LTRIM(STR(xcValor,14,2)),".",",")
					
					OTHERWISE
						objCopy.gatom[2]=ALLTRIM(xcValor)
					
				ENDCASE
				
			CASE xoObject.baseclass="Combobox"
				objCopy.gatom[2]=ALLTRIM(xoObject.Value)
			CASE xoObject.baseclass="Checkbox"
				objCopy.gatom[1]=xoObject.caption
				objCopy.gatom[2]=TRANSFORM(xoObject.value)
			OTHERWISE
			
				
		ENDCASE
		
		RETURN
		
	ENDPROC

	PROCEDURE unpackprs
		LPARAMETERS xcFile,xcClaveId,xcProceso,xlCopete,xlForceInd,xcRootApply,xcRootServ
		* Construye un cursor a partir de un archivo *.prs
		* xcfile= "archivoTexto.prs"
		* -------------------------------------------------
		LOCAL nFap,nfop,fcr,ln,lnfiles,i,lnREcords,lReadStruc,;
			lcNameCur,lREadRec,lClosefap,lcGet,lcReturn,;
			lvClaveId,lvProceso,lCopete,lnCount,lnGen,;
			lcIdProceso,lcProceso,lcTagId,xi,ji,;
			LcHoraGen,ldFechaGen,lcterminal,;
			lctProceso,lctIdproc,lctFecha,lctHora,lctTermi,;
			lctSalon,lctIdCarga,lctBase,lctUser,lctNetUser,;
			lcUser,lcNetUser,lOkey,lTagINfo,lnti,lnEtiq,lnc,;
			lcSeparator,lcProcedure,lReadProc,lcRoot,lMOdifi,;
			lModifi,nf,lcAli,lcNew,lcIndborr,lnTagIn,lForceMod
			
		lcSeparator=","
		STORE 0 TO lnFiles,ln,i,lnREcords,lnCount,lnGen,lnti,lnEtiq,lnc,lnTagIn
		STORE "" TO lcNameCur,lcIdProceso,lcProceso,lcTagId,;
			LcHoraGen,lcterminal,;
			lctProceso,lctIdproc,lctFecha,lctHora,lctTermi,;
			lctSalon,lctIdCarga,lctBase,;
			lctNetUse,lctUser,lcNetUser,lcUser,lcProcedure
		
		STORE CTOD("") TO ldfechagen
		lOkey=.T.
			
		LOCAL ARRAY gaTablas(1,3),gaIndices(1),;
			gatypes(1),gaCampos(1),gaWids(1),gaDec(1),gaStruc(1),gaExist(1),;
			gaCdx(1),gaTagInfo(1)
			 
		STORE "" TO gaTablas
		fcr=ADDBS(_Screen.dtemp)+"transdat.txt"
		IF FILE(fcr)
			DELETE FILE &fcr
		ENDIF
		
		
		lvClaveId=!EMPTY(xcClaveId)
		lvProceso=!EMPTY(xcProceso)
		nfop=-1
		IF !This.GetFopen(xcfile,@nfop,.F.,0)
			RETURN
		ENDIF
		FSEEK(nfop,0,0)
		* lFlags: lCopete*copete, lReads, lTagInfo, lReadREc*Reg
		DO WHILE !FEOF(nFop)
			
			lcGet=FGETS(nfop,8192)
			lcGEt=ALLTRIM(CHRTRAN(lcGet,CHR(9),""))
			IF lcGet=="</TRANSDAT>"
				EXIT
			ENDIF
			
			* Cancela estructura de tag
			IF LEFT(lcGet,2)="</"
				DO case
					CASE lcGet=="</REG>"
					* Cancela lectura de registros
						lREadRec=.f.
						IF lnRecords#lnCount
							MESSAGEBOX("Records en prsfile="+TRANSFORM(lnRecords)+CHR(13);
							+"Records procesados="+TRANSFORM(lnCount))
						ENDIF
						LOOP
						
		
					* CAncela lectura de tabla
					CASE LEFT(lcGEt,LEN("</TABLE="))=="</TABLE="
						RELEASE loEx
						TRY
							lcUse=ADDBS(lcRoot)+lcNameCur
							lcUseInd=FORCEEXT(lcUse,"cdx")
							lforceMod=.f.				
							IF xlForceInd
								lForceMod=.t.
							ELSE
								IF lnEtiq = lnTagIn
									FOR i=1 TO lnEtiq
										FOR j=1 TO 6
											IF gaTagInfo[i,j]#gaCdx[i,j]
												lforceMod=.t.
												EXIT
											ENDIF
										NEXT
									NEXT
								ELSE
									lForceMOd=.t.
								ENDIF
							ENDIF
						CATCH TO loEx
							loexcep.UserValue=PROGRAM()+"<Cursor="+lcNameCur+"/>"
							this.showerror(loExcep)				
						FINALLY
						
						ENDTRY
									
		
						RELEASE loExcep
						TRY
							LOCAL loExcep as Exception
							IF lForceMod OR !FILE(lcUseInd)				
								IF USED(LcNameCur)
									SELECT (lcNameCur)
									USE
								ENDIF
								
								USE (lcUse) IN 0 EXCLUSIVE
								
								SELECT (lcNameCur)
								DELETE TAG all
								FOR si=1 TO LnEtiq
									lcInd=gaIndices[si]
									&lcInd
								NEXT
						
								USE
								lnGen=lnGen+1
								gaTablas[lnGen,1]=lcNameCur
								gaTablas[lnGen,2]=lnRecords
								gaTablas[lnGen,3]=lnCount
						
							ENDIF
							
						CATCH TO loExcep
							loexcep.UserValue=PROGRAM()+"<Cursor="+lcNameCur+"/>"
							this.showerror(loExcep)
						FINALLY
					
							* Limpieza
							IF USED(LcNameCur)
								SELECT (lcNameCur)
								USE
							ENDIF				
							STORE 0 TO lnRecords,lnCount,lnEtiq,lnc,lnTagIn
							DIMENSION gaIndices(1),gastruc(1,4),gaTagInfo(1,6),gaCdx(1)
							STORE "" TO gaIndices,gaTagInfo,gaCdx	
							STORE .f. TO lForceMod								
						ENDTRY
						
						LOOP
					* Cancela lectura de etiquetas de indice					
					CASE lcGet=="</TAG_INFO>"
						lTagInfo=.F.
						LOOP
			
					* Cancela lectura de estructura y crea la tabla SI NO existe
					* Si existe, debe comparar la estructura
					CASE lcGet=="</STRUCTURE>"
						lReadStruc=.f.
						dimension gastruc(lnc,4)
						FOR i=1 TO lnc
							gastruc[i,1]=gaCampos[i]
							gastruc[i,2]=gatypes[i]
							gastruc[i,3]=VAL(gaWids[i])
							gastruc[i,4]=VAL(gaDec[i])
						NEXT
						
						IF EMPTY(lcNameCur)
							LOOP
						ENDIF
						
						TRY
							LOCAL loEx as Exception
							IF USED(lcNameCur)
								SELECT (lcNameCur)
								USE
							ENDIF
							lcCrea=ADDBS(lcRoot)+lcNameCur
							IF !FILE(FORCEEXT(lcCrea,"dbf"))
								CREATE table &lcCrea FREE FROM ARRAY gastruc	
							ELSE
						
								lModifi=.f.
								USE (lcCrea) IN 0 EXCLUSIVE
								nf=AFIELDS(gaExist,lcNameCur)
								lnTagIn=ATAGINFO(gaTagInfo,lcNameCur)
								USE
							
								IF nf # ALEN(gaStruc,1)
									lModifi=.t.
								ELSE
									FOR xi=1 TO ALEN(gastruc,1)
										FOR ji=1 TO ALEN(gastruc,2)
											IF gasTruc[xi,ji]#gaExist[xi,ji]
												lModifi=.t.
												EXIT
											ENDIF
										NEXT
									NEXT
								ENDIF
								IF lModifi
									lcAli="cur"+lcNamecur
									lcNew=ADDBS(_Screen.dtemp)+"cur"+lcAli
									CREATE table &lcNew FREE FROM ARRAY gastruc
									SELECT (lcAli)
									APPEND FROM &lcCrea
									COPY TO &lcCrea
									USE
									lcIndBorr=FORCEEXT(lcCrea,"cdx")
									DELETE FILE &lcIndborr
								
								ENDIF
							ENDIF
						CATCH TO loEx
							loEx.UserValue=PROGRAM()+"<Cursor="+lcNameCur+"/>";
								+"<Tabla="+lcCrea+"/>"
							this.showerror(loEx)
						FINALLY
						ENDTRY
							
						LOOP
						
					* Cancela lectura de copete
					CASE lcGet=="</COPETE>"
						lCopete=.f.
						IF xlCopete	&& cuando se pide solamente el copete (verificación)
							EXIT
						ELSE
							LOOP
						ENDIF
						
					* Cancela la lectura de Procedure
					CASE lcGet=="</PROCEDURE>"
						
						lcProcedure=LEFT(lcProcedure,LEN(lcProcedure)-1)
						IF !EMPTY(lcProcedure)
							EXECSCRIPT(lcProcedure,FORCEEXT(lcCREA,"dbf"))
						ENDIF
						lReadProc=.F.
						LOOP
				ENDCASE
			ENDIF
					
			DO case
				* Abre la lectura del copete	
				CASE lcGEt=="<COPETE>"
					lCopete=.t.		
					LOOP
				
				* inicia lectura de etiquetas de indices
				CASE lcGet=="<TAG_INFO>"
					lTAgInfo=.t.
					LOOP
				
				
				* inicia lectura de estrctura
				CASE lcGet=="<STRUCTURE>"
					lReadStruc=.t.
					LOOP
		
				* inicia lectura de registros	
				CASE LCGET=="<REG>"
					lReadRec=.t.
					LOOP
				
				* inicia lectura de procedures
				CASE lcGet=="<PROCEDURE>"
					lREadProc=.t.
					LOOP
			ENDCASE
			* Nombre de Tabla, records, ruta
			DO case
				
				CASE LEFT(lcGet,7)=="<TABLE="
					lcFra=STREXTRACT(lcGet,"<",">")
					nl=ALINES(gaLines,lcFra,1,"=")
					IF nl=2
						lcNameCur=gaLines[2]
					ENDIF
					WAIT WINDOW "Transdat "+gaLines[2]+"..." AT 12,20 nowait
					LOOP
				CASE LEFT(lcget,12)=="<RECORDS|N|="	
					lcFra=STREXTRACT(lcGet,"<","/>")
					nl=ALINES(gaLines,lcFra,1,"=")
					IF nl=2
						lnRecords=VAL(gaLines[2])
						WAIT WINDOW "Generando &lcNameCur con "+TRANSFORM(gaLines[2])+" registros..." AT 12,20 nowait
					ENDIF
					LOOP
				CASE LEFT(lcGet,LEN("<ROOT|C|="))="<ROOT|C|="
					lcRoot=this.getvaltag(lcGet)
					DO case
					
						CASE LEFT( UPPER(lcRoot) , LEN("*ROOT_APPLY*") )=="*ROOT_APPLY*"
							lcRoot=xcRootApply+SUBSTR(lcRoot,LEN("*ROOT_APPLY*")+1)
		
						CASE left(UPPER(lcRoot),LEN("*ROOT_SERV*"))=="*ROOT_SERV*"
							lcRoot=xcRootServ+SUBSTR(lcRoot,LEN("*ROOT_SERV*")+1) 
					ENDCASE
								
			ENDCASE
			
			* LFLAGS
			
			DO CASE
				CASE lReadProc
					lcProcedure=lcProcedure+lcGet+CHR(13)
		
				CASE lReadRec
					*habilitada la lectura de registros 
		
				*gaTypes
					nf=ALINES(gaVals,lcGet,1,lcSeparator)
					FOR bix=1 TO nf
						lctom=gaVals[bix]
						lcty=gaTypes[bix]
						DO case
							CASE lcty$'CM'
								lcTom=SUBSTR(lcTom,2)
								gaVals[bix]=LEFT(lcTom,LEN(lctom)-1)
							CASE lcTy="D"
								gaVals[bix]=CTOD(lctom)
							CASE lcTy="L"
								gaVals[bix]=IIF(AT("T",LCtOM)#0,.T.,.F.)
							CASE LCTy$'IN'
								gaVals[bix]=VAL(lctom)
						ENDCASE
					NEXT
					INSERT INTO (lcNameCur) FROM ARRAY gaVals			
					lnCount=lnCount+1	
							
				* Lee estructura de índices
				CASE lTagInfo
					lnTi=ALINES(gaTagINf,lcGet,16,"/>")
					iTag=This.GetValTag(gaTAgInf[1])
					iTyp=This.GetValTag(gaTagInf[2])
					iKey=This.GetValTag(gaTAgInf[3])
					iFil=This.GetValTag(gaTagInf[4])
					iOrd=This.GetValTag(gaTAgInf[5])
					iCol=This.GetValTag(gaTAgInf[6])
					lnEtiq=lnEtiq + 1
					DIMENSION gaIndices(lnEtiq),gaCdx(lnEtiq,6)
					gaCdx[lnEtiq,1]=iTag
					gaCdx[lnEtiq,2]=iTyp
					gaCdx[lnEtiq,3]=iKey
					gaCdx[lnEtiq,4]=iFil
					gaCdx[lnEtiq,5]=iOrd
					gaCdx[lnEtiq,6]=iCol
					
					gaindices[lnEtiq]="INDEX ON "+IKEY+" TAG "+ITAG
				
				* Lee estructura de tabla
				CASE lReadStruc	
					lcFra=STREXTRACT(lcGet,"<","/>")
					nl=ALINES(gaLines,lcFra,1,"=")
					IF nl=2
						lcVal=gaLines[2]
						DO CASE
							CASE AT("<FIELDS|C|=",LCGET)#0
								lnc=ALINES(gaCampos,lcVal,5,",")
							CASE AT("<TYPES|C|=",LCGET)#0
								lnt=ALINES(gaTypes,lcVal,5,",")
							CASE AT("<WIDTHS|C|=",LCGET)#0
								lnw=ALINES(gaWids,lcval,5,",")
							CASE AT("<DECIMALS|C|=",LCGET)#0
								lnd=ALINES(gaDec,lcVal,5,",")
						ENDCASE
		
					ENDIF
				
		*!*		Lee copete de archivo
		*!*		<COPETE>
		*!*			<PROCESO|C|=TRANSDAT/>
		*!*			<IDPROCESO|C|=/>
		*!*			<CLAVEID|C|=/>
		*!*			<NETUSER|C|=DAVID/>
		*!*			<USER|C|=FIDEL/>
		*!*			<FECHA|D|=14/12/2013/>
		*!*			<HORA|C|=10:28/>
		*!*			<FILES|N|=1/>
		*!*			<SEPARATOR|N|=28/>
		*!*		</COPETE>	
			
				CASE lCopete	
					DO CASE
						* Validación de Usuario
						CASE LEFT(lcGet,6)=="<CUIT|"
							lcFra=This.GetValTag(lcGet)
							lOkey=IIF(lcFra==MiCuitemp,.t.,.f.)
							IF !lOkey
								MESSAGEBOX("Cuit inválido",0,_screen.th_mensaje)
								EXIT
							ENDIF
		
						* Validación de Proceso		
						CASE LEFT(LCGET,9)=="<PROCESO|"
							lctProceso=lcGet
							lcProceso=This.GetValTag(lcGet)
							IF LVPROCESO
								IF lcProceso==xcProceso
									* Proceso Verificado
								ELSE
									lokey=.f.
									MESSAGEBOX("Descripción de proceso inválida",0,_screen.th_mensaje)
									EXIT
								ENDIF
							ENDIF
						
							
						CASE LEFT(LCGET,11)=="<IDPROCESO|"
							lctIdProc=lcGet
							LcIdproceso=This.GetValTag(lcGet)
							IF VARTYPE(lcIdproceso)="N"
								lcIdproceso=TRANSFORM(lcIdproceso)
							ENDIF
						
				
						CASE LEFT(LCGET,9)=="<CLAVEID|"
							lcClaveId=This.GetValTag(lcGet)
							IF LVCLAVEID
								IF lcClaveId==xcClaveId
									* OK
								ELSE
									MESSAGEBOX("No coincide la clave de identificación",0,_screen.th_mensaje)
									EXIT				
								ENDIF
							ENDIF
						
						
						* Cantidad de Files
						CASE LEFT(lcget,7)=="<FILES|"
						
							lnfiles=This.GetValTag(lcGet)
							IF lnFiles=0
								MESSAGEBOX("No hay tablas incluidas",0,_screen.th_mensaje)
								EXIT
							ENDIF
							DIMENSION gatablas(lnFiles,3)
							STORE "" TO gaTablas
				
						CASE LEFT(lcget,7)=="<FECHA|"
							lctFecha=lcGet
							ldFechagen=This.GetValTag(lcget)
						CASE LEFT(lcGet,6)=="<HORA|"
							lctHora=lcGet
							lcHoraGen=This.GetValTag(lcget)
							
						* Accesorias (válidas para Theodore)	
						CASE LEFT(Lcget,10)=="<TERMINAL|"
							lctTermi=lcGEt
							lcTerminal=This.GetValTag(lcGet)
						CASE LEFT(lcGet,7)=="<SALON|"
							lctSalon=lcGet
						CASE LEFT(lcget,9)=="<IDCARGA|"
							lctIdcarga=lcGet
						CASE LEFT(lcGet,6)=="<BASE|"
							lctBase=lcget
						CASE LEFT(LCGET,14)=="<SEPARATOR|N|="
							lcSeparator=CHR(This.GetValTag(lcGet))
						CASE LEFT(lcget,12)=="<NETUSER|C|="
							lctNetUser=lcGEt
							lcNetUser=This.GetValTag(lcGet)
						CASE LEFT(lcget,9)=="<USER|C|="
							lctUser=lcget
							lcUser=This.GetValTag(lcGet)
					ENDCASE
				
		
				
			ENDCASE
			
		ENDDO
		=FCLOSE(nfop)
		WAIT clear
		
		IF !lOkey
			RETURN ""
		ENDIF
		
		
		nfop=FCREATE(fcr)
		=FPUTS(nfop,This.PutTag("FILE",XCFILE))
		=FPUTS(nfop,lctProceso)
		=FPUTS(nfop,EVL(lctIdproc,"Empty"))
		=FPUTS(nfop,lctFecha)
		=FPUTS(nfop,lctUser)
		=FPUTS(nfop,lctNetUser)
		=FPUTS(NFOP,This.PutTag("FILES",lnFiles))
		IF !xlCopete AND lnFiles#0
			=FPUTS(nfop,"<TABLES>")
			FOR i=1 TO ALEN(gatablas,1)
				lcPut=CHR(9)+gaTablas[i,1]+",";
					+TRANSFORM(gaTAblas[i,2])+",";
					+TRANSFORM(gaTablas[i,3])
				=FPUTS(nfop,lcput)
			NEXT
			=FPUTS(NFOP,"</TABLES>")
		ENDIF
		=FCLOSE(nfop)
		
		RETURN fcr
		
		
	ENDPROC

	PROCEDURE validtext
		LPARAMETERS xcTexto,xnFlag
		***********************************
		IF VARTYPE(xnFlag)#"N"
			xnFlag=0
		ENDIF
		IF !BETWEEN(xnFlag,0,2)
			xnFlag=0
		ENDIF
		**************************************************************
		* xnFlag * Default=0
		* 0 Letras May/min + vocales con acento + numeros + guion bajo
		* 1 Letras May/min + vocales con acento
		* 2 Letras May/Min
		**************************************************************
		LOCAL lcREturn,i,lcchar,lc1
		lcReturn=""
		lc1="abcdefghijklmnñopqrstuvwxyz"
		lc1=lc1+IIF(INLIST(xnFlag,0,1),"áéíóúäëïöüàèìòùâêîôû","")
		Lc1=lc1+UPPER(lc1)+IIF(xnFlag=0,"_0123456789","")
		
		lcReturn=""
		FOR i=1 TO LEN(xcTexto)
			lcchar=SUBSTR(xcTexto,i,1)
			IF AT(LcChar,lc1)#0
				lcReturn=lcReturn+lcChar
			ENDIF
		NEXT
		RETURN lcReturn
		
		
	ENDPROC

	PROCEDURE wokupas
		LPARAMETERS xcTexto,xcFontName,xnFontSize,xcEstilo,xnAdd
		*********************************************************
		* xcTexto: 		Cadena para la que se determina el ancho
		* xcFontName:	Nombre de la fuente (default="Arial")
		* xnFontSize:	Ancho de la fuente  (default=8)
		* xcEStilo:		FontBold ($'NBnb' ; Numeric 0 ó 1 ; boolean)
		* xnAdd:		Pixels que se agregan al determinado (may be < 0)
		*****************************************************************
		xcFontName=EVL(xcFontName,"Arial")
		xnFontSize=EVL(xnFontSize,8)
		xnAdd=EVL(xnADd,0)
		DO case
			CASE VARTYPE(xcEstilo)="L"
				xcEstilo=IIF(xcEstilo,"B","N")
			CASE VARTYPE(xcEstilo)="C"
				xcEstilo=UPPER(xcEstilo)
				IF NOT xcEstilo$'BN'
					xcEstilo="N"
				ENDIF
			CASE VARTYPE(xcEstilo)="N"
				DO case
					CASE xcEstilo=0
						xcEStilo="N"
					CASE xcEStilo=1
						xcEStilo="B"
					OTHERWISE
						xcEstilo="N"
				ENDCASE
				
			OTHERWISE
				xcEstilo="N"
		ENDCASE
		
		nvtex=TxtWidth(xcTExto,xcFontName,xnFontSize,xcEstilo) * FontMetric(6,xcFontName,xnFontSize,xcEstilo)
		if xnAdd=0
			xnAdd=Int(nvTex/20)
		endif
		Return xnAdd+nvTex
	ENDPROC

ENDDEFINE

DEFINE CLASS shape3d AS shape 
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	BackColor = 221,226,222
	Height = 30
	Name = "shape3d"
	SpecialEffect = 0
	Width = 100

ENDDEFINE
